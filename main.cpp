#include "stdafx.h"
#include <iostream>
#include <deque>
#include <regex>
#include <iomanip>
#include <experimental/filesystem>
#include "enet/enet.h"
#include <string>
#include <algorithm> 
#include <cctype>
#include <locale>
#include <cstdio>
#ifdef _WIN32
#include <windows.h>
#include <conio.h>
#endif
#ifdef __linux__
#include <stdio.h>
char _getch() {
	return getchar();
}
#endif
#include <vector>
#include <sstream>
#include <chrono>
#include <fstream>
#include "json.hpp"
#include <thread> // TODO
#include <mutex> // TODO

#pragma warning(disable : 4996)

//#define TOTAL_LOG
#define REGISTRATION
#include <signal.h>
#ifdef __linux__
#include <cstdint>
typedef unsigned char BYTE;
typedef unsigned char byte;
typedef unsigned char __int8;
typedef unsigned short __int16;
typedef unsigned int DWORD;
#endif
//Linux equivalent of GetLastError
#ifdef __linux__
//Linux has no byteswap functions.
ulong _byteswap_ulong(ulong x)
{
	// swap adjacent 32-bit blocks
	//x = (x >> 32) | (x << 32);
	// swap adjacent 16-bit blocks
	x = ((x & 0xFFFF0000FFFF0000) >> 16) | ((x & 0x0000FFFF0000FFFF) << 16);
	// swap adjacent 8-bit blocks
	return ((x & 0xFF00FF00FF00FF00) >> 8) | ((x & 0x00FF00FF00FF00FF) << 8);
}
#endif
#include "gamepacket.h"
#include "server.h"
#include "player.h"

/***bcrypt
*/

int getBlockState(WorldInfo* worldInfo, int x, int y) {
	auto type = 0x00000000, i = x + (y * worldInfo->width);
	if (worldInfo->items.at(i).activated) type |= 0x00400000;
	if (worldInfo->items.at(i).flipped) type |= 0x00200000;
	if (worldInfo->items.at(i).entrance_open) type |= 8388608;
	if (worldInfo->items.at(i).water) type |= 0x04000000;
	if (worldInfo->items.at(i).glue) type |= 0x08000000;
	if (worldInfo->items.at(i).fire) type |= 0x10000000;
	if (worldInfo->items.at(i).red) type |= 0x20000000;
	if (worldInfo->items.at(i).green) type |= 0x40000000;
	if (worldInfo->items.at(i).blue) type |= 0x80000000;
	if (worldInfo->items.at(i).silenced) type |= 0x02000000;
	return type;
}
string jsontostring(json data) {
	stringstream JsonConvert;
	JsonConvert << data;
	string DataNew = JsonConvert.str();
	return DataNew;
}
void Security_Pin(ENetPeer* peer) {
	if (((PlayerInfo*)(peer->data))->haveGrowId == false) return;
	if (((PlayerInfo*)(peer->data))->pin == "") {
		auto p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_label_with_icon|big|`5Account Security``|left|1436|\nadd_textbox|`5Hello there, You can control your account here!``|left|\nadd_button|changepass|`wChange Password``|\nadd_button|enaaapbutton|`2Enable `w2-Step Verification Code``|\nend_dialog|dialog|`wCancel``||"));
		auto respawnTimeout = 500;
		auto deathFlag = 0x19;
		memcpy(p2.data + 24, &respawnTimeout, 4);
		memcpy(p2.data + 56, &deathFlag, 4);
		const auto packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet2);
		delete p2.data;
	}
	else {
		auto p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_label_with_icon|big|`5Account Security``|left|1436|\nadd_textbox|`5Hello there, You can control your account here!``|left|\nadd_button|changepass|`wChange Password``|\nadd_button|enaaapbutton|`w`9Change`` 2-Step Verification Code``|\nadd_button|disableaapbutton|`4Remove `w2-Step Verification Code``|\nend_dialog|dialog|`wCancel``||"));
		auto respawnTimeout = 500;
		auto deathFlag = 0x19;
		memcpy(p2.data + 24, &respawnTimeout, 4);
		memcpy(p2.data + 56, &deathFlag, 4);
		const auto packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet2);
		delete p2.data;
	}
}
void GenerateRegularWorld(WorldInfo* world, int width, int height, int dirtType = 2, int lavaType = 4, int mainDoorType = 6, int bedrockType = 8, int rockType = 10, int caveBackgroundType = 14, int machineId = 0)
{
	world->weather = machineId;
	int mainDoorX = (rand() % (world->width - 4)) + 2;
	for (int i = 0; i < world->width * world->height; i++)
	{
		world->items.at(i).foreground = 0;
	}
	for (int i = 0; i < world->width * world->height; i++)
	{
		if (i >= 3800 && i < 5400 && !(rand() % 50)) { world->items.at(i).foreground = rockType; }
		else if (i >= 3700 && i < 5400) {
			if (i > 5000) {
				int m = rand() % 8;
				if (m < 3) { world->items.at(i).foreground = lavaType; }
				else { world->items.at(i).foreground = dirtType; }
			}
			else { world->items.at(i).foreground = dirtType; }
		}
		else if (i >= 5400) { world->items.at(i).foreground = bedrockType; }

		if (i == 3600 + mainDoorX)
			world->items.at(i).foreground = mainDoorType;
		if (i == 3700 + mainDoorX)
			world->items.at(i).foreground = bedrockType;
		if (i >= 3700)
			world->items.at(i).background = caveBackgroundType;
		//nobody wants grass
		//else if (i >= 3600 && i < 3700)
		//	world->blocks.at(i).foreground = 0; 
	}
}
void GenerateGrowaloneLikeWorld(WorldInfo* world, int width, int height, int dirtType = 2, int lavaType = 4, int mainDoorType = 6, int bedrockType = 8, int rockType = 10, int caveBackgroundType = 14, int wmachineid = 0, int deco1Id = 0, int deco2Id = 0, int id = 0)
{
	world->weather = wmachineid;
	for (int i = 0; i < world->width * world->height; i++)
	{
		WorldItem tiles{};
		tiles.foreground = 0;
		world->items.push_back(tiles);
	}
	int* offset = new int[width];
	int* offset2 = new int[width];
	offset[0] = (height - 60 < 0) ? -10 : height - 60;
	offset2[0] = offset[0] < 0 ? -10 : offset[0];

	auto settile = [](WorldInfo* w, int x, int y, int id) {
		if (x < w->width && x >= 0 && y < w->height && y >= 0)
			w->items[x + y * w->width].foreground = id;
	};
	auto settilebg = [](WorldInfo* w, int x, int y, int id) {
		if (x < w->width && x >= 0 && y < w->height && y >= 0)
			w->items[x + y * w->width].background = id;
	};
	auto gettile = [](WorldInfo* w, int x, int y) {
		if (x < w->width && x >= 0 && y < w->height && y >= 0)
			return w->items[x + y * w->width].foreground;
	};
	auto gettilebg = [](WorldInfo* w, int x, int y) {
		if (x < w->width && x >= 0 && y < w->height && y >= 0)
			return w->items[x + y * w->width].background;
	};

	for (int i = 1; i < width; i++)
	{
		offset[i] = (height - 60 < 0) ? -10 : height - 60;
		int rnd = rand() % 30 - 10;
		if (rnd < -2)
			offset[i] = offset[i - 1] - 1; // rise
		else if (rnd > 11)
			offset[i] = offset[i - 1] + 1; // fall
		else
			offset[i] = offset[i - 1]; // no change
		offset2[i] = offset[i] < 0 ? -10 : offset[i];
	}
	// now we generate the world.
	for (int j = 0; j < width; j++)
	{
		for (int k = 26 + offset[j]; k < height - 5; k++)
		{
			settile(world, j, k, dirtType);
			settilebg(world, j, k, caveBackgroundType);
			int renrnd = rand() % 12;
			if (renrnd > 10)
				settile(world, j, k, rockType);
		}
		settile(world, j, 26 + offset[j], dirtType);
		settilebg(world, j, 26 + offset[j], caveBackgroundType);
		settile(world, j, height - 6, bedrockType);
		settile(world, j, height - 5, bedrockType);
		settile(world, j, height - 4, bedrockType);
		settile(world, j, height - 3, bedrockType);
		settile(world, j, height - 2, bedrockType);
		settile(world, j, height - 1, bedrockType);

		settilebg(world, j, height - 6, caveBackgroundType);
		settilebg(world, j, height - 5, caveBackgroundType);
		settilebg(world, j, height - 4, caveBackgroundType);
		settilebg(world, j, height - 3, caveBackgroundType);
		settilebg(world, j, height - 2, caveBackgroundType);
		settilebg(world, j, height - 1, caveBackgroundType);
	}
	for (int srg = height - 10; srg < height - 6; srg++)
	{
		for (int dhk = 0; dhk < width; dhk++)
		{
			int djkf = rand() % 2;
			if (djkf == 1)
			{
				settile(world, dhk, srg, lavaType);
			}
		}
	}
	if (id & BlastProperties_WaterLevelD2)
	{
		for (int i = 0; i < width; i++)
		{
			for (int j = deco2Id; j < height; j++)
			{
				if (gettile(world, i, j) == 0)
				{
					if (i < world->width && i >= 0 && j < world->height && j >= 0)
						world->items[i + j * world->width].water = 1;
				}
			}
		}
	}
	else if (id & BlastProperties_RandomDeco1)
	{
		int deco1Count = rand() % 25 + 3;
		for (int i = 0; i < deco1Count; i++)
		{
			int a = rand() % width;
			settile(world, a, 25 + offset[a], deco1Id);
		}
	}
	else if (id & BlastProperties_RandomDeco2)
	{
		int deco2Count = rand() % 25 + 3;
		for (int i = 0; i < deco2Count; i++)
		{
			int a = rand() % width;
			settile(world, a, 25 + offset[a], deco2Id);
		}
	}


regenerate:
	int mainDoorX = (rand() % (width - 4)) + 2;
	int f = 25 + offset[mainDoorX];
	while (gettile(world, mainDoorX, f) != 0)
	{
		f--;
		if (f < 0) goto regenerate;
	}
	settile(world, mainDoorX, f, mainDoorType);
	settile(world, mainDoorX, f + 1, bedrockType);

	delete[] offset;
	delete[] offset2;
}

WorldInfo* GenerateWorld(WorldInfo* world, string name, int width, int height)
{
	for (int i = 0; i < world->width * world->height; i++)
	{
		WorldItem tiles{};
		if (i >= 3800 && i < 5400 && !(rand() % 60)) { tiles.foreground = 162; }
		else if (i >= 3700 && i < 5400) {
			if (i > 5000) {
				if (i % 7 == 0) { tiles.foreground = 162; }
				else { tiles.foreground = 2724; }
			}
			else { tiles.foreground = 2724; }
		}
		else if (i >= 5400) { tiles.foreground = 8; }
		if (i >= 3700)
			tiles.background = 14;
		if (i == 3650)
			tiles.foreground = 0;
		else if (i >= 3600 && i < 3700)
			tiles.foreground = 0;
		if (i == 3750)
			tiles.foreground = 8;
		world->items.push_back(tiles);
	}
	return world;
}

WorldInfo generateWorld(string name, int width, int height, bool clear) {
	WorldInfo world;
	world.name = name;
	world.width = width;
	world.height = height;
	if (clear) {
		for (int i = 0; i < world.width * world.height; i++)
		{
			WorldItem tiles{};
			if (i >= 3800 && i < 5400 && !(rand() % 50)) { tiles.foreground = 0; }
			else if (i >= 3700 && i < 5400) {
				if (i > 5000) {
					if (i % 7 == 0) { tiles.foreground = 0; }
					else { tiles.foreground = 0; }
				}
				else { tiles.foreground = 0; }
			}
			else if (i >= 5400) { tiles.foreground = 8; }
			if (i >= 3700)
				tiles.background = 0;
			if (i == 3650)
				tiles.foreground = 6;
			else if (i >= 3600 && i < 3700)
				tiles.foreground = 0; //fixed the grass in the world!
			if (i == 3750)
				tiles.foreground = 8;
			world.items.push_back(tiles);
		}
	}
	else {
		if (name != "DEATHMATCH") {
			for (int i = 0; i < world.width * world.height; i++)
			{
				WorldItem tiles{};
				if (i >= 3800 && i < 5400 && !(rand() % 50)) { tiles.foreground = 10; }
				else if (i >= 3700 && i < 5400) {
					if (i > 5000) {
						if (i % 7 == 0) { tiles.foreground = 4; }
						else { tiles.foreground = 2; }
					}
					else { tiles.foreground = 2; }
				}
				else if (i >= 5400) { tiles.foreground = 8; }
				if (i >= 3700)
					tiles.background = 14;
				if (i == 3650)
					tiles.foreground = 6;
				else if (i >= 3600 && i < 3700)
					tiles.foreground = 0; //fixed the grass in the world!
				if (i == 3750)
					tiles.foreground = 8;
				world.items.push_back(tiles);
			}
		}
	}
	return world;
}
WorldInfo generateWorlds(string name, int width, int height, int dirtType = 2, int lavaType = 4, int mainDoorType = 6, int bedrockType = 8, int rockType = 10, int caveBackgroundType = 14, int wmachineid = 0, int deco1Id = 0, int deco2Id = 0, int id = 0)
{
	WorldInfo world;
	world.name = name;
	world.width = width;
	world.height = height;
	GenerateGrowaloneLikeWorld(&world, width, height, dirtType, lavaType, mainDoorType, bedrockType, rockType, caveBackgroundType, wmachineid, deco1Id, deco2Id, id);
	return world;
}

class PlayerDB {
public:
	static string getProperName(string name);
	static string fixColors(string text);
	static int playerLogin(ENetPeer* peer, string username, string password);
	static int playerRegister(ENetPeer* peer, string username, string password, string passwordverify, string email);
	static int guildRegister(ENetPeer* peer, string guildName, string guildStatement, string guildFlagFg, string guildFlagBg);
	static int checkSubscription(ENetPeer* peer, string name);
};

string PlayerDB::getProperName(string name) {
	string ret = "", ret2 = "", newS = "";
	try {
		for (auto c : name) newS += (c >= 'A' && c <= 'Z') ? c - ('A' - 'a') : c;
		for (auto i = 0; i < newS.length(); i++) {
			if (newS.at(i) == '`') i++;
			else ret += newS.at(i);
		}
		for (auto c : ret) if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) ret2 += c;
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	return ret2;
}
void LoadDialog(ENetPeer* peer) {

	std::ifstream ifff("dialog.json");

	json j;
	ifff >> j;

	string news;
	news = j["dialog"].get<string>();


	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), news));

	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);

	delete p.data;

}

void updateGuild(ENetPeer* peer) {
	string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild);
	if (guildname != "") {
		std::ifstream ifff("guilds/" + guildname + ".json");
		if (ifff.fail()) {
			ifff.close();
			cout << "Failed loading guilds/" + guildname + ".json! From " + ((PlayerInfo*)(peer->data))->displayName + "." << endl;
			((PlayerInfo*)(peer->data))->guild = "";
			updateGuild;
		}
		json j;
		ifff >> j;
		ifff.close();
		int gfbg, gffg;
		string gstatement, gleader;
		vector<string> gmembers;
		vector<string> GE;
		vector<string> GC;
		gfbg = j["backgroundflag"];
		gffg = j["foregroundflag"];
		gstatement = j["GuildStatement"].get<string>();
		gleader = j["Leader"].get<string>();
		for (int i = 0; i < j["Member"].size(); i++) {
			gmembers.push_back(j["Member"].at(i));
		}
		for (int i = 0; i < j["Elder-Leader"].size(); i++) {
			GE.push_back(j["Elder-Leader"].at(i));
		}
		for (int i = 0; i < j["Co-Leader"].size(); i++) {
			GC.push_back(j["Co-Leader"].at(i));
		}
		if (find(gmembers.begin(), gmembers.end(), ((PlayerInfo*)(peer->data))->rawName) == gmembers.end()) {
			((PlayerInfo*)(peer->data))->guild = "";
		}
		if (find(GE.begin(), GE.end(), ((PlayerInfo*)(peer->data))->rawName) == GE.end()) {
			((PlayerInfo*)(peer->data))->guild = "";
		}
		if (find(GC.begin(), GC.end(), ((PlayerInfo*)(peer->data))->rawName) == GC.end()) {
			((PlayerInfo*)(peer->data))->guild = "";
		}
		else {
			((PlayerInfo*)(peer->data))->guildBg = gfbg;
			((PlayerInfo*)(peer->data))->guildFg = gffg;
			((PlayerInfo*)(peer->data))->guildStatement = gstatement;
			((PlayerInfo*)(peer->data))->guildLeader = gleader;
			((PlayerInfo*)(peer->data))->guildMembers = gmembers;
			((PlayerInfo*)(peer->data))->guildGE = GE;
			((PlayerInfo*)(peer->data))->guildGC = GC;
		}
	}
}
bool isHere(ENetPeer* peer, ENetPeer* peer2)
{
	return ((PlayerInfo*)(peer->data))->currentWorld == ((PlayerInfo*)(peer2->data))->currentWorld;
}


void SendBillBoard(ENetPeer* peer) {
	if (((PlayerInfo*)(peer->data))->billboardperwhat == 0) {
		Player::OnDialogRequest(peer, "\nadd_label_with_icon|big|`wTrade Billboard|left|8282|\nadd_spacer|small|\nadd_item_picker|billitem|`wSelect Billboard Item|Choose an item to put on your billboard|\nadd_checkbox|showbill|Show billboard|" + to_string(((PlayerInfo*)(peer->data))->billboardtab) + "|\nadd_text_input|billprice|Price of item:|" + to_string(((PlayerInfo*)(peer->data))->billboardprice) + "|5|\nadd_checkbox|wlperitem|World Lock per item|0|\nadd_checkbox|itemperwl|Item per world lock|1|\nadd_quick_exit|\nend_dialog|updatebillboard|Cancel|Update|");
	}
	else {
		Player::OnDialogRequest(peer, "\nadd_label_with_icon|big|`wTrade Billboard|left|8282|\nadd_spacer|small|\nadd_item_picker|billitem|`wSelect Billboard Item|Choose an item to put on your billboard|\nadd_checkbox|showbill|Show billboard|" + to_string(((PlayerInfo*)(peer->data))->billboardtab) + "|\nadd_text_input|billprice|Price of item:|" + to_string(((PlayerInfo*)(peer->data))->billboardprice) + "|5|\nadd_checkbox|wlperitem|World Lock per item|1|\nadd_checkbox|itemperwl|Item per world lock|0|\nadd_quick_exit|\nend_dialog|updatebillboard|Cancel|Update|");
	}
}
void BillBoard(ENetPeer* peer, int id, int price, int enabled, int perwhat) {
	GamePacket p1 = packetEnd(appendInt(appendInt(appendInt(appendInt(appendIntx(appendString(createPacket(), "OnBillboardChange"), ((PlayerInfo*)(peer->data))->netID), id), enabled), price), perwhat));
	memcpy(p1.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	ENetPacket* packet1 = enet_packet_create(p1.data, p1.len, ENET_PACKET_FLAG_RELIABLE);
	for (ENetPeer* currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, packet1);
		}
	}
	delete p1.data;
}

void updateInvis(ENetPeer* peer) {
	GamePacket pzzz22 = packetEnd(appendInt(appendString(createPacket(), "OnChangePureBeingMode"), ((PlayerInfo*)(peer->data))->pure_state));
	memcpy(pzzz22.data + 8, &((PlayerInfo*)(peer->data))->netID, 4);
	ENetPacket* packet3zzz22 = enet_packet_create(pzzz22.data, pzzz22.len, ENET_PACKET_FLAG_RELIABLE);
	GamePacket pzzz2 = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), ((PlayerInfo*)(peer->data))->transform));
	memcpy(pzzz2.data + 8, &((PlayerInfo*)(peer->data))->netID, 4);
	ENetPacket* packet3zzz2 = enet_packet_create(pzzz2.data, pzzz2.len, ENET_PACKET_FLAG_RELIABLE);
	GamePacket p3 = packetEnd(appendIntx(appendIntx(appendIntx(appendIntx(appendIntx(appendIntx(appendString(createPacket(), "OnDaylightDragon"), 2), 0), 1), 10), 0), 1));
	memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
	GamePacket p132 = packetEnd(appendInt(appendInt(appendInt(appendInt(appendIntx(appendString(createPacket(), "OnBillboardChange"), ((PlayerInfo*)(peer->data))->netID), ((PlayerInfo*)(peer->data))->billboardid), ((PlayerInfo*)(peer->data))->billboardprice), ((PlayerInfo*)(peer->data))->billboardtab), ((PlayerInfo*)(peer->data))->billboardperwhat));
	memcpy(p132.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	ENetPacket* packet132 = enet_packet_create(p132.data, p132.len, ENET_PACKET_FLAG_RELIABLE);
	GamePacket p2ww = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), ((PlayerInfo*)(peer->data))->country + "|showGuild"));
	memcpy(p2ww.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	ENetPacket* packet2ww = enet_packet_create(p2ww.data, p2ww.len, ENET_PACKET_FLAG_RELIABLE);
	int flag1 = (65536 * ((PlayerInfo*)(peer->data))->guildBg) + ((PlayerInfo*)(peer->data))->guildFg;
	GamePacket p2gg = packetEnd(appendIntx(appendIntx(appendIntx(appendIntx(appendString(createPacket(), "OnGuildDataChanged"), 41179607), 41179607), flag1), 0));
	memcpy(p2gg.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	ENetPacket* packet2gg = enet_packet_create(p2gg.data, p2gg.len, ENET_PACKET_FLAG_RELIABLE);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
		if (isHere(peer, currentPeer)) {
			GamePacket pzzz4 = packetEnd(appendInt(appendString(createPacket(), "OnChangePureBeingMode"), ((PlayerInfo*)(currentPeer->data))->pure_state));
			memcpy(pzzz4.data + 8, &((PlayerInfo*)(currentPeer->data))->netID, 4);
			ENetPacket* packet3zzz4 = enet_packet_create(pzzz4.data, pzzz4.len, ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3zzz4);
			GamePacket pzzz = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), ((PlayerInfo*)(currentPeer->data))->transform));
			memcpy(pzzz.data + 8, &((PlayerInfo*)(currentPeer->data))->netID, 4);
			ENetPacket* packet3zzz = enet_packet_create(pzzz.data, pzzz.len, ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3zzz);
			GamePacket p32 = packetEnd(appendIntx(appendIntx(appendIntx(appendIntx(appendIntx(appendIntx(appendString(createPacket(), "OnDaylightDragon"), 2), 0), 1), 10), 0), 1));
			memcpy(p32.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
			ENetPacket* packet32 = enet_packet_create(p32.data, p32.len, ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet32);
			GamePacket p13 = packetEnd(appendInt(appendInt(appendInt(appendInt(appendIntx(appendString(createPacket(), "OnBillboardChange"), ((PlayerInfo*)(currentPeer->data))->netID), ((PlayerInfo*)(currentPeer->data))->billboardid), ((PlayerInfo*)(currentPeer->data))->billboardprice), ((PlayerInfo*)(currentPeer->data))->billboardtab), ((PlayerInfo*)(currentPeer->data))->billboardperwhat));
			memcpy(p13.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
			ENetPacket* packet13 = enet_packet_create(p13.data, p13.len, ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet13);
			GamePacket p2wwee = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), ((PlayerInfo*)(currentPeer->data))->country + "|showGuild"));
			memcpy(p2wwee.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
			ENetPacket* packet2wwee = enet_packet_create(p2wwee.data, p2wwee.len, ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet2wwee);
			GamePacket p2xd = packetEnd(appendIntx(appendIntx(appendIntx(appendIntx(appendString(createPacket(), "OnGuildDataChanged"), 41179607), 41179607), (65536 * ((PlayerInfo*)(currentPeer->data))->guildBg) + ((PlayerInfo*)(currentPeer->data))->guildFg), 0));
			memcpy(p2xd.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
			ENetPacket* packet2xd = enet_packet_create(p2xd.data, p2xd.len, ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet2xd);
			enet_peer_send(currentPeer, 0, packet3zzz22);
			enet_peer_send(currentPeer, 0, packet3zzz2);
			enet_peer_send(currentPeer, 0, packet3);
			enet_peer_send(currentPeer, 0, packet132);
			enet_peer_send(currentPeer, 0, packet2ww);
			enet_peer_send(currentPeer, 0, packet2gg);
			delete p2xd.data;
			delete p2wwee.data;
			delete p13.data;
			delete p32.data;
			delete pzzz4.data;
			delete pzzz.data;
		}
	}
	delete p3.data;
	delete pzzz22.data;
	delete pzzz2.data;
	delete p132.data;
	delete p2ww.data;
	delete p2gg.data;
}

void showWrong(ENetPeer* peer, string listFull, string itemFind) {
	GamePacket fff = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wFind item: " + itemFind + "``|left|206|\nadd_spacer|small|\n" + listFull + "add_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||30|\nend_dialog|findid|Cancel|Find the item!|\n"));
	ENetPacket* packetd = enet_packet_create(fff.data,
		fff.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packetd);

	//enet_host_flush(server);
	delete fff.data;
}

void sendInventory(ENetPeer* peer, PlayerInventory inventory)
{
	try {
		int inventoryLen = inventory.items.size();
		int packetLen = 66 + (inventoryLen * 4) + 4;
		BYTE* data2 = new BYTE[packetLen];
		int MessageType = 0x4;
		int PacketType = 0x9;
		int NetID = -1;
		int CharState = 0x8;
		memset(data2, 0, packetLen);
		memcpy(data2, &MessageType, 4);
		memcpy(data2 + 4, &PacketType, 4);
		memcpy(data2 + 8, &NetID, 4);
		memcpy(data2 + 16, &CharState, 4);
		int endianInvVal = _byteswap_ulong(inventoryLen);
		memcpy(data2 + 66 - 4, &endianInvVal, 4);
		endianInvVal = _byteswap_ulong(inventory.inventorySize);
		memcpy(data2 + 66 - 8, &endianInvVal, 4);
		int val = 0;
		for (int i = 0; i < inventoryLen; i++) {
			val = 0;
			val |= inventory.items.at(i).itemID;
			val |= inventory.items.at(i).itemCount << 16;
			val &= 0x00FFFFFF;
			val |= 0x00 << 24;
			memcpy(data2 + (i * 4) + 66, &val, 4);
		}
		ENetPacket* packet3 = enet_packet_create(data2, packetLen, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet3);
		delete[] data2;
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}

void DoorEffect(ENetPeer* peer, int x, int y)
{
	Player::OnZoomCamera(peer, 10000.000600, 1000);
	GamePacket p2 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
	memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	SendGamePacket(peer, &p2);
	GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnFailedToEnterWorld"), 1));
	SendGamePacket(peer, &p3);
	GamePacket p4 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x * 32, y * 32));
	memcpy(p4.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	SendGamePacket(peer, &p4);
	Player::OnZoomCamera(peer, 10000.000000, 1000);
}


void FlushPlayer(ENetPeer* peer) {
	try {
		if (((PlayerInfo*)(peer->data))->haveGrowId) {
			PlayerInfo* p = ((PlayerInfo*)(peer->data));
			json inv = json::array();
			for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
				json d;
				d["id"] = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID;
				d["count"] = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
				inv.push_back(d);
			}
			ifstream read_player("players/" + p->rawName + ".json");
			if (!read_player.is_open()) {
				return;
			}
			json j;
			read_player >> j;
			read_player.close();
			j["username"] = p->rawName;
			j["password"] = p->tankIDPass;
			j["gems"] = p->gems;
			j["adminLevel"] = p->adminLevel;
			j["userID"] = p->userID;
			j["xp"] = p->xp;
			j["level"] = p->level;
			j["hair"] = p->cloth_hair;
			j["shirt"] = p->cloth_shirt;
			j["skin"] = p->skinColor;
			j["hand"] = p->cloth_hand;
			j["mask"] = p->cloth_mask;
			j["wing"] = p->cloth_back;
			j["neck"] = p->cloth_necklace;
			j["face"] = p->cloth_face;
			j["ances"] = p->cloth_ances;
			j["pants"] = p->cloth_pants;
			j["feet"] = p->cloth_feet;
			j["bannedat"] = p->bandate;
			j["ban"] = p->ban;
			j["bantime"] = p->bantime;
			j["lstep"] = p->lqueststep;
			j["lprogress"] = p->lquestprogress;
			j["ltype"] = p->ltype;
			j["invisize"] = p->inventory.items.size();
			j["size"] = p->inventory.inventorySize;
			j["inventory"] = inv;
			j["xpboost"] = p->xpboost;
			j["xptime"] = p->xptime;
			j["mute"] = p->isDuctaped;
			j["curse"] = p->isCursed;
			j["billboardid"] = p->billboardid;
			j["billboardtab"] = p->billboardtab;
			j["billboardprice"] = p->billboardprice;
			j["billboardperwhat"] = p->billboardperwhat;
			j["cape"] = ((PlayerInfo*)(peer->data))->ItemsOption;
			j["transform"] = p->transform;
			j["friends"] = p->friendinfo;
			j["showloc"] = p->showloc;
			j["enableBName"] = p->blueName;
			j["enableLName"] = p->lName;
			j["pure"] = p->pure_state;
			j["worldsowned"] = p->worldsowned;
			j["pin"] = p->pin;
			ofstream write_player("players/" + p->rawName + ".json");
			write_player << j << std::endl;
			write_player.close();
			ofstream playtime_write("playtime/" + p->rawName + ".txt");
			playtime_write << p->play_time;
			playtime_write.close();
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
void LoadReports(ENetPeer* peer)
{
	PlayerInfo* pinfo = (PlayerInfo*)peer->data;
	try
	{
		std::ifstream ifs("reports/_" + pinfo->rawName + ".json");
		if (!ifs.is_open()) {
			ifs.close();
			return;
		}

		json j;
		ifs >> j;
		ifs.close();

		PlayerNotes note;
		int reportcount = j["count"].get<int>();
		json notes = j["notes"];
		for (int i = 0; i < reportcount; i++)
		{
			Note it;
			it.time = notes.at(i)["time"].get<string>();
			it.who = notes.at(i)["who"].get<string>();
			it.reason = notes.at(i)["text"].get<string>();
			note.notes.push_back(it);
		}
		pinfo->notes = note;
	}
	catch (exception e)
	{

	}
}

string PlayerDB::fixColors(string text) {
	string ret = "";
	try {
		auto colorLevel = 0;
		for (auto i = 0; i < text.length(); i++)
		{
			if (text.at(i) == '`')
			{
				ret += text.at(i);
				if (i + 1 < text.length())
					ret += text[i + 1];
				if (i + 1 < text.length() && text[i + 1] == '`')
				{
					colorLevel--;
				}
				else
				{
					colorLevel++;
				}
				i++;
			}
			else
			{
				ret += text.at(i);
			}
		} for (auto i = 0; i < colorLevel; i++)
		{
			ret += "``";
		} for (auto i = 0; i > colorLevel; i--)
		{
			ret += "`w";
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	return ret;
}
string filterName(string  name) {
	string filteredname = "";
	for (int i = 0; i < name.length(); i++) {
		string ch = name.substr(i, 1); // always take 1 character, and move next. EXAMPLE: we got password 12345, it will take first 1 and check, then 2 and check, and 3 and check, 4 and check, 5 and ccheck. it will scan ALL characters if bad symbols etc. because i is always getting a higher number cuz we said i++
		if (ch != "a" && ch != "A" && ch != "b" && ch != "B" && ch != "c" && ch != "C" && ch != "d" && ch != "D" && ch != "e" && ch != "E"
			&& ch != "f" && ch != "F" && ch != "g" && ch != "G" && ch != "h" && ch != "H" && ch != "i" && ch != "I" && ch != "j" && ch != "J"
			&& ch != "k" && ch != "K" && ch != "l" && ch != "L" && ch != "m" && ch != "M" && ch != "n" && ch != "N" && ch != "o" && ch != "O" &&
			ch != "p" && ch != "P" && ch != "q" && ch != "Q" && ch != "r" && ch != "R" && ch != "s" && ch != "S" && ch != "t" && ch != "T" && ch != "u" && ch != "U"
			&& ch != "v" && ch != "V" && ch != "w" && ch != "W" && ch != "x" && ch != "X" && ch != "y" && ch != "Y" && ch != "z" && ch != "Z" && ch != "0" && ch != "1" && ch != "2"
			&& ch != "3" && ch != "4" && ch != "5" && ch != "6" && ch != "7" && ch != "8" && ch != "9") {
		}
		else
		{
			filteredname = filteredname + ch;
		}
	}
	return filteredname;
}

string filterPass(string password) {

	string filteredpass = "";
	for (int i = 0; i < password.length(); i++) {
		string ch = password.substr(i, 1); // always take 1 character, and move next. EXAMPLE: we got password 12345, it will take first 1 and check, then 2 and check, and 3 and check, 4 and check, 5 and ccheck. it will scan ALL characters if bad symbols etc. because i is always getting a higher number cuz we said i++
		if (ch != "a" && ch != "A" && ch != "b" && ch != "B" && ch != "c" && ch != "C" && ch != "d" && ch != "D" && ch != "e" && ch != "E"
			&& ch != "f" && ch != "F" && ch != "g" && ch != "G" && ch != "h" && ch != "H" && ch != "i" && ch != "I" && ch != "j" && ch != "J"
			&& ch != "k" && ch != "K" && ch != "l" && ch != "L" && ch != "m" && ch != "M" && ch != "n" && ch != "N" && ch != "o" && ch != "O" &&
			ch != "p" && ch != "P" && ch != "q" && ch != "Q" && ch != "r" && ch != "R" && ch != "s" && ch != "S" && ch != "t" && ch != "T" && ch != "u" && ch != "U"
			&& ch != "v" && ch != "V" && ch != "w" && ch != "W" && ch != "x" && ch != "X" && ch != "y" && ch != "Y" && ch != "z" && ch != "Z" && ch != "0" && ch != "1" && ch != "2"
			&& ch != "3" && ch != "4" && ch != "5" && ch != "6" && ch != "7" && ch != "8" && ch != "9" && ch != "!" && ch != ".") {

		}
		else
		{
			filteredpass = filteredpass + ch;
		}
	}
	return filteredpass;
}

struct Admin {
	string username;
	string password;
	int level = 0;
	long long int lastSB = 0;
};


bool isDoubleJumpItem(int id) {

	if (id == 156 || id == 362 || id == 678 || id == 736 || id == 818 || id == 1206 || id == 1460 || id == 1550 || id == 1574 || id == 1672 || id == 1674 || id == 1784 || id == 1824 || id == 1936 || id == 1938 || id == 1970 || id == 2254 || id == 2256 || id == 2258 || id == 2260 || id == 2262 || id == 2264 || id == 2390 || id == 2392 || id == 3120 || id == 3513 || id == 4534 || id == 4986 || id == 5754 || id == 6444 || id == 6334 || id == 6694 || id == 6818 || id == 6842 || id == 7104 || id == 7150 || id == 7196 || id == 7350 || id == 7412 || id == 7502 || id == 7582 || id == 7734 || id == 7834 || id == 7914 || id == 7916 || id == 8286 || id == 8302 || id == 3808 || id == 8552 || id == 8620 || id == 8862 || id == 8914 || id == 9114 || id == 9182 || id == 9352 || id == 9394 || id == 9422 || id == 2722 || id == 3114 || id == 4970 || id == 4972 || id == 5020 || id == 8024 || id == 6284 || id == 8026 || id == 9210 || id == 9408 || id == 9428 || id == 350 || id == 1166 || id == 1738 || id == 2158 || id == 2160 || id == 2162 || id == 2164 || id == 2166 || id == 2168 || id == 2438 || id == 2538 || id == 2642 || id == 2778 || id == 3104 || id == 3112 || id == 3858 || id == 5738 || id == 7084 || id == 7204 || id == 7214 || id == 8194 || id == 8576 || id == 8578 || id == 8580 || id == 8582 || id == 9320 || id == 9322 || id == 9446 || id == 1958) {

		return true;
	}
	else {
		return false;
	}

}

vector<Admin> admins;

void addAdmin(string username, string password, int level)
{
	Admin admin;
	admin.username = username;
	admin.password = password;
	admin.level = level;
	admins.push_back(admin);
}

int getAdminLevel(string username, string password) {
	for (int i = 0; i < admins.size(); i++) {
		Admin admin = admins.at(i);
		if (admin.username == username && admin.password == password) {
			return admin.level;
		}
	}
	return 0;
}

void sendConsoleMsg(ENetPeer* peer, string message) {
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), message));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}
void BlockLoginNoUrl(ENetPeer* peer, string message) {
	string text = "action|log\nmsg|" + message + "\n";
	string text3 = "action|logon_fail\n";

	BYTE* data = new BYTE[5 + text.length()];
	BYTE* data3 = new BYTE[5 + text3.length()];

	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);

	memcpy(data3, &type, 4);
	memcpy(data3 + 4, text3.c_str(), text3.length());
	memcpy(data3 + 4 + text3.length(), &zero, 1);

	ENetPacket* p = enet_packet_create(data,
		5 + text.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p);
	ENetPacket* p2 = enet_packet_create(data3,
		5 + text3.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p2);

	delete[] data;
	delete[] data3;

	enet_peer_disconnect_later(peer, 0);

}

int PlayerDB::guildRegister(ENetPeer* peer, string guildName, string guildStatement, string guildFlagfg, string guildFlagbg) {
	auto uname = guildName;
	if (guildName.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) return -1;
	if (guildName == "prn" || guildName == "con" || guildName == "aux" || guildName == "nul" || guildName == "com1" || guildName == "com2" || guildName == "com3" || guildName == "com4" || guildName == "com5" || guildName == "com6" || guildName == "com7" || guildName == "com8" || guildName == "com9" || guildName == "lpt1" || guildName == "lpt2" || guildName == "lpt3" || guildName == "lpt4" || guildName == "lpt5" || guildName == "lpt6" || guildName == "lpt7" || guildName == "lpt8" || guildName == "lpt9") return -1;
	toUpperCase(uname);
	if (guildName.length() < 3) return -2;
	if (guildName.length() > 15) return -3;
	if (guildFlagfg.size() > 5 || guildFlagfg.size() < 0 || guildFlagbg.size() > 5 || guildFlagbg.size() < 0) return -1;
	int fg; int bg;
	try {
		fg = stoi(guildFlagfg);
	}
	catch (...) {
		return -6;
	}
	try {
		bg = stoi(guildFlagbg);
	}
	catch (...) {
		return -5;
	}
	if (fg > CoreDataItems || bg > CoreDataItems) return -1;
	auto guildNames = PlayerDB::getProperName(guildName);
	std::ifstream ifs("guilds/" + guildNames + ".json");
	if (ifs.is_open()) {
		return -4;
	}
	return 1;
}
int PlayerDB::checkSubscription(ENetPeer* peer, string name) {
	std::ifstream ifs("subscription/" + name + ".txt");
	if (ifs.is_open()) {
		ifstream fd("subscription/" + name + ".txt");
		long long banDuration = 0;
		string bannedBy;
		string bannedReason;
		if (!fd.is_open()) {
			enet_peer_disconnect_later(peer, 0);
			return -1;
		}
		else
		{
			fd >> banDuration;
			fd >> bannedBy;
			fd.ignore();
			getline(fd, bannedReason);
			fd.close();
		}
		int bantimeleft = calcBanDuration(banDuration);
		if (bantimeleft < 1) {
			return -1;
		}
		((PlayerInfo*)(peer->data))->haveSubscription = true;
		Player::OnConsoleMessage(peer, "VIP Subscription is active, " + OutputBanTime(calcBanDuration(banDuration)) + " left.");
	}
}
int PlayerDB::playerRegister(ENetPeer* peer, string username, string password, string passwordverify, string email) {
	if (username.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos || username == "" || username == " " || username == "  " || username == "   " || username == "    ") return -1;
	if (password == "" || password == " " || password == "  " || password == "   " || password == "    ") return -7;
	string displayName666 = username;
	string namex = username;
	string uname = username;
	username = PlayerDB::getProperName(username);
	string displayName = username;

	if (email.find("@") == std::string::npos && email.length() != 0) return -4;
	if (passwordverify != password) return -3;
	if (username.length() < 3 || username.length() > 18) return -2;
	if (password.length() < 8 || password.length() > 18) return -7;
	int registeringIpCount = 1;
	bool existsRegisteringIP = std::experimental::filesystem::exists("registeredIP/" + ((PlayerInfo*)(peer->data))->charIP + ".txt");
	if (existsRegisteringIP) {
		ifstream getIp("registeredIP/" + ((PlayerInfo*)(peer->data))->charIP + ".txt");
		getIp >> registeringIpCount;
		registeringIpCount += 1;
		getIp.close();
		if (registeringIpCount > 3) return -6;
		ofstream writeIp("registeredIP/" + ((PlayerInfo*)(peer->data))->charIP + ".txt");
		writeIp << registeringIpCount;
		writeIp.close();
	}
	else {
		ofstream writeIp("registeredIP/" + ((PlayerInfo*)(peer->data))->charIP + ".txt");
		writeIp << 1;
		writeIp.close();
	}
	std::ifstream check_player("players/" + username + ".json");
	if (check_player.is_open()) {
		check_player.close();
		return -1;
	}
	json inv = json::array();
	json j;
	try {
		userIDcount++;
		if (userIDcount == 1) userIDcount++;
		std::ofstream write_player("players/" + username + ".json");
		if (!write_player.is_open()) {
			return -1;
		} for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
			json d;
			d["id"] = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID;
			d["count"] = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
			inv.push_back(d);
		}
		j["username"] = username;
		j["password"] = filterPass(password);
		j["gems"] = std::to_string(200000);
		j["displayName"] = displayName666;
		j["adminLevel"] = 0;
		j["userID"] = userIDcount;
		j["xp"] = 0;
		j["level"] = 1;
		j["hair"] = 0;
		j["shirt"] = 0;
		j["skin"] = ((PlayerInfo*)(peer->data))->skinColor;
		j["hand"] = 0;
		j["mask"] = 0;
		j["wing"] = 0;
		j["neck"] = 0;
		j["face"] = 0;
		j["ances"] = 0;
		j["pants"] = 0;
		j["feet"] = 0;
		j["bannedat"] = -1;
		j["ban"] = 0;
		j["bantime"] = -1;
		j["lstep"] = 0;
		j["lprogress"] = 0;
		j["ltype"] = 0;
		j["invisize"] = ((PlayerInfo*)(peer->data))->inventory.inventorySize;
		j["size"] = ((PlayerInfo*)(peer->data))->inventory.inventorySize;
		j["inventory"] = inv;
		j["xpboost"] = -1;
		j["xptime"] = 0;
		j["mute"] = ((PlayerInfo*)(peer->data))->isDuctaped;
		j["curse"] = ((PlayerInfo*)(peer->data))->isCursed;
		j["joinguild"] = false;
		j["guild"] = "";
		j["billboardid"] = ((PlayerInfo*)(peer->data))->billboardid;
		j["billboardtab"] = ((PlayerInfo*)(peer->data))->billboardtab;
		j["billboardprice"] = ((PlayerInfo*)(peer->data))->billboardprice;
		j["billboardperwhat"] = ((PlayerInfo*)(peer->data))->billboardperwhat;
		j["cape"] = "cape=147,56,143:collar=147,56,143:cape2=137,30,43:collar2=137,30,43:delay=5";
		j["transform"] = std::to_string(0);
		j["friends"] = ((PlayerInfo*)(peer->data))->friendinfo;
		j["showloc"] = ((PlayerInfo*)(peer->data))->showloc;
		j["enableBName"] = false;
		j["enableLName"] = false;
		j["pure"] = 0;
		j["worldsowned"] = ((PlayerInfo*)(peer->data))->worldsowned;
		j["pin"] = ((PlayerInfo*)(peer->data))->pin;
		write_player << j << std::endl;
		write_player.close();
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	((PlayerInfo*)(peer->data))->userID = userIDcount;
	ofstream myfile;
	myfile.open("uids.txt");
	myfile << to_string(userIDcount);
	myfile.close();
	((PlayerInfo*)(peer->data))->userID = userIDcount;
	return 1;
}

struct AWorld {
	WorldInfo* ptr;
	WorldInfo info;
	int id;
};
string getStrLower(string txt)
{
	string ret;
	for (char c : txt) ret += tolower(c);
	return ret;
}
string getStrUpper(string txt)
{
	string ret;
	for (char c : txt) ret += toupper(c);
	return ret;
}
vector<WorldInfo> worlds;

class WorldDB
{
public:
	WorldInfo get(string name) const;
	void remove(string name);
	WorldInfo* get_pointer(string name) const;
	static AWorld get2(string name);
	vector<WorldInfo> getRandomWorlds();
	WorldDB();
};
WorldDB::WorldDB() {
	// Constructor
}
void WorldDB::remove(string name) {
	vector<WorldInfo>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const WorldInfo& a) { return a.name == name; });
	if (p != worlds.end()) {
		auto id_ = p - worlds.begin();
		WorldInfo* info = &worlds.at(id_);
		worlds.erase(worlds.begin() + id_);
		info = NULL;
	}
	std::remove(("worlds/" + name + ".json").c_str());
}

void ToUpperStr(string str)
{
	//auto toupp = [](unsigned char c) { return std::toupper(c); };
	//std::transform(str.begin(), str.end(), str.begin(),
	//	toupp);
	try {
		for (auto& c : str) c = toupper(c);
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
AWorld WorldDB::get2(string name) {
	AWorld ret;
	name = getStrUpper(name);
	vector<WorldInfo>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const WorldInfo& a) { return a.name == name; });
	if (p != worlds.end()) {
		ret.id = p - worlds.begin();
		ret.info = worlds.at(p - worlds.begin());
		ret.ptr = &worlds.at(p - worlds.begin());
		return ret;
	}
	try {
		WorldInfo info;
		ifstream read_world("worlds/" + name + ".json");
		if (read_world.is_open()) {
			json j;
			read_world >> j;
			read_world.close();
			info.name = j["name"].get<string>();
			for (int i = 0; i < j["list"].size(); i++) {
				info.viplist.push_back(j["list"].at(i));
			}
			for (int i = 0; i < j["acc"].size(); i++) {
				info.accessworld.push_back(j["acc"].at(i));
			}
			try { info.last_SAVE = j["lastSave"].get<long long>(); }
			catch (nlohmann::json::exception ex) {}
			info.ownerID = j["ownid"].get<int>();
			info.width = j["width"].get<int>();
			info.height = j["height"].get<int>();
			info.owner = j["owner"].get<string>();
			info.ownerDisplayName = j["dname"].get<string>();
			info.isPublic = j["isPublic"].get<bool>();
			info.weather = j["weather"].get<int>();
			info.stuffID = j["sid"].get<int>();
			info.stuff_invert = j["si"].get<bool>();
			info.stuff_gravity = j["sg"].get<int>();
			info.stuff_spin = j["ss"].get<bool>();
			info.bgID = j["bid"].get<int>();
			info.hw_red = j["hwr"].get<int>();
			info.hw_green = j["hwg"].get<int>();
			info.hw_blue = j["hwb"].get<int>();
			info.droppedCount = j["dc"].get<int>();
			info.isNuked = j["nuked"].get<bool>();
			info.magplantGems = j["maggem"].get<int>();
			info.enablecolleciton = j["magena"].get<bool>();
			info.magX = j["magx"].get<int>();
			info.magY = j["magy"].get<int>();
			info.bpm = j["bpm"].get<int>();
			info.invisible_music = j["invis"].get<int>();

			json droppedobjects = j["dropped"];
			for (int i = 0; i < droppedobjects.size(); i++) {
				DroppedItem di;
				di.count = droppedobjects.at(i)["c"].get<BYTE>();
				di.id = droppedobjects.at(i)["id"].get<short>();
				di.x = droppedobjects.at(i)["x"].get<int>();
				di.y = droppedobjects.at(i)["y"].get<int>();
				di.uid = droppedobjects.at(i)["uid"].get<int>();
				info.droppedItems.push_back(di);
			}
			json tiles = j["tiles"];
			int square = info.width * info.height;
			for (int i = 0; i < tiles.size(); i++) {
				WorldItem w_tiles{};
				w_tiles.foreground = tiles.at(i)["fg"].get<int>();
				w_tiles.background = tiles.at(i)["bg"].get<int>();
				w_tiles.sign = tiles.at(i)["s"].get<string>();
				w_tiles.intdata = tiles.at(i)["int"].get<int>();
				w_tiles.destWorld = tiles.at(i)["destw"].get<string>();
				w_tiles.destId = tiles.at(i)["destid"].get<string>();
				w_tiles.currId = tiles.at(i)["currid"].get<string>();
				w_tiles.growtime = tiles.at(i)["time"].get<int>();
				w_tiles.fruitcount = tiles.at(i)["fruit"].get<int>();

				w_tiles.vdraw = tiles.at(i)["vd"].get<int>();
				w_tiles.blockstate = tiles.at(i)["state"].get<string>();
				if (w_tiles.blockstate != "") {
					if (w_tiles.blockstate.find(",")) {
						vector<string> lol = explode(",", w_tiles.blockstate);
						if (lol.at(0) == "1") w_tiles.water = true;
						if (lol.at(1) == "1") w_tiles.glue = true;
						if (lol.at(2) == "1") w_tiles.fire = true;
						if (lol.at(3) == "1") w_tiles.red = true;
						if (lol.at(4) == "1") w_tiles.green = true;
						if (lol.at(5) == "1") w_tiles.blue = true;
						if (lol.at(6) == "1") w_tiles.entrance_open = true;
						if (lol.at(7) == "1") w_tiles.flipped = true;
						if (lol.at(8) == "1") w_tiles.activated = true;
						if (lol.at(9) == "1") w_tiles.opened = true;
						if (lol.at(10) == "1") 
						if (lol.at(11) == "1") w_tiles.rm = true;
						if (lol.at(12) == "1") w_tiles.silenced = true;
						lol.clear();
					}
				}
				info.items.push_back(w_tiles);
			}
			j.clear(), tiles.clear(), droppedobjects.clear();
		}
		else {
			if (usedthermoblast == true) {
				usedthermoblast = false;
				info = generateWorld(name, 100, 60, true);
			}
			else if (usemars == true) {
				usemars = false;
				info = generateWorlds(name, 100, 60, 1132, 440, 6, 8, 1134, 14, 7, 1138, 0, BlastProperties_RandomDeco1);
			}
			else {
				info = generateWorld(name, 100, 60, false);
			}
		}
		worlds.push_back(info);
		ret.id = worlds.size() - 1;
		ret.info = info;
		ret.ptr = &worlds.at(worlds.size() - 1);
		return ret;
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
		AWorld ret;
		ret.id = -1;
		return ret;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
		AWorld ret;
		ret.id = -1;
		return ret;
	}
	throw 1;
}

WorldInfo WorldDB::get(const string name) const
{
	AWorld worldas = this->get2(name);
	if (worldas.id == -1) {
		worldas.info.name = "error";
	}
	return worldas.info;
}

WorldInfo* WorldDB::get_pointer(const string name) const
{
	AWorld worldas = this->get2(name);
	if (worldas.id == -1) {
		return NULL;
	}
	return worldas.ptr;
}
void save_world(const string& name_, bool erase, bool triger_cooldown) {
	try {
		if (triger_cooldown) {
			vector<WorldInfo>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const WorldInfo& a) { return a.name == name_; });
			if (p != worlds.end()) {
				auto id_ = p - worlds.begin();
				WorldInfo* info = &worlds.at(id_);
				if (info->last_SAVE + 120000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
				{
					info->last_SAVE = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					json j;
					json tiles = json::array();
					json droppedarr = json::array();
					int square = info->width * info->height;

					for (int i = 0; i < info->droppedItems.size(); i++) {
						if (info->droppedItems.at(i).id == 0) {
							info->droppedItems.erase(info->droppedItems.begin() + i);
							i--;
							for (int a_ = 0; a_ < info->droppedItems.size(); a_++)
								if (a_ > i) info->droppedItems[a_].uid--;
							continue;
						}
						json droppedJ;
						droppedJ["c"] = (BYTE)info->droppedItems.at(i).count;
						droppedJ["id"] = (short)info->droppedItems.at(i).id;
						droppedJ["x"] = info->droppedItems.at(i).x;
						droppedJ["y"] = info->droppedItems.at(i).y;
						droppedJ["uid"] = info->droppedItems.at(i).uid;
						droppedarr.push_back(droppedJ);
						droppedJ.clear();
					}
					for (int i = 0; i < square; i++) {
						json tile;
						tile["fg"] = info->items.at(i).foreground;
						tile["bg"] = info->items.at(i).background;
						tile["s"] = info->items.at(i).sign;

						tile["int"] = info->items.at(i).intdata;

						tile["destw"] = info->items.at(i).destWorld;
						tile["destid"] = info->items.at(i).destId;
						tile["currid"] = info->items.at(i).currId;
						tile["time"] = info->items.at(i).growtime;
						tile["fruit"] = info->items.at(i).fruitcount;

						tile["vd"] = info->items.at(i).vdraw;
						tile["state"] = info->items.at(i).blockstate;

						tiles.push_back(tile);
						tile.clear();
					}
					j["name"] = info->name;
					j["lastSave"] = info->last_SAVE;
					j["list"] = info->viplist;
					j["acc"] = info->accessworld;
					j["ownid"] = info->ownerID;
					j["width"] = info->width;
					j["height"] = info->height;
					j["owner"] = info->owner;
					j["dname"] = info->ownerDisplayName;
					j["isPublic"] = info->isPublic;
					j["weather"] = info->weather;
					j["sid"] = info->stuffID;
					j["sil"] = info->silence;
					j["rbg"] = info->rainbows;
					j["sg"] = info->stuff_gravity;
					j["si"] = info->stuff_invert;
					j["ss"] = info->stuff_spin;
					j["bid"] = info->bgID;

					j["hwr"] = info->hw_red;
					j["hwg"] = info->hw_green;
					j["hwb"] = info->hw_blue;
					j["dc"] = info->droppedCount;
					j["nuked"] = info->isNuked;
					j["dropped"] = droppedarr;
					j["tiles"] = tiles;
					j["maggem"] = info->magplantGems;
					j["magena"] = info->enablecolleciton;
					j["magx"] = info->magX;
					j["magy"] = info->magY;
					j["bpm"] = info->bpm;
					j["invis"] = info->invisible_music;
					ofstream write_player("worlds/" + info->name + ".json");
					write_player << j << std::endl;
					write_player.close(), j.clear(), droppedarr.clear(), tiles.clear();
					if (erase) {
						worlds.erase(worlds.begin() + id_);
						info = NULL;
					}
				}
			}
		}
		else {
			vector<WorldInfo>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const WorldInfo& a) { return a.name == name_; });
			if (p != worlds.end()) {
				auto id_ = p - worlds.begin();
				WorldInfo* info = &worlds.at(id_);
				json j;
				json tiles = json::array();
				json droppedarr = json::array();
				int square = info->width * info->height;

				for (int i = 0; i < info->droppedItems.size(); i++) {
					if (info->droppedItems.at(i).id == 0) {
						info->droppedItems.erase(info->droppedItems.begin() + i);
						i--;
						for (int a_ = 0; a_ < info->droppedItems.size(); a_++)
							if (a_ > i) info->droppedItems[a_].uid--;
						continue;
					}
					json droppedJ;
					droppedJ["c"] = (BYTE)info->droppedItems.at(i).count;
					droppedJ["id"] = (short)info->droppedItems.at(i).id;
					droppedJ["x"] = info->droppedItems.at(i).x;
					droppedJ["y"] = info->droppedItems.at(i).y;
					droppedJ["uid"] = info->droppedItems.at(i).uid;
					droppedarr.push_back(droppedJ);
				}
				for (int i = 0; i < square; i++) {
					json tile;
					tile["fg"] = info->items.at(i).foreground;
					tile["bg"] = info->items.at(i).background;
					tile["s"] = info->items.at(i).sign;

					tile["int"] = info->items.at(i).intdata;

					tile["destw"] = info->items.at(i).destWorld;
					tile["destid"] = info->items.at(i).destId;
					tile["currid"] = info->items.at(i).currId;
					tile["time"] = info->items.at(i).growtime;
					tile["fruit"] = info->items.at(i).fruitcount;

					tile["vd"] = info->items.at(i).vdraw;
					tile["state"] = info->items.at(i).blockstate;

					tiles.push_back(tile);
				}
				j["name"] = info->name;
				j["lastSave"] = info->last_SAVE;
				j["list"] = info->viplist;
				j["acc"] = info->accessworld;
				j["ownid"] = info->ownerID;
				j["width"] = info->width;
				j["height"] = info->height;
				j["owner"] = info->owner;
				j["dname"] = info->ownerDisplayName;
				j["isPublic"] = info->isPublic;
				j["weather"] = info->weather;
				j["sid"] = info->stuffID;
				j["sil"] = info->silence;
				j["rbg"] = info->rainbows;
				j["sg"] = info->stuff_gravity;
				j["si"] = info->stuff_invert;
				j["ss"] = info->stuff_spin;
				j["bid"] = info->bgID;

				j["hwr"] = info->hw_red;
				j["hwg"] = info->hw_green;
				j["hwb"] = info->hw_blue;
				j["dc"] = info->droppedCount;
				j["nuked"] = info->isNuked;
				j["dropped"] = droppedarr;
				j["tiles"] = tiles;
				j["maggem"] = info->magplantGems;
				j["magena"] = info->enablecolleciton;
				j["magx"] = info->magX;
				j["magy"] = info->magY;
				j["bpm"] = info->bpm;
				j["invis"] = info->invisible_music;
				ofstream write_player("worlds/" + info->name + ".json");
				write_player << j << std::endl;
				write_player.close();
				if (erase) {
					worlds.erase(worlds.begin() + id_);
					info = NULL;
				}
			}
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
unsigned long RGBA2DWORD(int iR, int iG, int iB, int iA) { return (((((iA << 8) + iR) << 8) + iG) << 8) + iB; }
int getPlayersCountInWorld(string name)
{
	int count = 0;
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (((PlayerInfo*)(currentPeer->data))->currentWorld == name)
			count++;
	}
	return count;
}

int getPlayersCountInWorldVSave(WorldInfo world, const string name) {
	auto count = 0;
	for (auto currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
		if (((PlayerInfo*)(currentPeer->data))->currentWorld == name) {
			count++;
		}
	}
	return count;
}


WorldDB worldDB;

void remove(string name) {
	try {
		for (int i = 0; i < worlds.size(); i++)
		{
			WorldInfo w = worlds.at(i);
			if (getStrLower(name) == getStrLower(w.name))
			{
				worlds.erase(worlds.begin() + i);
			}
		}
		std::remove(("worlds/" + name + ".json").c_str());
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}

vector<WorldInfo> WorldDB::getRandomWorlds()
{
	vector<WorldInfo> ret;
	for (auto i = 0; i < ((worlds.size() < 10) ? worlds.size() : 10); i++)
	{
		ret.push_back(worlds.at(i));
	}
	if (worlds.size() > 4)
	{
		for (auto j = 0; j < 6; j++)
		{
			auto isPossible = true;
			auto world = worlds.at(rand() % (worlds.size() - 4));
			for (auto i = 0; i < ret.size(); i++)
			{
				if (world.name == ret.at(i).name || world.name == "EXIT")
				{
					isPossible = false;
				}
			}
			if (isPossible)
			{
				ret.push_back(world);
			}
		}
	}
	return ret;
}

//WorldInfo world;
//vector<WorldInfo> worlds;
struct PlayerMoving {
	int packetType;
	int netID;
	int secondNetId;
	float x;
	float y;
	int characterState;
	int plantingTree;
	int punchX;
	int punchY;

};
ItemDefinition getItemDef(int id)
{
	if (id < itemDefs.size() && id > -1)
		return itemDefs.at(id);
	/*for (int i = 0; i < itemDefs.size(); i++)
	{
		if (id == itemDefs.at(i).id)
		{
			return itemDefs.at(i);
		}
	}*/
	throw 0;
	return itemDefs.at(0);
}

bool isGoodForeground(int tile) {
	///if (tile != 0 && getItemDef(tile).blockType != BlockTypes::DISPLAY_SHELF && getItemDef(tile).blockType != BlockTypes::WEATHER2 && getItemDef(tile).blockType != BlockTypes::Mannequin && tile != 2398 && getItemDef(tile).blockType != BlockTypes::Heart_Monitor && getItemDef(tile).blockType != BlockTypes::Toggleable_Deadly_Block && getItemDef(tile).blockType != BlockTypes::Sungate && getItemDef(tile).blockType != BlockTypes::Scoreboard && getItemDef(tile).blockType != BlockTypes::WEATHER && getItemDef(tile).blockType != BlockTypes::Provider && getItemDef(tile).blockType != BlockTypes::BULLETIN_BOARD && getItemDef(tile).blockType != BlockTypes::MAILBOX && getItemDef(tile).blockType != BlockTypes::PORTAL && getItemDef(tile).blockType != BlockTypes::Painting_Easel && getItemDef(tile).blockType != BlockTypes::SFX_FOREGROUND && getItemDef(tile).blockType != BlockTypes::Heart_Monitor && getItemDef(tile).blockType != BlockTypes::GATEWAY && getItemDef(tile).blockType != BlockTypes::VIP && getItemDef(tile).blockType != BlockTypes::CHEST && getItemDef(tile).blockType != BlockTypes::TOGGLE_FOREGROUND && getItemDef(tile).blockType != BlockTypes::SWITCH_BLOCK && getItemDef(tile).blockType != BlockTypes::PORTRAIT && getItemDef(tile).blockType != BlockTypes::Country_Flag && getItemDef(tile).blockType != BlockTypes::BACKGROUND && getItemDef(tile).blockType != BlockTypes::ANIM_FOREGROUND && getItemDef(tile).blockType != BlockTypes::SEED && getItemDef(tile).blockType != BlockTypes::CHECKPOINT && getItemDef(tile).blockType != BlockTypes::DOOR && getItemDef(tile).blockType != BlockTypes::MAIN_DOOR && getItemDef(tile).blockType != BlockTypes::SIGN && getItemDef(tile).blockType != BlockTypes::PLATFORM && tile != 6296 && tile != 7444 && tile != 4546 && tile != 1616 && tile != 1224 && tile != 7182 && tile != 1104 && tile != 4546 && tile != 7226 && tile != 7448 && tile != 192 && tile != 3002 && tile != 3004) {
	if (getItemDef(tile).collisionType == 1) {
		return true;
	}
	return false;
}

void craftItemDescriptions() {
	int current = -1;
	std::ifstream infile("Descriptions.txt");
	for (std::string line; getline(infile, line);)
	{
		if (line.length() > 3 && line[0] != '/' && line.at(1) != '/')
		{
			vector<string> ex = explode("|", line);
			ItemDefinition def;
			if (atoi(ex.at(0).c_str()) + 1 < itemDefs.size())
			{
				itemDefs.at(atoi(ex[0].c_str())).description = ex.at(1);
				if (!(atoi(ex.at(0).c_str()) % 2))
					itemDefs.at(atoi(ex.at(0).c_str()) + 1).description = "This is a tree.";
			}
		}
	}
}
void sendHelp(ENetPeer* peer)
{
	if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 2)
	{
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "This command is disabled due not done!"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
		//enet_host_flush(server);
	}
	else if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1)
	{
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "This command is disabled due not done!"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
		//enet_host_flush(server);
	}
	else {
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "This command is disabled due not done!"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
		//enet_host_flush(server);
	}
}

void loadnews() {
	std::ifstream ifs("dialogs/gazette.txt");
	std::string content((std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));

	string target = "\r";
	string news = "";
	int found = -1;
	do {
		found = content.find(target, found + 1);
		if (found != -1) {
			news = content.substr(0, found) + content.substr(found + target.length());
		}
		else {
			news = content;
		}
	} while (found != -1);
	if (news != "") {
		newslist = news;
	}
}
void sendGazette(ENetPeer* peer) {

	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), newslist));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;

}

string FormatTradeItems(vector<TradeItem> tradeItems)
{
	string fmt;
	for (auto& t : tradeItems)
	{
		fmt += "add_slot|" + to_string(t.id) + "|" + to_string(t.count) + "\n";
	}
	return fmt;
}

string FormatTradeItemsForDialog(vector<TradeItem> tradeItems, bool getting)
{
	if (tradeItems.size() < 1)
	{
		string a = "add_textbox|";
		a += (getting ? "`2" : "`4");
		a += "Nothing!";
		return a;
	}
	string fmt;
	for (auto& t : tradeItems)
	{
		fmt += "add_label_with_icon|small|`o(`w" + to_string(t.count) + "`o) `w" + getItemDef(t.id).name + "``|left|" + to_string(t.id) + "|\n";
	}
	return fmt;
}
string FormatTradeItemsForMessage(vector<TradeItem> tradeItems)
{
	if (tradeItems.size() < 1) return "nothing";
	string fmt;
	for (auto& t : tradeItems)
	{
		if (fmt.size() > 0)
			fmt += ", " + to_string(t.count) + " " + getItemDef(t.id).name + "";
		else
			fmt += to_string(t.count) + " " + getItemDef(t.id).name + "";
		//fmt += "add_label_with_icon|big|`o(`w" + to_string(t.count) + "`o) `w" + getItemDef(t.id).name + "``|left|" + to_string(t.id) + "|\n";
	}
	return fmt;
}

bool DetectTradeConnection(ENetPeer* peer1, ENetPeer* peer2)
{
	PlayerInfo* pinfo = (PlayerInfo*)peer1->data;
	PlayerInfo* pinfo2 = (PlayerInfo*)peer2->data;

	if (pinfo->isWaitingForTrade)
	{
		if (pinfo->isWaitingForTradeWithUserID == pinfo2->userID)
		{
			if (pinfo2->isWaitingForTrade)
			{
				if (pinfo2->isWaitingForTradeWithUserID == pinfo->userID)
				{
					// set both peer's flags
					pinfo->isTrading = true;
					pinfo->isTradingWithUserID = pinfo->isWaitingForTradeWithUserID;
					pinfo->isWaitingForTradeWithUserID = 0;
					pinfo->isTradingWithUserID = pinfo2->userID;
					pinfo->isWaitingForTrade = false;

					pinfo2->isTradingWithUserID = pinfo->userID;
					pinfo2->isTrading = true;
					pinfo2->isTradingWithUserID = pinfo2->isWaitingForTradeWithUserID;
					pinfo2->isWaitingForTradeWithUserID = false;
					pinfo2->isWaitingForTrade = false;

					pinfo->tradeItems.clear();
					pinfo2->tradeItems.clear();

					Player::OnTradeStatus(peer1, pinfo->netID, "`oSelect an item from the inventory.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|0\nreset_locks|1\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
					Player::OnTradeStatus(peer1, pinfo2->netID, "`w" + pinfo2->displayName + "`o's offer.``", "", FormatTradeItems(pinfo2->tradeItems) + "\nlocked|0\naccepted|" + to_string(pinfo2->isAcceptingTrade) + "\n");

					Player::OnTradeStatus(peer2, pinfo2->netID, "`oSelect an item from the inventory.``", "", FormatTradeItems(pinfo2->tradeItems) + "\nlocked|0\naccepted|" + to_string(pinfo2->isAcceptingTrade) + "\n");
					Player::OnTradeStatus(peer2, pinfo->netID, "`w" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|0\nreset_locks|1\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
					return true;
				}
			}
		}
	}
	return false;
}



void UpdateTradeAcceptedStatus(ENetPeer* peer1, int showOverlay = 0)
{
	PlayerInfo* pinfo = (PlayerInfo*)peer1->data;
	ENetPeer* currentPeer;

	bool found = false;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		PlayerInfo* pinfo2 = (PlayerInfo*)currentPeer->data;
		if (pinfo->isTradingWithUserID == pinfo2->userID) {

			Player::OnTradeStatus(currentPeer, pinfo->netID, "`o" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|1\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
			Player::OnTradeStatus(currentPeer, pinfo2->netID, "`o" + pinfo2->displayName + "`o's offer.``", "", FormatTradeItems(pinfo2->tradeItems) + "\nlocked|1\naccepted|" + to_string(pinfo2->isAcceptingTrade) + "\n");
			break;
		}
	}
	//Player::OnTradeStatus(peer1, pinfo->netID, "`o" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|1\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
}
int WaitForTradeWithThisPlayer(ENetPeer* peer1, ENetPeer* peer2)
{
	if (peer1 == peer2) return -2;
	PlayerInfo* pinfo = (PlayerInfo*)peer1->data;
	PlayerInfo* pinfo2 = (PlayerInfo*)peer2->data;
	if (pinfo->currentWorld != pinfo2->currentWorld) return -3;
	if (pinfo2->isTrading) return -1;
	pinfo->isTrading = false;
	pinfo->isWaitingForTrade = true;
	pinfo->isWaitingForTradeWithUserID = pinfo2->userID;
	Player::OnStartTrade(peer1, pinfo2->displayName, pinfo2->netID);
	if (!DetectTradeConnection(peer1, peer2))
	{
		Player::OnConsoleMessage(peer2, "`#TRADE ALERT`o: " + pinfo->displayName + " `owants to trade with you! To accept, type `w/trade " + pinfo->rawName + "`o.");
	}
	return 0;
}




void SendCancelTrade(ENetPeer* peer, string overlay = "That player is busy.")
{
	PlayerInfo* pinfo = (PlayerInfo*)peer->data;
	Player::OnForceTradeEnd(peer); // just in case
	if (overlay != "") {
		Player::OnTextOverlay(peer, overlay);
	}
	pinfo->isTrading = false;
	pinfo->isAcceptingTrade = false;
	pinfo->isTradingWithUserID = 0;
	pinfo->isWaitingForTradeWithUserID = 0;
	pinfo->isWaitingForTrade = false;
}


std::ifstream::pos_type filesize(const char* filename)
{
	std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);
	return in.tellg();
}

uint32_t HashString(unsigned char* str, int len)
{
	if (!str) return 0;

	unsigned char* n = (unsigned char*)str;
	uint32_t acc = 0x55555555;

	if (len == 0)
	{
		while (*n)
			acc = (acc >> 27) + (acc << 5) + *n++;
	}
	else
	{
		for (int i = 0; i < len; i++)
		{
			acc = (acc >> 27) + (acc << 5) + *n++;
		}
	}
	return acc;

}

unsigned char* getA(string fileName, int* pSizeOut, bool bAddBasePath, bool bAutoDecompress)
{
	unsigned char* pData = NULL;
	FILE* fp = fopen(fileName.c_str(), "rb");
	if (!fp)
	{
		cout << "File not found" << endl;
		if (!fp) return NULL;
	}

	fseek(fp, 0, SEEK_END);
	*pSizeOut = ftell(fp);
	fseek(fp, 0, SEEK_SET);

	pData = (unsigned char*)new unsigned char[((*pSizeOut) + 1)];
	if (!pData)
	{
		printf("Out of memory opening %s?", fileName.c_str());
		return 0;
	}
	pData[*pSizeOut] = 0;
	fread(pData, *pSizeOut, 1, fp);
	fclose(fp);

	return pData;
}
int itemsdathash;
void buildItemsDatabase()
{
	std::string secret = "PBG892FXX982ABC*";
	std::ifstream file("items.dat", std::ios::binary | std::ios::ate);
	int size = file.tellg();
	itemsDatSize = size;
	char* data = new char[size];
	file.seekg(0, std::ios::beg);

	if (file.read((char*)(data), size))
	{
		itemsDat = new BYTE[60 + size];
		int MessageType = 0x4;
		int PacketType = 0x10;
		int NetID = -1;
		int CharState = 0x8;

		memset(itemsDat, 0, 60);
		memcpy(itemsDat, &MessageType, 4);
		memcpy(itemsDat + 4, &PacketType, 4);
		memcpy(itemsDat + 8, &NetID, 4);
		memcpy(itemsDat + 16, &CharState, 4);
		memcpy(itemsDat + 56, &size, 4);
		file.seekg(0, std::ios::beg);
		if (file.read((char*)(itemsDat + 60), size))
		{
			uint8_t* pData;
			int size = 0;
			const char filename[] = "items.dat";
			size = filesize(filename);
			pData = getA((std::string)filename, &size, false, false);
			std::cout << "Updating items data success! Hash: " << HashString((unsigned char*)pData, size) << std::endl;
			itemdathash = HashString((unsigned char*)pData, size);
			file.close();
		}
	}
	else {
		std::cout << "Updating items data failed!" << std::endl;
		exit(0);
	}
	int itemCount;
	int memPos = 0;
	int16_t itemsdatVersion = 0;
	memcpy(&itemsdatVersion, data + memPos, 2);
	memPos += 2;
	memcpy(&itemCount, data + memPos, 4);
	memPos += 4;
	for (int i = 0; i < itemCount; i++) {
		ItemDefinition tile;
		memcpy(&tile.id, data + memPos, 4);
		memPos += 4;
		tile.editableType = data[memPos];
		memPos += 1;
		tile.itemCategory = data[memPos];
		memPos += 1;
		tile.actionType = data[memPos];
		memPos += 1;
		tile.hitSoundType = data[memPos];
		memPos += 1;
		int16_t strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.name += data[memPos] ^ (secret[(j + tile.id) % secret.length()]);
			memPos++;
		}
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.texture += data[memPos];
			memPos++;
		}
		memcpy(&tile.textureHash, data + memPos, 4);
		memPos += 4;
		tile.itemKind = memPos[data];
		memPos += 1;
		memcpy(&tile.val1, data + memPos, 4);
		memPos += 4;
		tile.textureX = data[memPos];
		memPos += 1;
		tile.textureY = data[memPos];
		memPos += 1;
		tile.spreadType = data[memPos];
		memPos += 1;
		tile.isStripeyWallpaper = data[memPos];
		memPos += 1;
		tile.collisionType = data[memPos];
		memPos += 1;
		tile.breakHits = *(uint8_t*)(data + memPos) / 6;
		memPos += 1;
		memcpy(&tile.dropChance, data + memPos, 4);
		memPos += 4;
		tile.clothingType = data[memPos];
		memPos += 1;
		memcpy(&tile.rarity, data + memPos, 2);
		memPos += 2;
		tile.maxAmount = data[memPos];
		memPos += 1;
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.extraFile += data[memPos];
			memPos++;
		}
		memcpy(&tile.extraFileHash, data + memPos, 4);
		memPos += 4;
		memcpy(&tile.audioVolume, data + memPos, 4);
		memPos += 4;
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.petName += data[memPos];
			memPos++;
		}
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.petPrefix += data[memPos];
			memPos++;
		}
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.petSuffix += data[memPos];
			memPos++;
		}
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.petAbility += data[memPos];
			memPos++;
		}
		tile.seedBase = data[memPos];
		memPos += 1;
		tile.seedOverlay = data[memPos];
		memPos += 1;
		tile.treeBase = data[memPos];
		memPos += 1;
		tile.treeLeaves = data[memPos];
		memPos += 1;
		memcpy(&tile.seedColor, data + memPos, 4);
		memPos += 4;
		memcpy(&tile.seedOverlayColor, data + memPos, 4);
		memPos += 4;
		memPos += 4;
		memcpy(&tile.growTime, data + memPos, 4);
		memPos += 4;
		memcpy(&tile.val2, data + memPos, 2);
		memPos += 2;
		memcpy(&tile.isRayman, data + memPos, 2);
		memPos += 2;
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.extraOptions += data[memPos];
			memPos++;
		}
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.texture2 += data[memPos];
			memPos++;
		}
		strLen = *(int16_t*)&data[memPos];
		memPos += 2;
		for (int j = 0; j < strLen; j++) {
			tile.extraOptions2 += data[memPos];
			memPos++;
		}
		memPos += 80;
		if (itemsdatVersion >= 11) {
			strLen = *(int16_t*)&data[memPos];
			memPos += 2;
			for (int j = 0; j < strLen; j++) {
				tile.punchOptions += data[memPos];
				memPos++;
			}
		}
		if (itemsdatVersion >= 12) memPos += 13;
		if (itemsdatVersion >= 13) memPos += 4;
		if (itemsdatVersion >= 14) memPos += 4;
		if (i != tile.id) cout << "Critical error! Unordered database at item " << std::to_string(i) << "/" << std::to_string(tile.id) << "!" << endl;

		vector<string> properties = explode(",", (ItemCategoryToProperties(tile.itemCategory, tile.editableType).empty() ? "0" : join(ItemCategoryToProperties(tile.itemCategory, tile.editableType), ',')));
		tile.properties = Property_Zero;
		for (auto& prop : properties)
		{
			if (prop == "NoSeed")
				tile.properties += Property_NoSeed;
			if (prop == "Dropless")
				tile.properties += Property_Dropless;
			if (prop == "Beta")
				tile.properties += Property_Beta;
			if (prop == "Mod")
				tile.properties += Property_Mod;
			if (prop == "Untradable")
				tile.properties += Property_Untradable;
			if (prop == "Wrenchable")
				tile.properties += Property_Wrenchable;
			if (prop == "MultiFacing")
				tile.properties += Property_MultiFacing;
			if (prop == "Permanent")
				tile.properties += Property_Permanent;
			if (prop == "AutoPickup")
				tile.properties += Property_AutoPickup;
			if (prop == "WorldLock")
				tile.properties += Property_WorldLock;
			if (prop == "NoSelf")
				tile.properties += Property_NoSelf;
			if (prop == "RandomGrow")
				tile.properties += Property_RandomGrow;
			if (prop == "Public")
				tile.properties += Property_Public;
		}
		switch (tile.actionType) {
		case 0:
			tile.blockType = BlockTypes::FIST;
			break;
		case 1:
			break;
		case 2:
			tile.blockType = BlockTypes::DOOR;
			break;
		case 5:
			tile.blockType = BlockTypes::TREASURE;
			break;
		case 3:
			tile.blockType = BlockTypes::LOCK;
			break;
		case 4:
			tile.blockType = BlockTypes::GEMS;
			break;
		case 6:
			tile.blockType = BlockTypes::DEADLY;
			break;
		case 7:
			tile.blockType = BlockTypes::TRAMPOLINE;
			break;
		case 8:
			tile.blockType = BlockTypes::CONSUMABLE;
			break;
		case 9:
			tile.blockType = BlockTypes::GATEWAY;
			break;
		case 12:
			tile.blockType = BlockTypes::TOGGLE_FOREGROUND;
			break;
		case 14:
			tile.blockType = BlockTypes::PLATFORM;
			break;
		case 10:
			tile.blockType = BlockTypes::SIGN;
			break;
		case 11:
			tile.blockType = BlockTypes::SFX_FOREGROUND;
			break;
		case 13:
			tile.blockType = BlockTypes::MAIN_DOOR;
			break;
		case 15:
			tile.blockType = BlockTypes::BEDROCK;
			break;
		case 17:
			tile.blockType = BlockTypes::FOREGROUND;
			break;
		case 18:
			tile.blockType = BlockTypes::BACKGROUND;
			break;
		case 19:
			if (tile.id == 866) cout << tile.id << endl;
			tile.blockType = BlockTypes::SEED;
			break;
		case 20:
			tile.blockType = BlockTypes::CLOTHING;
			switch (tile.clothingType) {
			case 0: tile.clothType = ClothTypes::HAIR;
				break;
			case 1: tile.clothType = ClothTypes::SHIRT;
				break;
			case 2: tile.clothType = ClothTypes::PANTS;
				break;
			case 3: tile.clothType = ClothTypes::FEET;
				break;
			case 4: tile.clothType = ClothTypes::FACE;
				break;
			case 5: tile.clothType = ClothTypes::HAND;
				break;
			case 6: tile.clothType = ClothTypes::BACK;
				break;
			case 7: tile.clothType = ClothTypes::MASK;
				break;
			case 8: tile.clothType = ClothTypes::NECKLACE;
				break;
			default:
				break;
			}

			break;
		case 21:
			tile.blockType = BlockTypes::ANIM_FOREGROUND;
			break;
		case 26:
			tile.blockType = BlockTypes::PORTAL;
			break;
		case 27:
			tile.blockType = BlockTypes::CHECKPOINT;
			break;
		case 28:
			tile.blockType = BlockTypes::BACKGROUND;
			break;
		case 31:
			tile.blockType = BlockTypes::SWITCH_BLOCK;
			break;
		case 32:
			tile.blockType = BlockTypes::CHEST;
			break;
		case 36:
			tile.blockType = BlockTypes::RANDOM_BLOCK;
			break;
		case 37:
			tile.blockType = BlockTypes::COMPONENT;
			break;
		case 41:
			tile.blockType = BlockTypes::WEATHER;
			break;
		case 51:
			tile.blockType = BlockTypes::MAGIC_EGG;
			break;
		case 47:
			tile.blockType = BlockTypes::DONATION;
			break;
		case 33:
			tile.blockType = BlockTypes::MAILBOX;
			break;
		case 34:
			tile.blockType = BlockTypes::BULLETIN_BOARD;
			break;
		case 49:
			tile.blockType = BlockTypes::Mannequin;
			break;
		case 61:
			tile.blockType = BlockTypes::DISPLAY;
			break;
		case 62:
			tile.blockType = BlockTypes::VENDING;
			break;
		case 76:
			tile.blockType = BlockTypes::Painting_Easel;
			break;
		case 83:
			tile.blockType = BlockTypes::DISPLAY_SHELF;
			break;
		case 107:
			tile.blockType = BlockTypes::CLOTHING;
			tile.clothType = ClothTypes::ANCES;
			break;
		case 111:
			tile.blockType = BlockTypes::SUCKER;
			break;
		case 103:
			tile.blockType = BlockTypes::FACTION;
		default:
			tile.blockType = BlockTypes::UNKNOWN;
			break;

		}

		CoreDataItems = tile.id;
		itemDefs.push_back(tile);
		coredatasize++;
	}
	craftItemDescriptions();
	delete[] data;
}






bool isOwner(string username, string password) {
	try {
		for (int i = 0; i < admins.size(); i++) {
			Admin admin = admins.at(i);
			if (admin.username == username && admin.password == password && admin.level == 3) {
				return true;
			}
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	return false;
}


bool isMod(string username, string password) {
	try {
		for (int i = 0; i < admins.size(); i++) {
			Admin admin = admins.at(i);
			if (admin.username == username && admin.password == password && admin.level >= 1) {
				return true;
			}
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	return false;
}

bool isDev(ENetPeer* peer) {
	try {
		if (((PlayerInfo*)(peer->data))->adminLevel > 1) {
			return true;
		}
		else {
			return false;
		}
	}
	catch(std::exception & e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
bool haveSubscription(ENetPeer* peer) {
	try {
		if (((PlayerInfo*)(peer->data))->haveSubscription) {
			return true;
		}
		else {
			return false;
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
bool adminLevel(ENetPeer* peer) {
	return ((PlayerInfo*)(peer->data))->adminLevel;
}
bool isWorldOwner(ENetPeer* peer, WorldInfo* world) {
	return ((PlayerInfo*)(peer->data))->rawName == world->owner;
}
bool isWorldAdmin(ENetPeer* peer, WorldInfo* world) {
	try {
		for (int i = 0; i < world->accessworld.size(); i++) {
			if (world->accessworld.at(i) == "") continue;
			if (world->accessworld.at(i) == ((PlayerInfo*)(peer->data))->rawName) return true;
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	return false;
}


void SendGamePacketEveryoneInWorld(ENetPeer* peer, GamePacket* p)
{
	ENetPacket* packet1 = enet_packet_create(p->data,
		p->len,
		ENET_PACKET_FLAG_RELIABLE);
	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer))
		{
			enet_peer_send(currentPeer, 0, packet1);
		}
	}
	delete p->data;
}
void UpdateTradeStatus(ENetPeer* peer1, int userID, int showOverlay = 0, bool doSelfToo = true)
{
	PlayerInfo* pinfo2 = NULL;
	PlayerInfo* pinfo = (PlayerInfo*)peer1->data;
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer1, currentPeer)) {
			if (pinfo->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer1->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
				pinfo2 = (PlayerInfo*)currentPeer->data;
				Player::OnTradeStatus(currentPeer, pinfo2->netID, "`oSelect an item from the inventory.``", "", FormatTradeItems(pinfo2->tradeItems) + "\nlocked|0\nreset_locks|1\naccepted|" + to_string(pinfo2->isAcceptingTrade) + "\n");
				Player::OnTradeStatus(currentPeer, pinfo->netID, "`o" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|0\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
				Player::OnTextOverlay(currentPeer, "The deal has changed");
				if (doSelfToo) {
					Player::OnTradeStatus(peer1, pinfo->netID, "`o" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|0\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
					Player::OnTextOverlay(peer1, "The deal has changed");
				}
				break;
			}
		}
	}
}
void skipMemPos(int& memPos, const char* data) {
	for (int j = 0; j < *&data[memPos - 2]; j++) memPos++;
}

void PlayAudioWorld(ENetPeer* peer, string audioFile)
{
	string text = "action|play_sfx\nfile|" + audioFile + "\ndelayMS|0\n";
	BYTE* data = new BYTE[5 + text.length()];
	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);
	ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer))
		{
			enet_peer_send(currentPeer, 0, packet2);
		}
	}
	delete[] data;
}

BYTE* packPlayerMoving(PlayerMoving* dataStruct)
{
	BYTE* data = new BYTE[56];
	try {
		for (int i = 0; i < 56; i++)
		{
			data[i] = 0;
		}
		memcpy(data, &dataStruct->packetType, 4);
		memcpy(data + 4, &dataStruct->netID, 4);
		memcpy(data + 12, &dataStruct->characterState, 4);
		memcpy(data + 20, &dataStruct->plantingTree, 4);
		memcpy(data + 24, &dataStruct->x, 4);
		memcpy(data + 28, &dataStruct->y, 4);
		memcpy(data + 44, &dataStruct->punchX, 4);
		memcpy(data + 48, &dataStruct->punchY, 4);
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	return data;
}

PlayerMoving* unpackPlayerMoving(BYTE* data)
{
	PlayerMoving* dataStruct = new PlayerMoving;
	try {
		memcpy(&dataStruct->packetType, data, 4);
		memcpy(&dataStruct->netID, data + 4, 4);
		memcpy(&dataStruct->characterState, data + 12, 4);
		memcpy(&dataStruct->plantingTree, data + 20, 4);
		memcpy(&dataStruct->x, data + 24, 4);
		memcpy(&dataStruct->y, data + 28, 4);
		memcpy(&dataStruct->punchX, data + 44, 4);
		memcpy(&dataStruct->punchY, data + 48, 4);
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	return dataStruct;
}

void SendPacket(int a1, string a2, ENetPeer* enetPeer)
{
	if (enetPeer)
	{
		ENetPacket* v3 = enet_packet_create(0, a2.length() + 5, 1);
		memcpy(v3->data, &a1, 4);
		//*(v3->data) = (DWORD)a1;
		memcpy((v3->data) + 4, a2.c_str(), a2.length());

		//cout << std::hex << (int)(char)v3->data[3] << endl;
		enet_peer_send(enetPeer, 0, v3);
	}
}
void SendPacketRaw3(int a1, void* packetData, size_t packetDataSize, void* a4, ENetPeer* peer, int packetFlag)
{
	ENetPacket* p;

	if (peer) // check if we have it setup
	{
		p = enet_packet_create(0, packetDataSize + 5, packetFlag);
		memcpy(p->data, &a1, 4);
		memcpy((char*)p->data + 4, packetData, packetDataSize);
		enet_peer_send(peer, 0, p);
	}
	delete (char*)packetData;
}

void SendPacketRaw2(int a1, void* packetData, size_t packetDataSize, void* a4, ENetPeer* peer, int packetFlag)
{
	ENetPacket* p;

	if (peer) // check if we have it setup
	{
		if (a1 == 4 && *((BYTE*)packetData + 12) & 8)
		{
			p = enet_packet_create(0, packetDataSize + *((DWORD*)packetData + 13) + 5, packetFlag);
			int four = 4;
			memcpy(p->data, &four, 4);
			memcpy((char*)p->data + 4, packetData, packetDataSize);
			memcpy((char*)p->data + packetDataSize + 4, a4, *((DWORD*)packetData + 13));
			enet_peer_send(peer, 0, p);

		}
		else
		{
			if (a1 == 192) {
				a1 = 4;
				p = enet_packet_create(0, packetDataSize + 5, packetFlag);
				memcpy(p->data, &a1, 4);
				memcpy((char*)p->data + 4, packetData, packetDataSize);
				enet_peer_send(peer, 0, p);


			}
			else {
				p = enet_packet_create(0, packetDataSize + 5, packetFlag);
				memcpy(p->data, &a1, 4);
				memcpy((char*)p->data + 4, packetData, packetDataSize);
				enet_peer_send(peer, 0, p);


			}
		}
	}

	delete packetData;
}


void SendPacketRaw(int a1, void* packetData, size_t packetDataSize, void* a4, ENetPeer* peer, int packetFlag)
{
	ENetPacket* p;

	if (peer) // check if we have it setup
	{
		if (a1 == 4 && *((BYTE*)packetData + 12) & 8)
		{
			p = enet_packet_create(0, packetDataSize + *((DWORD*)packetData + 13) + 5, packetFlag);
			int four = 4;
			memcpy(p->data, &four, 4);
			memcpy((char*)p->data + 4, packetData, packetDataSize);
			memcpy((char*)p->data + packetDataSize + 4, a4, *((DWORD*)packetData + 13));
			enet_peer_send(peer, 0, p);
		}
		else
		{
			try {
				p = enet_packet_create(0, packetDataSize + 5, packetFlag);
				memcpy(p->data, &a1, 4);
				memcpy((char*)p->data + 4, packetData, packetDataSize);
				enet_peer_send(peer, 0, p);
			}
			catch (...) {
				cout << "Failed to send packet raw" << endl;
			}
		}
	}
	delete (char*)packetData;
}

void RemoveAccess(ENetPeer* currentPeer, int x, int y, WorldInfo* world) {
	if (world == NULL || world == nullptr) return;
	PlayerMoving moving{};
	moving.packetType = 0x3;
	moving.characterState = 0x0;
	moving.x = x;
	moving.y = y;
	moving.punchX = x;
	moving.punchY = y;
	moving.netID = -1;
	moving.plantingTree = world->items[x + (y * world->width)].foreground;
	SendPacketRaw(4, packPlayerMoving(&moving), 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
}

void sendUpdatePacket(ENetPeer* peer, int32_t type, uint8_t* data, int32_t len) {
	const auto packet = enet_packet_create(NULL, len + 5, ENET_PACKET_FLAG_RELIABLE);
	const auto game_packet = (gametextpacket_t*)packet->data;
	game_packet->m_type = type;
	if (data) memcpy(&game_packet->m_data, data, len);
	memset(&game_packet->m_data + len, 0, 1);
	enet_peer_send(peer, 0, packet);
}

void send_dice(ENetPeer* peer, int netID, int number, int x, int y) {
	PlayerInfo* info = ((PlayerInfo*)(peer->data));
	int state = getState(info);
	gameupdatepacket_t packet;
	packet.m_type = 8;
	packet.m_netid = ((PlayerInfo*)(peer->data))->netID;
	packet.m_count = number;
	packet.m_player_flags = state;
	packet.m_packet_flags = 16;
	packet.m_vec_x = info->x;
	packet.m_vec_y = info->y;
	packet.m_state1 = x;
	packet.m_state2 = y;
	packet.m_data = 1097317;
	packet.m_int_data = 0;

	sendUpdatePacket(peer, 4, (uint8_t*)&packet, 56);
}

bool isWorldAdmin2(ENetPeer* peer, WorldInfo world) {
	if ((find(world.accessworld.begin(), world.accessworld.end(), ((PlayerInfo*)(peer->data))->rawName) != world.accessworld.end())) {
		return true;

	}
	else {
		return false;
	}
	return false;
}
void accessPlayer(ENetPeer* peer, WorldInfo* world) {
	if (world == NULL || world->name == "EXIT") return;
	if (isWorldOwner(peer, world) || isWorldAdmin(peer, world)) return;
	world->accessworld.push_back(((PlayerInfo*)(peer->data))->rawName);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
		if (isHere(peer, currentPeer)) {
			Player::OnConsoleMessage(currentPeer, ((PlayerInfo*)(peer->data))->displayName + " `owas given access to a World Lock.");
		}
	}
	if (((PlayerInfo*)(peer->data))->adminLevel == 0)
	{
		string lol999 = "";
		lol999 += ((PlayerInfo*)(peer->data))->displayName = "`^" + ((PlayerInfo*)(peer->data))->tankIDName;
		((PlayerInfo*)(peer->data))->displayName = "`^" + ((PlayerInfo*)(peer->data))->tankIDName;
		Player::OnNameChanged(peer, ((PlayerInfo*)(peer->data))->netID, lol999);
	}
}
void sendNotification(ENetPeer* peer, string audio, string image, string message)
{
	GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), image), message), audio), 0));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}
string packPlayerMoving2(PlayerMoving* dataStruct)
{
	string data;
	data.resize(56);
	STRINT(data, 0) = dataStruct->packetType;
	STRINT(data, 4) = dataStruct->netID;
	STRINT(data, 12) = dataStruct->characterState;
	STRINT(data, 20) = dataStruct->plantingTree;
	STRINT(data, 24) = *(int*)&dataStruct->x;
	STRINT(data, 28) = *(int*)&dataStruct->y;
	//xspeed and yspeed deleted cus someone crashed it./**/
	STRINT(data, 44) = dataStruct->punchX;
	STRINT(data, 48) = dataStruct->punchY;
	return data;
}
void sendTileData(ENetPeer* peer, int x, int y, int visual, uint16_t fgblock, uint16_t bgblock, string tiledata) {
	if (fgblock == 202 || fgblock == 204 || fgblock == 206 || fgblock == 4994) return;
	PlayerMoving pmov{};
	pmov.packetType = 5;
	pmov.characterState = 0;
	pmov.x = 0;
	pmov.y = 0;
	pmov.plantingTree = 0;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = 0;
	string packetstr;
	packetstr.resize(4);
	packetstr[0] = 4;
	packetstr += packPlayerMoving2(&pmov);
	packetstr[16] = 8;
	packetstr.resize(packetstr.size() + 4);
	STRINT(packetstr, 52 + 4) = tiledata.size() + 4;
	STR16(packetstr, 56 + 4) = fgblock;
	STR16(packetstr, 58 + 4) = bgblock;
	packetstr += tiledata;
	ENetPacket* packet = enet_packet_create(&packetstr[0], packetstr.length(), ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
}
void SendTileDataMultiple(ENetPeer* peer, WorldInfo* world, vector<point> pointsToUpdate)
{

	if (!world) return;
	vector<byte> packet;
	packet.resize(56, 0);
	packet[0] = 6; // packettype is 6
	packet[12] = 0xff;
	packet[13] = 0xff;
	packet[14] = 0xff;
	packet[15] = 0xff;

	int s = 56;
	for (int i = 0; i < pointsToUpdate.size(); i++)
	{
		// add points to update
		point p = pointsToUpdate.at(i);

		// Push_back the point first!
		BYTE* as = new BYTE[12];
		memcpy(as + 0, &p.x, 4);
		memcpy(as + 4, &p.y, 4);
		for (int j = 0; j < 8; j++) packet.push_back(as[j]);
		delete as;

		int a = 8, b = 8;

		// A and B now indicate size.
		BYTE* bt = new BYTE[a];
		memset(bt, 0, a);
		int c = 8, d = 8;

		for (int j = 0; j < a; j++) packet.push_back(0);
		delete bt;
		s += a;
	}

	packet.push_back(0xff); // This is the end marker!
	packet.push_back(0xff);
	packet.push_back(0xff);
	packet.push_back(0xff);



	// now the sending part.
	//ENetPacket* packet_enet = enet_packet_create(packet.data(), packet.size(), ENET_PACKET_FLAG_RELIABLE);
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			BYTE* DATA = new BYTE[packet.size()];
			//*((int*)DATA + 52) = s - 56;
			for (int i = 0; i < packet.size(); i++) DATA[i] = packet.at(i);
			//enet_peer_send(cpeer, 0, packet_enet);
			SendPacketRaw(4, DATA, packet.size(), NULL, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	//enet_packet_destroy(packet_enet);
}

void SendTradeEffect(ENetPeer* peer, int id, int netIDsrc, int netIDdst, int timeMs)
{
	PlayerMoving data;
	data.packetType = 0x13;
	data.punchX = id;
	data.punchY = id;

	BYTE* raw = packPlayerMoving(&data);
	int netIdSrc = netIDsrc;
	int netIdDst = netIDdst;
	int three = 3;
	int n1 = timeMs;
	memcpy(raw + 3, &three, 1);
	memcpy(raw + 4, &netIdDst, 4);
	memcpy(raw + 8, &netIdSrc, 4);
	memcpy(raw + 20, &n1, 4);
	BYTE* raw2 = new BYTE[56];
	memcpy(raw2, raw, 56);
	SendPacketRaw(4, raw2, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	delete raw;
}
uint8_t* magplantTileData(uint16_t itemid, uint16_t itemamount, uint8_t magnet_on, uint8_t remote_on) {
	uint8_t* data = new uint8_t[15];
	memset(data, 0, 15);
	data[0] = 0x3E;
	*(uint16_t*)(data + 1) = itemid;
	*(uint16_t*)(data + 5) = itemamount;
	*(uint8_t*)(data + 9) = magnet_on;
	*(uint8_t*)(data + 10) = remote_on;
	*(uint8_t*)(data + 12) = 1;
	return data;
}
void sendMag(ENetPeer* peer, const int blockid, const int x, const int y, const uint16_t itemid, const uint16_t itemamount, const uint8_t magneton, const uint8_t remoteon, const int background)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 8;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 15 + 8;
	uint8_t* packet = new uint8_t[4 + 56 + 15 + 8];
	memset(packet, 0, 4 + 56 + 15 + 8);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 4 + 56) = blockid; // magplant id
	*(uint16_t*)(packet + 4 + 56 + 6) = background;
	uint8_t* tiledata = magplantTileData(itemid, itemamount, magneton, remoteon);
	memcpy(packet + 4 + 56 + 8, tiledata, 15);
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 8 + 15, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;
	delete tiledata;
}
void sendHeatwave(ENetPeer* peer, int x, int y, uint8_t red, uint8_t green, uint8_t blue)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 8;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 5 + 8;
	uint8_t* packet = new uint8_t[4 + 56 + 5 + 8];
	memset(packet, 0, 4 + 56 + 5 + 8);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 4 + 56) = 3694; // heatwave id
	*(uint16_t*)(packet + 4 + 56 + 6) = 1;
	*(uint8_t*)(packet + 4 + 56 + 8) = 0x28;
	*(uint32_t*)(packet + 4 + 56 + 9) = (blue << 24) | (green << 16) | (red << 8);
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 8 + 5, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;

}

void SendThrowEffect(ENetPeer* peer, int id, int netIDsrc, int netIDdst, int timeMs, byte type, int x, int y)
{
	PlayerMoving data;
	data.packetType = 0x13;
	data.punchX = id;
	data.punchY = id;
	data.x = x;
	data.y = y;
	BYTE* raw = packPlayerMoving(&data);
	int netIdSrc = netIDsrc;
	int netIdDst = netIDdst;
	int three = 3;
	int n1 = timeMs;
	memcpy(raw + 3, &type, 1);
	memcpy(raw + 4, &netIdDst, 4);
	memcpy(raw + 8, &netIdSrc, 4);
	memcpy(raw + 20, &n1, 4);

	BYTE* raw2 = new BYTE[56];
	memcpy(raw2, raw, 56);
	SendPacketRaw(4, raw2, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	delete raw;
}

void onPeerConnect(ENetPeer* peer)
{
	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (peer != currentPeer)
		{
			if (isHere(peer, currentPeer))
			{
				string netIdS = std::to_string(((PlayerInfo*)(currentPeer->data))->netID);
				string netIdS3 = std::to_string(((PlayerInfo*)(currentPeer->data))->userID);
				GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + netIdS + "\nuserID|" + netIdS3 + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(((PlayerInfo*)(currentPeer->data))->x) + "|" + std::to_string(((PlayerInfo*)(currentPeer->data))->y) + "\nname|``" + ((PlayerInfo*)(currentPeer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(currentPeer->data))->country + "\ninvis|" + to_string(((PlayerInfo*)(currentPeer->data))->isInvisible) + "\nmstate|" + to_string(((PlayerInfo*)(currentPeer->data))->mstate) + "\nsmstate|" + to_string(((PlayerInfo*)(currentPeer->data))->smstate) + "\n"));
				ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet);
				delete p.data;
				string netIdS22 = std::to_string(((PlayerInfo*)(peer->data))->netID);
				string netIdS232 = std::to_string(((PlayerInfo*)(peer->data))->userID);
				GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + netIdS22 + "\nuserID|" + netIdS232 + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(((PlayerInfo*)(peer->data))->x) + "|" + std::to_string(((PlayerInfo*)(peer->data))->y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "\ninvis|" + to_string(((PlayerInfo*)(peer->data))->isInvisible) + "\nmstate|" + to_string(((PlayerInfo*)(peer->data))->mstate) + "\nsmstate|" + to_string(((PlayerInfo*)(peer->data))->smstate) + "\n"));
				ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2);
				delete p2.data;
			}
		}
	}
}

void updateAllClothes(ENetPeer* peer)
{
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer))
		{
			GamePacket p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), ((PlayerInfo*)(peer->data))->cloth_hair, ((PlayerInfo*)(peer->data))->cloth_shirt, ((PlayerInfo*)(peer->data))->cloth_pants), ((PlayerInfo*)(peer->data))->cloth_feet, ((PlayerInfo*)(peer->data))->cloth_face, ((PlayerInfo*)(peer->data))->cloth_hand), ((PlayerInfo*)(peer->data))->cloth_back, ((PlayerInfo*)(peer->data))->cloth_mask, ((PlayerInfo*)(peer->data))->cloth_necklace), ((PlayerInfo*)(peer->data))->skinColor), ((PlayerInfo*)(peer->data))->cloth_ances, 0.0f, 0.0f));
			memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet3);
			delete p3.data;
			//enet_host_flush(server);
			GamePacket p4 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), ((PlayerInfo*)(currentPeer->data))->cloth_hair, ((PlayerInfo*)(currentPeer->data))->cloth_shirt, ((PlayerInfo*)(currentPeer->data))->cloth_pants), ((PlayerInfo*)(currentPeer->data))->cloth_feet, ((PlayerInfo*)(currentPeer->data))->cloth_face, ((PlayerInfo*)(currentPeer->data))->cloth_hand), ((PlayerInfo*)(currentPeer->data))->cloth_back, ((PlayerInfo*)(currentPeer->data))->cloth_mask, ((PlayerInfo*)(currentPeer->data))->cloth_necklace), ((PlayerInfo*)(currentPeer->data))->skinColor), ((PlayerInfo*)(currentPeer->data))->cloth_ances, 0.0f, 0.0f));
			memcpy(p4.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4); // ffloor
			ENetPacket* packet4 = enet_packet_create(p4.data,
				p4.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet4);
			delete p4.data;
		}
	}
}


void sendClothes(ENetPeer* peer)
{
	ENetPeer* currentPeer;
	GamePacket p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), ((PlayerInfo*)(peer->data))->cloth_hair, ((PlayerInfo*)(peer->data))->cloth_shirt, ((PlayerInfo*)(peer->data))->cloth_pants), ((PlayerInfo*)(peer->data))->cloth_feet, ((PlayerInfo*)(peer->data))->cloth_face, ((PlayerInfo*)(peer->data))->cloth_hand), ((PlayerInfo*)(peer->data))->cloth_back, ((PlayerInfo*)(peer->data))->cloth_mask, ((PlayerInfo*)(peer->data))->cloth_necklace), ((PlayerInfo*)(peer->data))->skinColor), ((PlayerInfo*)(peer->data))->cloth_ances, 0.0f, 0.0f));
	memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor
	ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer))
		{
			enet_peer_send(currentPeer, 0, packet3);
		}

	}
	delete p3.data;
}
void sendPData(ENetPeer* peer, PlayerMoving* data)
{
	data->netID = ((PlayerInfo*)(peer->data))->netID;
	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (peer != currentPeer)
		{
			if (isHere(peer, currentPeer))
			{
				SendPacketRaw(4, packPlayerMoving(data), 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
			}
		}
	}
}
void sendRoulete(ENetPeer* peer) {
	auto pData = (PlayerInfo*)peer->data;
	if (pData->lastSpin + 3100 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
	{
		pData->lastSpin = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
	}
	else {
		return;
	}
	ENetPeer* currentPeer;
	auto val = rand() % 36;
	for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
		if (isHere(peer, currentPeer))
		{
			string name = pData->displayName;
			int respawnTimeout = 2000, deathFlag = 0x19;
			if (val == 1 || val == 3 || val == 5 || val == 7 || val == 9 || val == 12 || val == 14 || val == 16 || val == 18 || val == 19 || val == 21 || val == 23 || val == 25 || val == 27 || val == 30 || val == 32 || val == 34 || val == 36) {
				GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), pData->netID), "`w[" + name + " `wspun the wheel and got `4" + std::to_string(val) + "`w!]"), 0));
				memcpy(p2.data + 24, &respawnTimeout, 4);
				memcpy(p2.data + 56, &deathFlag, 4);
				ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2);
				delete p2.data;
				GamePacket p2s = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`7[`w" + name + " `ospun the wheel and got `4" + std::to_string(val) + "`o!`7]"));
				memcpy(p2s.data + 24, &respawnTimeout, 4);
				memcpy(p2s.data + 56, &deathFlag, 4);
				ENetPacket* packet2s = enet_packet_create(p2s.data, p2s.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2s);
				delete p2s.data;
			}
			else if (val == 2 || val == 4 || val == 6 || val == 8 || val == 10 || val == 11 || val == 13 || val == 15 || val == 17 || val == 20 || val == 22 || val == 24 || val == 26 || val == 28 || val == 29 || val == 31 || val == 33 || val == 35) {
				GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), pData->netID), "`w[" + name + " `wspun the wheel and got `b" + std::to_string(val) + "`w!]"), 0));
				memcpy(p2.data + 24, &respawnTimeout, 4);
				memcpy(p2.data + 56, &deathFlag, 4);
				ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2);
				delete p2.data;
				GamePacket p2s = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`7[`w" + name + " `ospun the wheel and got `b" + std::to_string(val) + "`o!`7]"));
				memcpy(p2s.data + 24, &respawnTimeout, 4);
				memcpy(p2s.data + 56, &deathFlag, 4);
				ENetPacket* packet2s = enet_packet_create(p2s.data, p2s.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2s);
				delete p2s.data;
			}
			else if (val == 0 || val == 37) {
				GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), pData->netID), "`w[" + name + " `wspun the wheel and got `20`w!]"), 0));
				memcpy(p2.data + 24, &respawnTimeout, 4);
				memcpy(p2.data + 56, &deathFlag, 4);
				ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2);
				delete p2.data;
				GamePacket p2s = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w[" + name + " `wspun the wheel and got `20`w!]"));
				memcpy(p2s.data + 24, &respawnTimeout, 4);
				memcpy(p2s.data + 56, &deathFlag, 4);
				ENetPacket* packet2s = enet_packet_create(p2s.data, p2s.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2s);
				delete p2s.data;
			}
		}
	}
}


void sendNothingHappened(ENetPeer* peer, int x, int y) {
	PlayerMoving data;
	data.netID = ((PlayerInfo*)(peer->data))->netID;
	data.packetType = 0x8;
	data.plantingTree = 0;
	data.netID = -1;
	data.x = x;
	data.y = y;
	data.punchX = x;
	data.punchY = y;
	SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}
void sendDice(ENetPeer* peer, int number, int x, int y) {

	PlayerMoving data;
	BYTE* raw = packPlayerMoving(&data);
	memcpy(raw + 1, &number, 3);

	data.netID = ((PlayerInfo*)(peer->data))->netID;
	data.packetType = 0x8;
	data.plantingTree = 0;
	data.netID = -1;
	data.x = x;
	data.y = y;
	data.punchX = x;
	data.punchY = y;
	SendPacketRaw(4, raw, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}
void SendTilePickup(ENetPeer* peer, int itemid, int netID, float x, float y, int itemcount, int itemamount) {
	PlayerMoving data;
	data.characterState = 0x0; // animation
	data.x = x * 32;
	data.y = y * 32;
	data.punchX = 0;
	data.punchY = 0;
	data.netID = -1;
	data.secondNetId = -1;
	data.plantingTree = itemid;
	data.packetType = 0xE;
	BYTE* raw = packPlayerMoving(&data);
	int netIdSrc = -1;
	int netIdDst = -1;
	int three = 3;
	int n1 = itemid;
	int one = 1;
	float count = itemamount;
	memcpy(raw + 3, &three, 1);
	memcpy(raw + 4, &netIdDst, 4);
	memcpy(raw + 8, &netIdSrc, 4);
	memcpy(raw + 16, &count, 4);
	memcpy(raw + 20, &n1, 4);

	((PlayerInfo*)(peer->data))->droppeditemcount++;
	SendPacketRaw(4, raw, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	PlayerMoving datax;
	datax.characterState = 0x0; // animation
	datax.x = x * 32;
	datax.y = y * 32;
	datax.punchX = 0;
	datax.punchY = 0;
	datax.netID = -1;
	datax.secondNetId = 0;
	datax.plantingTree = itemid;
	datax.packetType = 0xE;
	BYTE* raws = packPlayerMoving(&data);
	int lol = -1;


	memcpy(raws + 3, &three, 1);
	memcpy(raws + 4, &netID, 4);
	memcpy(raws + 8, &lol, 4);
	memcpy(raws + 20, &((PlayerInfo*)(peer->data))->droppeditemcount, 4);
	SendPacketRaw(4, raws, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}
void CountryFlag(WorldInfo* world, ENetPeer* peer, int x, int y, int fg, int bg, string flag) {
	int state = 0;
	if (world->items.at(x + (y * world->width)).flipped == true) state |= 0x00200000;
	int plength = 78 + flag.length(), tlen = flag.length(), zero = 0, mm = 660944929;
	BlockData data; data.packetType = 5; data.plength = plength; data.charState = 8; data.x = x; data.y = y; data.fg = fg; data.bg = bg; data.visual = state; data.visual2 = mm;
	BYTE* raw = makeData(data);
	raw[64] = 33;
	memcpy(raw + 65, &tlen, 4);
	memcpy(raw + 67, flag.c_str(), tlen);
	SendPacketRaw3(4, raw, data.plength, nullptr, peer, ENET_PACKET_FLAG_RELIABLE);
}
void UpdateVend(ENetPeer* peer, int x, int y, int id, bool locks, int price, int foreground, int background, bool isPer = false, WorldInfo* world = NULL) {
	if (world == NULL) return;
	if (price == 0) id = 0;
	auto options321 = 0;
	if (price >= 256 && price < 512) options321 = 1;
	else if (price >= 512 && price < 768) options321 = 2;
	else if (price >= 768 && price < 1024) options321 = 3;
	else if (price >= 1024 && price < 1280) options321 = 4;
	else if (price >= 1280 && price < 1536) options321 = 5;
	else if (price >= 1536 && price < 1792) options321 = 6;
	else if (price >= 1792 && price < 2048) options321 = 7;
	else if (price >= 2048 && price < 2304) options321 = 8;
	else if (price >= 2304 && price < 2560) options321 = 9;
	else if (price >= 2560 && price < 2816) options321 = 10;
	else if (price >= 2816 && price < 3072) options321 = 11;
	else if (price >= 3072 && price < 3328) options321 = 12;
	else if (price >= 3328 && price < 3584) options321 = 13;
	else if (price >= 3584 && price < 3840) options321 = 14;
	else if (price >= 3840 && price < 4096) options321 = 15;
	else if (price >= 4096 && price < 4352) options321 = 16;
	else if (price >= 4352 && price < 4608) options321 = 17;
	else if (price >= 4608 && price < 4864) options321 = 18;
	else if (price >= 4864 && price < 5120) options321 = 19;
	else if (price >= 5120 && price < 5376) options321 = 20;
	else if (price >= 5376 && price < 5632) options321 = 21;
	else if (price >= 5632 && price < 5888) options321 = 22;
	else if (price >= 5888 && price < 6144) options321 = 23;
	else if (price >= 6144 && price < 6400) options321 = 24;
	else if (price >= 6400 && price < 6656) options321 = 25;
	else if (price >= 6656 && price < 6912) options321 = 26;
	else if (price >= 6912 && price < 7168) options321 = 27;
	else if (price >= 7168 && price < 7424) options321 = 28;
	else if (price >= 7424 && price < 7680) options321 = 29;
	else if (price >= 7680 && price < 7936) options321 = 30;
	else if (price >= 7936 && price < 8192) options321 = 31;
	else if (price >= 8192 && price < 8448) options321 = 32;
	else if (price >= 8448 && price < 8704) options321 = 33;
	else if (price >= 8704 && price < 8960) options321 = 34;
	else if (price >= 8960 && price < 9216) options321 = 35;
	else if (price >= 9216 && price < 9472) options321 = 36;
	else if (price >= 9472 && price < 9728) options321 = 37;
	else if (price >= 9728 && price < 9984) options321 = 38;
	else if (price >= 9984 && price < 10240) options321 = 39;
	else if (price >= 10240 && price < 10496) options321 = 40;
	else if (price >= 10496 && price < 10752) options321 = 41;
	else if (price >= 10752 && price < 11008) options321 = 42;
	else if (price >= 11008 && price < 11264) options321 = 43;
	else if (price >= 11264 && price < 11520) options321 = 44;
	else if (price >= 11520 && price < 11776) options321 = 45;
	else if (price >= 11776 && price < 12032) options321 = 46;
	else if (price >= 12032 && price < 12288) options321 = 47;
	else if (price >= 12288 && price < 12544) options321 = 48;
	else if (price >= 12544 && price < 12800) options321 = 49;
	else if (price >= 12800 && price < 13056) options321 = 50;
	else if (price >= 13056 && price < 13312) options321 = 51;
	else if (price >= 13312 && price < 13568) options321 = 52;
	else if (price >= 13568 && price < 13824) options321 = 53;
	else if (price >= 13824 && price < 14080) options321 = 54;
	else if (price >= 14080 && price < 14336) options321 = 55;
	else if (price >= 14336 && price < 14592) options321 = 56;
	else if (price >= 14592 && price < 14848) options321 = 57;
	else if (price >= 14848 && price < 15104) options321 = 58;
	else if (price >= 15104 && price < 15360) options321 = 59;
	else if (price >= 15360 && price < 15616) options321 = 60;
	else if (price >= 15616 && price < 15872) options321 = 61;
	else if (price >= 15872 && price < 16128) options321 = 62;
	else if (price >= 16128 && price < 16384) options321 = 63;
	else if (price >= 16384 && price < 16640) options321 = 64;
	else if (price >= 16640 && price < 16896) options321 = 65;
	else if (price >= 16896 && price < 17152) options321 = 66;
	else if (price >= 17152 && price < 17408) options321 = 67;
	else if (price >= 17408 && price < 17664) options321 = 68;
	else if (price >= 17664 && price < 17920) options321 = 69;
	else if (price >= 17920 && price < 18176) options321 = 70;
	else if (price >= 18176 && price < 18432) options321 = 71;
	else if (price >= 18432 && price < 18688) options321 = 72;
	else if (price >= 18688 && price < 18944) options321 = 73;
	else if (price >= 18944 && price < 19200) options321 = 74;
	else if (price >= 19200 && price < 19456) options321 = 75;
	else if (price >= 19456 && price < 19712) options321 = 76;
	else if (price >= 19712 && price < 19968) options321 = 77;
	else if (price >= 19968 && price <= 20000) options321 = 78;
	price -= 256 * options321;
	TileExtra data{};
	data.packetType = 0x5;
	data.characterState = 8;
	data.punchX = x;
	data.punchY = y;
	data.charStat = 13;
	data.blockid = foreground;
	data.backgroundid = background;
	data.visual = 0x00410000 + getBlockState(world, x, y);
	if (locks == true) data.visual = 0x02410000 + getBlockState(world, x, y);
	auto n = id;
	string hex = "";
	{
		std::stringstream ss;
		ss << std::hex << n;
		string res(ss.str());
		hex = res + "18";
	}
	int xx;
	std::stringstream ss;
	ss << std::hex << hex;
	ss >> xx;
	data.displayblock = xx;
	int xes;
	{
		int wl = price;
		string basic_string = "";
		{
			std::stringstream stringstream;
			stringstream << std::hex << wl;
			string res(stringstream.str());
			basic_string = res + "00";
		}
		int i;
		std::stringstream basic_stringstream;
		basic_stringstream << std::hex << basic_string;
		basic_stringstream >> i;
		xes = i;
	}
	BYTE* raw = nullptr;
	if (isPer) {
		raw = packStuffVisual(&data, 16777215, -xes);
	}
	else {
		raw = packStuffVisual(&data, options321, xes);
	}
	SendPacketRaw2(192, raw, 102, nullptr, peer, ENET_PACKET_FLAG_RELIABLE);
	raw = NULL;
}
void UpdateMessageVisuals(ENetPeer* peer, int foreground, int x, int y, string text, int background, int bubbleType_ = 2, bool sendPacketToEveryone = true, int blockState = 0)
{
	if (text.size() > 120) return;
	// setting tile packet
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	// hopefully the magic :/
	int hmm = 8, textLen = text.size(), PacketType = 5;
	int yeh = hmm + 3 + 1, idk = 15 + textLen, endMarker = -1, sizeofshort = 2;
	int bubbleType = bubbleType_;
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int sizeofint = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	//MEMCPY DESTINATION					SOURCE			SIZE
	memcpy(data, &PacketType, sizeof(int));
	memcpy(data + yeh, &hmm, sizeof(int));
	memcpy(data + yup, &x, sizeof(int));
	memcpy(data + yup + 4, &y, sizeof(int));
	memcpy(data + 4 + yup + 4, &idk, sizeof(int));
	memcpy(data + magic, &foreground, sizeof(short));
	memcpy(data + magic + 2, &background, sizeof(short));
	memcpy(data + sizeofint + magic, &blockState, sizeof(int));
	memcpy(data + magic + 4 + sizeofint, &bubbleType, sizeof(byte));
	memcpy(data + wow, &textLen, sizeof(short));
	memcpy(data + sizeofshort + wow, text.c_str(), textLen);
	memcpy(data + ok, &endMarker, sizeof(int));
	memcpy(p->data, &sizeofint, sizeof(int));
	memcpy((char*)p->data + sizeofint, data, kek);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete[] data;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete[] data;
	}
}
void SendParticleEffectAll(ENetPeer* peer, int particle, float x, float y) {
	GamePacket p = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), particle), x, y));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		enet_peer_send(currentPeer, 0, packet);
	}
	delete p.data;
}

BYTE* packBlockVisual222(TileExtra* dataStruct)
{

	BYTE* data = new BYTE[104]; // 96
	for (int i = 0; i < 100; i++)
	{
		data[i] = 0;
	}
	memcpy(data, &dataStruct->packetType, 4);
	memcpy(data + 8, &dataStruct->netID, 4);
	memcpy(data + 12, &dataStruct->characterState, 4);
	memcpy(data + 16, &dataStruct->objectSpeedX, 4);
	//memcpy(data + 40, &dataStruct->bpm, 4);
	memcpy(data + 44, &dataStruct->punchX, 4);
	memcpy(data + 48, &dataStruct->punchY, 4);
	memcpy(data + 52, &dataStruct->charStat, 4);
	memcpy(data + 56, &dataStruct->blockid, 2);
	memcpy(data + 58, &dataStruct->backgroundid, 2);
	memcpy(data + 60, &dataStruct->visual, 4);
	memcpy(data + 64, &dataStruct->displayblock, 4);


	return data;
}
BYTE* packBlockVisual(TileExtra* dataStruct)
{

	BYTE* data = new BYTE[104]; // 96
	for (int i = 0; i < 100; i++)
	{
		data[i] = 0;
	}
	memcpy(data, &dataStruct->packetType, 4);
	memcpy(data + 8, &dataStruct->netID, 4);
	memcpy(data + 12, &dataStruct->characterState, 4);
	memcpy(data + 16, &dataStruct->objectSpeedX, 4);
	//memcpy(data + 40, &dataStruct->bpm, 4);
	memcpy(data + 44, &dataStruct->punchX, 4);
	memcpy(data + 48, &dataStruct->punchY, 4);
	memcpy(data + 52, &dataStruct->charStat, 4);
	memcpy(data + 56, &dataStruct->blockid, 2);
	memcpy(data + 58, &dataStruct->backgroundid, 2);
	memcpy(data + 60, &dataStruct->visual, 4);
	memcpy(data + 64, &dataStruct->displayblock, 4);


	return data;
}

BYTE* packBlockVisual(BlockVisual* dataStruct)
{
	BYTE* data = new BYTE[72];
	for (int i = 0; i < 72; i++)
	{
		data[i] = 0;
	}
	memcpy(data, &dataStruct->packetType, 4);
	memcpy(data + 8, &dataStruct->netID, 4);
	memcpy(data + 12, &dataStruct->characterState, 4);
	//memcpy(data + 40, &dataStruct->bpm, 4);
	memcpy(data + 44, &dataStruct->punchX, 4);
	memcpy(data + 48, &dataStruct->punchY, 4);
	memcpy(data + 52, &dataStruct->charStat, 4);
	memcpy(data + 56, &dataStruct->blockid, 4);
	memcpy(data + 58, &dataStruct->backgroundid, 4);
	memcpy(data + 60, &dataStruct->visual, 4);
	memcpy(data + 64, &dataStruct->displayblock, 4);


	return data;
}
void InitializePacketWithDisplayBlock(BYTE* raw)
{
	int i = 0;
	raw[i] = 0x05; i++; // fixed display block leak
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x08; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x56; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x15; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x0d; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x82; i++;
	raw[i] = 0x0b; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x01; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x17; i++;
	raw[i] = 0x82; i++;
	raw[i] = 0x04; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x6c; i++;
	raw[i] = 0xfd; i++;
	raw[i] = 0xfd; i++;
	raw[i] = 0xfd; i++;
}

void InitializePacketWithUnlockedDoor(BYTE* raw)
{
	int i = 0;
	raw[i] = 0x05; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x08; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x56; i++; // x - 4 bytes
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x15; i++; // y - 4 bytes
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x0d; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x0c; i++; // door ID / background ID - 4 bytes
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x01; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x01; i++;
	//raw[i] = 0x61; i++; // text??
	//raw[i] = 0x08; i++;
	//raw[i] = 0xeb; i++; // or 98 if locked
	//raw[i] = 0xfd; i++;
	//raw[i] = 0xfd; i++;
	//raw[i] = 0xfd; i++;
}

void UpdateDisplayShelf(ENetPeer* peer, int x, int y, int fg, int bg, int tiles1, int tiles2, int tiles3, int tiles4)
{
	try {
		BlockData data;
		data.packetType = 5;
		data.plength = 88;
		data.charState = 8;
		data.x = x;
		data.y = y;
		data.fg = fg;
		data.bg = bg;
		data.visual = 0;
		data.visual2 = 43;

		BYTE* raw = makeData(data);
		memcpy(raw + 69, &tiles1, 4);
		memcpy(raw + 65, &tiles2, 4);
		memcpy(raw + 73, &tiles3, 4);
		memcpy(raw + 77, &tiles4, 4);

		SendPacketRaw3(4, raw, data.plength, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	}
	catch (exception& n) {
		return;
	}
}
void UpdateDisplayVisuals(ENetPeer* peer, int foreground, int x, int y, int background, int itemid, bool sendPacketToEveryone = true)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = 0x56;
	sign.y = 0x15;
	sign.punchX = 0x56;
	sign.punchY = 0x15;
	sign.netID = -1;
	sign.plantingTree = 0x0b82;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	int plength = 73;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	InitializePacketWithDisplayBlock(raw);

	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &foreground, sizeof(short));
	memcpy(raw + 58, &background, sizeof(short));
	memcpy(raw + 65, &itemid, sizeof(int));

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete[] raw;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete[] raw;
	}
}

void UpdateUnlockedDoorVisuals(ENetPeer* peer, int foreground, int x, int y, int background, string text, bool sendPacketToEveryone = true, int visuals = 0)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = 0x56;
	sign.y = 0x15;
	sign.punchX = 0x56;
	sign.punchY = 0x15;
	sign.netID = -1;
	sign.plantingTree = 0x0b82;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	BYTE a = 0x98; // 0x08 for locked
	BYTE b = 0xeb; // 0x98 for locked
	uint32_t c = 0xfdfdfdfd;
	short textLen = (short)text.size();
	int plength = 73 + textLen;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	InitializePacketWithUnlockedDoor(raw);
	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &foreground, sizeof(short));
	memcpy(raw + 58, &background, sizeof(short));
	memcpy(raw + 60, &visuals, sizeof(int));
	memcpy(raw + 65, &textLen, sizeof(short));
	memcpy(raw + 67, text.c_str(), textLen);
	memcpy(raw + 67 + textLen, &a, 1);
	memcpy(raw + 68 + textLen, &b, 1);
	memcpy(raw + 69 + textLen, &c, 4);

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete[] raw;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete[] raw;
	}
}


void UpdateLockedDoorVisuals(ENetPeer* peer, int foreground, int x, int y, int background, string text, bool sendPacketToEveryone = true, int visuals = 0)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = 0x56;
	sign.y = 0x15;
	sign.punchX = 0x56;
	sign.punchY = 0x15;
	sign.netID = -1;
	sign.plantingTree = 0x0b82;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	BYTE a = 0x08; // 0x00 for unlocked
	BYTE b = 0x98; // 0xeb for unlocked
	uint32_t c = 0xfdfdfdfd;
	short textLen = (short)text.size();
	int plength = 73 + textLen;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	InitializePacketWithUnlockedDoor(raw);
	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &foreground, sizeof(short));
	memcpy(raw + 58, &background, sizeof(short));
	memcpy(raw + 60, &visuals, sizeof(int));
	memcpy(raw + 65, &textLen, sizeof(short));
	memcpy(raw + 67, text.c_str(), textLen);
	memcpy(raw + 67 + textLen, &a, 1);
	memcpy(raw + 68 + textLen, &b, 1);
	memcpy(raw + 69 + textLen, &c, 4);

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete[] raw;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete[] raw;
	}
}

void sendUnknownCommand(ENetPeer* _peer) {
	Player::OnConsoleMessage(_peer, "`4Unknown command.``  Enter `$/?`` for a list of valid commands.");
}



struct vec2i
{
	int m_x, m_y;

	vec2i(int x, int y)
		: m_x(x), m_y(y)
	{
	}

	bool operator==(const vec2i& other)
	{
		return m_x == other.m_x && m_y == other.m_y;
	}
};


void UpdateLock2(ENetPeer* peer, int bg, int x, int y, bool isPublic, int owner, int fg, vector<int> admin)
{
	const auto stat = 65536;
	const auto stat2 = isPublic ? 0x3008100 : 0x3000100;
	const auto adsize = admin.size();
	const auto len = 56 + 25 + admin.size() * 4;
	const auto cstat = 8;
	const auto type = 5;
	const auto four = 4;
	auto apos = 18;
	auto data = new BYTE[len];
	memset(data, 0, len);
	memcpy(data, &type, 4);
	memcpy(data + 12, &cstat, 4);
	memcpy(data + 44, &x, 4);
	memcpy(data + 48, &y, 4);
	memcpy(data + 56, &fg, 2);
	memcpy(data + 56 + 2, &bg, 2);
	memcpy(data + 56 + 4, &stat, 4);
	memcpy(data + 56 + 5, &stat2, 4);
	data[56 + 8] = 3;
	memcpy(data + 56 + 10, &owner, 4);
	memcpy(data + 56 + 14, &adsize, 4);
	for (auto& ad : admin)
	{
		memcpy(data + 56 + apos, &ad, 4);
		apos += 4;
	}
	ENetPacket* p = enet_packet_create(0, len + 4 + 5, ENET_PACKET_FLAG_RELIABLE);
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, data, len);
	enet_peer_send(peer, 0, p);

	delete[] data;
}



void UpdateTreeVisuals(ENetPeer* peer, int foreground, int x, int y, int background, int fruitCount, int timeIntoGrowth, bool forEveryone, int blockStateFlags, WorldInfo* world)
{
	int hmm = 8, packetType = 5, yeh = hmm + 3 + 1;
	int idk = 15 + 4, blockState = blockStateFlags, bubble_type = 4;
	int ok = 52 + idk;
	int packetSize = ok + 4;
	int yup = ok - 8 - idk;
	int four = 4;
	int magic = 56;
	int wew = ok + 5 + 4;
	int fc = (short)fruitCount;
	int time = (int)timeIntoGrowth;
	blockState |= 0x100000;
	int8_t* data = new int8_t[packetSize];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	memset(data, 0, packetSize);
	memcpy(data, &packetType, sizeof(int));
	memcpy(data + yeh, &hmm, sizeof(int));
	memcpy(data + yup, &x, sizeof(int));
	memcpy(data + yup + 4, &y, sizeof(int));
	memcpy(data + 4 + yup + 4, &idk, sizeof(int));
	memcpy(data + magic, &foreground, sizeof(short));
	memcpy(data + magic + 2, &background, sizeof(short));
	memcpy(data + magic + 4, &blockState, sizeof(int));
	memcpy(data + magic + 8, &bubble_type, sizeof(BYTE));
	memcpy(data + magic + 9 + 0, &time, 4);
	memcpy(data + magic + 9 + 4, &fc, 1);
	memcpy(data + ok, &blockState, sizeof(int));
	memcpy(p->data, &four, four);
	memcpy((char*)p->data + four, data, packetSize);
	if (forEveryone) {
		for (auto currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete[] data;
	}
	else {
		enet_peer_send(peer, 0, p);
		delete[] data;
	}
}

void Battle_Cage(ENetPeer* peer, const int x, const int y, const int fg, const int bg, string text, bool clear_arr) {
	if (clear_arr) {
		PlayerMoving sign;
		sign.packetType = 0x3;
		sign.characterState = 0x0;
		sign.x = 0x56;
		sign.y = 0x15;
		sign.punchX = 0x56;
		sign.punchY = 0x15;
		sign.netID = -1;
		sign.plantingTree = 0x0b82;
		SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
		//deleter raw
		return;
	}

	int plength = 84 + text.length();
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	raw[0] = 5, raw[1] = 0, raw[2] = 0, raw[3] = 0, raw[4] = 0, raw[5] = 0, raw[6] = 0, raw[7] = 0, raw[8] = 0, raw[9] = 0, raw[10] = 0, raw[11] = 2048, raw[12] = 8, raw[13] = 0, raw[14] = 0, raw[15] = 0, raw[16] = 0, raw[17] = 0, raw[18] = 0, raw[19] = 0, raw[20] = 0, raw[21] = 0, raw[22] = 0, raw[23] = 0, raw[24] = 0, raw[25] = 0, raw[26] = 0, raw[27] = 0, raw[28] = 0, raw[29] = 0, raw[30] = 0, raw[31] = 0, raw[32] = 0, raw[33] = 0, raw[34] = 0, raw[35] = 0, raw[36] = 0, raw[37] = 0, raw[38] = 0, raw[39] = 0, raw[40] = 0, raw[41] = 0, raw[42] = 0, raw[43] = 14848, raw[44] = 58, raw[45] = 0, raw[46] = 0, raw[47] = 5888, raw[48] = 23, raw[49] = 0, raw[50] = 0, raw[51] = 7424, raw[52] = 29, raw[53] = 0, raw[54] = 0, raw[55] = 56320, raw[56] = 3548, raw[57] = 13, raw[58] = 0, raw[59] = 0, raw[60] = 0, raw[61] = 256, raw[62] = 1, raw[63] = 9216, raw[64] = 1572, raw[65] = 6, raw[66] = 19456, raw[67] = 28492, raw[68] = 27759, raw[69] = 19820, raw[70] = 24909, raw[71] = 29537, raw[72] = 39027, raw[73] = 4760, raw[74] = 18, raw[75] = 0, raw[76] = 49664, raw[77] = 5570, raw[78] = 21, raw[79] = 0, raw[80] = 39424, raw[81] = 1946, raw[82] = 7, raw[83] = 0, raw[84] = 59136, raw[85] = 64999, raw[86] = 65021, raw[87] = 65021, raw[88] = 65021, raw[89] = 56829;

	int d = fg;
	int e = bg;
	int a = text.length();
	int o = 4760; // type petnya...
	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &d, sizeof(short));
	memcpy(raw + 58, &e, sizeof(short));
	memcpy(raw + 65, &a, 4);
	memcpy(raw + 67, text.c_str(), text.length());
	memcpy(raw + 67 + a, &o, sizeof(int));

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);
	enet_peer_send(peer, 0, p);
	delete[] raw;
}
void Portrait(ENetPeer* peer, int x, int y, int fg, int bg, int hairs, int mask, int face, int skin, int emoji, string text, int state) {
	int plength = 98 + text.length(), tlen = text.length();
	BlockData data;
	data.packetType = 5;
	data.plength = plength;
	data.charState = 8;
	data.x = x; data.y = y;
	data.fg = fg; data.bg = bg;
	data.visual = state;
	data.visual2 = 822091824;
	BYTE* raw = makeData(data);
	memcpy(raw + 65, &tlen, 4);
	memcpy(raw + 67, text.c_str(), tlen);
	memcpy(raw + 67 + tlen, &emoji, 2);
	memcpy(raw + 79 + tlen, &skin, 4);
	memcpy(raw + 83 + tlen, &face, 2);
	memcpy(raw + 85 + tlen, &mask, 2);
	memcpy(raw + 87 + tlen, &hairs, 2);
	SendPacketRaw3(4, raw, data.plength + 5 + 4, nullptr, peer, ENET_PACKET_FLAG_RELIABLE);
}

void UpdateBlockState(ENetPeer* peer, int x, int y, bool forEveryone, WorldInfo* worldInfo) {

	try {
		if (!worldInfo) return;

		int i = y * worldInfo->width + x;

		int blockStateFlags = 0;


		if (worldInfo->items.at(i).flipped)
			blockStateFlags |= 0x00200000;
		if (worldInfo->items.at(i).entrance_open)
			blockStateFlags |= 8388608;
		if (worldInfo->items.at(i).water)
			blockStateFlags |= 0x04000000;
		if (worldInfo->items.at(i).glue)
			blockStateFlags |= 0x08000000;
		if (worldInfo->items.at(i).fire)
			blockStateFlags |= 0x10000000;
		if (worldInfo->items.at(i).red)
			blockStateFlags |= 0x20000000;
		if (worldInfo->items.at(i).green)
			blockStateFlags |= 0x40000000;
		if (worldInfo->items.at(i).blue)
			blockStateFlags |= 0x80000000;
		if (worldInfo->items.at(i).activated)
			blockStateFlags |= 0x00400000;
		if (worldInfo->items.at(i).silenced)
			blockStateFlags |= 0x02400000;






		if (blockStateFlags != 0)
		{
			TileExtra data;
			data.packetType = 0x5;
			data.characterState = 8;
			data.charStat = 8;
			data.blockid = worldInfo->items.at(i).foreground;
			data.backgroundid = worldInfo->items.at(i).background;
			data.visual = blockStateFlags;
			data.punchX = x;
			data.punchY = y;

			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
					continue;
				if (isHere(peer, currentPeer)) {
					SendPacketRaw2(192, packBlockVisual(&data), 100, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
				}
			}

		}
		else {
			TileExtra data;
			data.packetType = 0x5;
			data.characterState = 8;
			data.charStat = 8;
			data.blockid = worldInfo->items.at(i).foreground;
			data.backgroundid = worldInfo->items.at(i).background;
			data.visual = blockStateFlags;
			data.punchX = x;
			data.punchY = y;

			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
					continue;
				if (isHere(peer, currentPeer)) {
					SendPacketRaw2(192, packBlockVisual(&data), 100, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
				}
			}

		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
void SaveBlockState(WorldInfo* world, ENetPeer* peer, int x, int y)
{
	int water = 0;
	int fire = 0;
	int glue = 0;
	int aktif = 0;
	int multi = 0;
	int red = 0;
	int green = 0;
	int blue = 0;
	int saved_entrance = 0;
	int flipped = 0;
	int activated = 0;
	int re_applied = 0;
	int rm = 0;
	int opened = 0;
	int silenced = 0;
	if (world->items.at(x + (y * world->width)).water == true) water = 1;
	if (world->items.at(x + (y * world->width)).glue == true) glue = 1;
	if (world->items.at(x + (y * world->width)).fire == true) fire = 1;
	if (world->items.at(x + (y * world->width)).red == true) red = 1;
	if (world->items.at(x + (y * world->width)).green == true) green = 1;
	if (world->items.at(x + (y * world->width)).blue == true) blue = 1;
	if (world->items.at(x + (y * world->width)).entrance_open == true) saved_entrance = 1;
	if (world->items.at(x + (y * world->width)).flipped == true) flipped = 1;
	if (world->items.at(x + (y * world->width)).activated == true) activated = 1;
	if (world->items.at(x + (y * world->width)).opened == true) opened = 1;
	if (world->items.at(x + (y * world->width)).rm == true) rm = 1;
	if (world->items.at(x + (y * world->width)).silenced) silenced = 1;
	world->items.at(x + (y * world->width)).blockstate = to_string(water) + "," + to_string(glue) + "," + to_string(fire) + "," + to_string(red) + "," + to_string(green) + "," + to_string(blue) + "," + to_string(saved_entrance) + "," + to_string(flipped) + "," + to_string(activated) + "," + to_string(opened) + "," + to_string(re_applied) + "," + to_string(rm) + "," + to_string(silenced) + ",";
}
void updateDoor(ENetPeer* peer, int foreground, int background, int x, int y, string text)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8;
	int text_len = text.length();
	int lol = 0;
	int wut = 5;
	int yeh = hmm + 3 + 1;
	int idk = 15 + text_len;
	int is_locked = 0;
	int bubble_type = 1;
	int ok = 52 + idk;
	int kek = ok + 4;
	int yup = ok - 8 - idk;
	int four = 4;
	int magic = 56;
	int uhm = 58;
	int wew = ok + 5 + 4;
	int wow = magic + 4 + 5;

	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, four); //4
	memcpy(data + yeh, &hmm, four); //8
	memcpy(data + yup, &x, 4); //12
	memcpy(data + yup + 4, &y, 4); //16
	memcpy(data + 4 + yup + 4, &idk, four); //20
	memcpy(data + magic, &foreground, 2); //22
	memcpy(data + uhm, &background, 2);
	memcpy(data + four + magic, &lol, four); //26
	memcpy(data + magic + 4 + four, &bubble_type, 1); //27
	memcpy(data + wow, &text_len, 2); //data + wow = text_len, pos 29
	memcpy(data + 2 + wow, text.c_str(), text_len); //data + text_len_len + text_len_offs = text, pos 94
	memcpy(data + ok, &is_locked, four); //98
	memcpy(p->data, &four, four); //4
	memcpy((char*)p->data + four, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete[] data;
}

void UpdateVisualsForBlock(ENetPeer* peer, bool forEveryone, int x, int y, WorldInfo* worldInfo, bool useLockId = true, string msg = "") {
	try {
		if (!worldInfo) return;
		const auto i = y * worldInfo->width + x;
		auto blockStateFlags = 0;
		if (worldInfo->items.at(i).flipped) blockStateFlags |= 0x00200000;
		if (worldInfo->items.at(i).entrance_open) blockStateFlags |= 8388608;
		if (worldInfo->items.at(i).water) blockStateFlags |= 0x04000000;
		if (worldInfo->items.at(i).glue) blockStateFlags |= 0x08000000;
		if (worldInfo->items.at(i).fire) blockStateFlags |= 0x10000000;
		if (worldInfo->items.at(i).red) blockStateFlags |= 0x20000000;
		if (worldInfo->items.at(i).green) blockStateFlags |= 0x40000000;
		if (worldInfo->items.at(i).blue) blockStateFlags |= 0x80000000;
		else if (getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::MAIN_DOOR) {
			UpdateUnlockedDoorVisuals(peer, worldInfo->items.at(i).foreground, x, y, worldInfo->items.at(i).background, "EXIT", forEveryone, blockStateFlags);
		}
		else if (worldInfo->items.at(i).foreground == 2946) {
			UpdateDisplayVisuals(peer, worldInfo->items.at(i).foreground, x, y, worldInfo->items.at(i).background, worldInfo->items.at(i).intdata);
		}
		else if (getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::SIGN) {
			UpdateMessageVisuals(peer, worldInfo->items.at(i).foreground, x, y, msg, worldInfo->items.at(i).background, 2, true, blockStateFlags);
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
void PlayAudioSelf(ENetPeer* peer, string audioFile)
{
	string text = "action|play_sfx\nfile|" + audioFile + "\ndelayMS|0\n";
	BYTE* data = new BYTE[5 + text.length()];
	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);
	ENetPacket* packet2 = enet_packet_create(data,
		5 + text.length(),
		ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, packet2);
	delete[] data;

}


void sendCustomState(ENetPeer* peer, PlayerInfo* info, int xpseed, int yspeed) {
	//return; // TODO
	int netID = info->netID;
	ENetPeer* currentPeer;
	int state = getState(info);
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			float water = 125.0f;
			data.packetType = 0x14;
			data.characterState = 0; // animation
			data.x = 1000;
			if (((PlayerInfo*)(peer->data))->cloth_hand == 366) {
				data.y = -400; // - is hbow
			}
			else {
				data.y = 400;
			}
			data.punchX = 0;
			data.punchY = 0;
			data.netID = netID;
			data.plantingTree = state;
			BYTE* raw = packPlayerMoving(&data);
			int var = 0x818100; // placing and breking 0x808040 
			memcpy(raw + 1, &var, 3);
			memcpy(raw + 16, &water, 4);
			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}

int PunchEffect(ENetPeer* peer)
{
	auto result = 0;

	if (((PlayerInfo*)(peer->data))->cloth_hand == 11006)
	{
		result = 0x008080D1;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 5480)
	{
		result = 8421456;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 9716)
	{
		result = 8421529;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_shirt == 1780)
	{
		result = 8421396;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_shirt == 10426)
	{
		result = 8421559;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_face == 1204) {
		result = 8421386;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_face == 138) {
		result = 8421377;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_face == 2476) {
		result = 8421415;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 366 || ((PlayerInfo*)(peer->data))->cloth_hand == 1464) {
		result = 8421378;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 472) {
		result = 8421379;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 7912) {
		result = 8421487;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 594) {
		result = 8421380;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 768) {
		result = 8421381;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 900) {
		result = 8421382;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 910) {
		result = 8421383;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 930) {
		result = 8421384;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1016) {
		result = 8421385;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1378) {
		result = 8421387;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1484) {
		result = 8421389;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1512) {
		result = 8421390;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1542) {
		result = 8421391;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1576) {
		result = 8421392;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1676) {
		result = 8421393;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1710) {
		result = 8421394;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1748) {
		result = 8421395;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1782) {
		result = 8421397;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1804) {
		result = 8421398;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1868) {
		result = 8421399;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1874) {
		result = 8421400;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1946) {
		result = 8421401;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1948) {
		result = 8421402;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1956) {
		result = 8421403;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2908) {
		result = 8421405;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2952) {
		result = 8421405;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 6312) {
		result = 8421405;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1980) {
		result = 8421406;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2066) {
		result = 8421407;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2212) {
		result = 8421408;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2218) {
		result = 8421409;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_feet == 2220) {
		result = 8421410;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2266) {
		result = 8421411;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2386) {
		result = 8421412;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2388) {
		result = 8421413;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2450) {
		result = 8421414;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2512) {
		result = 8421417;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2572) {
		result = 8421418;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2592) {
		result = 8421419;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2720) {
		result = 8421420;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2752) {
		result = 8421421;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2754) {
		result = 8421422;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2756) {
		result = 8421423;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2802) {
		result = 8421425;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2866) {
		result = 8421426;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2876) {
		result = 8421427;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2886) {
		result = 8421430;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 2890) {
		result = 8421431;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3066) {
		result = 8421433;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3124) {
		result = 8421434;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3168) {
		result = 8421435;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3214) {
		result = 8421436;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3300) {
		result = 8421440;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3418) {
		result = 8421441;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3476) {
		result = 8421442;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3686) {
		result = 8421444;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3716) {
		result = 8421445;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 4290) {
		result = 8421447;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 4474) {
		result = 8421448;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 4464) {
		result = 8421449;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 1576) {
		result = 8421450;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 4778 || ((PlayerInfo*)(peer->data))->cloth_hand == 6026) {
		result = 8421452;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 4996) {
		result = 8421453;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 4840) {
		result = 8421454;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 5480) {
		result = 8421456;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 6110) {
		result = 8421457;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 6308) {
		result = 8421458;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 6310) {
		result = 8421459;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 6298) {
		result = 8421460;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 6756) {
		result = 8421461;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 7044) {
		result = 8421462;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_shirt == 6892) {
		result = 8421463;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 7088) {
		result = 8421465;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 7098) {
		result = 8421466;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_shirt == 7192) {
		result = 8421467;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_shirt == 7136) {
		result = 8421468;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_mask == 7216) {
		result = 8421470;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_back == 7196) {
		result = 8421471;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_back == 7392) {
		result = 8421472;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_feet == 7384) {
		result = 8421474;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 7488) {
		result = 8421479;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 7586) {
		result = 8421480;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 7650) {
		result = 8421481;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_feet == 7950) {
		result = 8421489;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 8036) {
		result = 8421494;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 8910) {
		result = 8421505;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 8942) {
		result = 8421506;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 8948) {
		result = 8421507;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 8946) {
		result = 8421509;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_back == 9006) {
		result = 8421511;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 9116 || ((PlayerInfo*)(peer->data))->cloth_hand == 9118 || ((PlayerInfo*)(peer->data))->cloth_hand == 9120 || ((PlayerInfo*)(peer->data))->cloth_hand == 9122) {
		result = 8421376 + 111;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_necklace == 11232) {
		result = 8421376 + 224;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_necklace == 9376) {
		result = 8421525;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_ances == 9236) {
		result = 8421521;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_hand == 3066) {
		result = 8421433;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_back == 10960) {
		result = 8421559;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_back == 10456) {
		result = 8421559;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_back == 7480) {
		result = 8421396;
	}
	else if (((PlayerInfo*)(peer->data))->cloth_pants == 10914) {
		result = 8421580;
	}
	else {
		result = 0x818100;
	}
	return result;
}

void sendState(ENetPeer* peer, int Xspeed = 300, int Yspeed = 1000) { // lol
	//return; // TODO
	PlayerInfo* info = (PlayerInfo*)peer->data;
	int netID = info->netID;
	ENetPeer* currentPeer;
	int state = getState(info);
	int statey = 0;
	if (info->cloth_hand == 6028) statey = 1024;
	if (info->cloth_hand == 6262) statey = 8192;
	if (info->tutorial) statey = 32768;
	if (((PlayerInfo*)(peer->data))->currentWorld == "DEATHMATCH") {
		statey = 2097152;
	}
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			float water = 125.0f;
			data.packetType = 0x14;
			data.characterState = statey; // animation
			data.x = 1000;
			if (((PlayerInfo*)(peer->data))->cloth_hand == 366) {
				data.y = -400; // - is hbow
			}
			else {
				data.y = 400;
			}
			data.punchX = 0;
			data.punchY = 0;
			//data.XSpeed = Xspeed;
			//data.YSpeed = Yspeed;
			data.netID = netID;
			data.plantingTree = state;
			BYTE* raw = packPlayerMoving(&data);
			int var = PunchEffect(peer);
			float p3 = Xspeed;
			float p4 = Yspeed;
			memcpy(raw + 1, &var, 3);
			memcpy(raw + 16, &water, 4);
			memcpy(raw + 32, &p3, 4);
			memcpy(raw + 36, &p4, 4);
			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}
void sendStuffweather(ENetPeer* peer, int x, int y, uint16_t itemid, uint16_t gravity, bool spin, bool invert)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 8;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 10 + 8;
	uint8_t* packet = new uint8_t[4 + 56 + 10 + 8];
	memset(packet, 0, 4 + 56 + 10 + 8);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 4 + 56) = 3832; // bg machine id
	*(uint16_t*)(packet + 4 + 56 + 6) = 1;
	*(uint8_t*)(packet + 4 + 56 + 8) = 0x31;
	*(uint32_t*)(packet + 4 + 56 + 9) = itemid;
	*(uint32_t*)(packet + 4 + 56 + 13) = gravity;
	*(uint8_t*)(packet + 4 + 56 + 17) = spin | (invert << 1);
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 8 + 10, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;
}
void sendBackground(ENetPeer* peer, int x, int y, uint16_t itemid)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 8;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 5 + 8;
	uint8_t* packet = new uint8_t[4 + 56 + 5 + 8];
	memset(packet, 0, 4 + 56 + 5 + 8);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 4 + 56) = 5000; // bg machine id
	*(uint16_t*)(packet + 4 + 56 + 6) = 1;
	*(uint8_t*)(packet + 4 + 56 + 8) = 0x28;
	*(uint16_t*)(packet + 4 + 56 + 9) = itemid;
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 8 + 5, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;
}
bool isInside(int circle_x, int circle_y,
	int rad, int x, int y)
{

	if ((x - circle_x) * (x - circle_x) +
		(y - circle_y) * (y - circle_y) <= rad * rad)
		return true;
	else
		return false;

}
void Donation_BOX(BYTE* raw)
{
	raw[0] = 5;
	raw[1] = 0;
	raw[2] = 0;
	raw[3] = 0;
	raw[4] = 0;
	raw[5] = 0;
	raw[6] = 0;
	raw[7] = 0;
	raw[8] = 0;
	raw[9] = 0;
	raw[10] = 0;
	raw[11] = 2048;
	raw[12] = 8;
	raw[13] = 0;
	raw[14] = 0;
	raw[15] = 0;
	raw[16] = 0;
	raw[17] = 0;
	raw[18] = 0;
	raw[19] = 0;
	raw[20] = 0;
	raw[21] = 0;
	raw[22] = 0;
	raw[23] = 0;
	raw[24] = 0;
	raw[25] = 0;
	raw[26] = 0;
	raw[27] = 0;
	raw[28] = 0;
	raw[29] = 0;
	raw[30] = 0;
	raw[31] = 0;
	raw[32] = 0;
	raw[33] = 0;
	raw[34] = 0;
	raw[35] = 0;
	raw[36] = 0;
	raw[37] = 0;
	raw[38] = 0;
	raw[39] = 0;
	raw[40] = 0;
	raw[41] = 0;
	raw[42] = 0;
	raw[43] = 12032;
	raw[44] = 47;
	raw[45] = 0;
	raw[46] = 0;
	raw[47] = 5632;
	raw[48] = 22;
	raw[49] = 0;
	raw[50] = 0;
	raw[51] = 3840;
	raw[52] = 15;
	raw[53] = 0;
	raw[54] = 0;
	raw[55] = 44032;
	raw[56] = 1452;
	raw[57] = 5;
	raw[58] = 0;
	raw[59] = 0;
	raw[60] = 0;
	raw[61] = 16640;
	raw[62] = 65;
	raw[63] = 512;
	raw[64] = 2;
	raw[65] = 0;
	raw[66] = 65280;
	raw[67] = 65535;
	raw[68] = 65535;
	raw[69] = 65535;
	raw[70] = 255;
	raw[71] = 64768;
	raw[72] = 65021;
	raw[73] = 65021;
	raw[74] = 65021;
	raw[75] = 27389;
}
void SendDonateData2(ENetPeer* peer, short fg, short bg, int x, int y, int item) {
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = 0x56;
	sign.y = 0x15;
	sign.punchX = 0x56;
	sign.punchY = 0x15;
	sign.netID = -1;
	sign.plantingTree = fg;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	int plength = 75;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	Donation_BOX(raw);

	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &fg, sizeof(short));
	memcpy(raw + 58, &bg, sizeof(short));
	memcpy(raw + 62, &item, sizeof(int));

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);
	enet_peer_send(peer, 0, p);
	delete[] raw;
}

void SendDonateData(WorldInfo* world, ENetPeer* peer, short fg, short bg, int x, int y, int item) {
	int xx = 65;
	if (world->items[x + (y * world->width)].flipped) xx = 97;
	byte* ExtendedData = new byte[15];
	int state = 0x0010000;
	int zero = 0;
	int extendedLen = 15;
	int stt = 65;

	PlayerMoving pmov;
	pmov.packetType = 0x5;
	pmov.characterState = 0x8;
	pmov.punchX = x;
	pmov.punchY = y;

	byte* raw = new byte[56 + 15];
	memcpy(raw, packPlayerMoving(&pmov), 56);
	memcpy(raw + 52, &extendedLen, 4);

	memcpy(ExtendedData, &fg, 2);
	memcpy(ExtendedData + 2, &bg, 2);

	ExtendedData[4] = 0;
	ExtendedData[5] = 0;
	ExtendedData[6] = item;
	ExtendedData[7] = 0;





	memcpy(raw + 56, ExtendedData, extendedLen);
	if (item != 0) memcpy(raw + 62, &xx, 4);

	SendPacketRaw3(4, raw, 56 + 15, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	delete[] ExtendedData; // fix memleak by playingo

}
void sendDrop(ENetPeer* peer, int netID, int x, int y, int item, int count, BYTE specialEffect)
{
	if (item > CoreDataItems) return;
	if (item < 0) return;
	ENetPeer* currentPeer;
	string name = "";
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			data.packetType = 14;
			data.x = x;
			data.y = y;
			data.netID = netID;
			data.plantingTree = item;
			float val = count; // item count
			BYTE val2 = specialEffect;

			BYTE* raw = packPlayerMoving(&data);
			memcpy(raw + 16, &val, 4);
			memcpy(raw + 1, &val2, 1);

			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}
void RemoveDroppedItem(ENetPeer* peer, int obj_id, WorldInfo* world)
{
	if (!world) return;


	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			BYTE* b = new BYTE[56];
			memset(b, 0, 56);
			*((int*)&b[0]) = 0xe;
			*((int*)&b[4]) = -2; // type
			*((int*)&b[8]) = -1;
			*((int*)&b[20]) = obj_id + 1; // source ID 1

			SendPacketRaw(4, b, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}
int processTakeServer(WorldInfo* world, ENetPeer* peer, const int itemIdx) {
	if (world == NULL) return -1;
	try {
		auto legit = true;
		auto atik = -1;
		for (auto i = 0; i < world->droppedItems.size(); i++) {
			if (world->droppedItems.at(i).uid == itemIdx) {
				atik = i;
				break;
			}
		}
		legit = atik != -1;
		if (legit) {
			try {
				world->droppedItems.erase(world->droppedItems.begin() + atik);
			}
			catch (...) {
				return -1;
			}
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	return 0;
}
int dropItem(WorldInfo* world, ENetPeer* peer, int netID, int x, int y, int item, int count, BYTE specialEffect)
{
	if (!world) return -1;
	if (item >= (coredatasize - 2)) return -1;
	if (item < 0)  return -1;
	if (x == 0 || y == 0)  return -1;
	bool hasmag = false;
	int blockX = x / 32;
	int blockY = y / 32;
	if (blockX<0 || blockY<0 || blockX>world->width || blockY>world->height) return -1;
	for (auto i = 0; i < world->width * world->height; i++) {
		if (world->items.at(i).foreground == 5638 || world->items.at(i).foreground == 6946 || world->items.at(i).foreground == 6948) {
			if (world->items.at(i).intdata != 0) {
				if (item == world->items.at(i).intdata) {
					if (world->items.at(i).fruitcount <= 5000 || world->items.at(i).intdata == 112) {
						const auto xx = i % world->width, yy = i / world->width;
						hasmag = true;
						world->items.at(i).fruitcount += count;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
							if (isHere(peer, currentPeer)) {
								SendThrowEffect(currentPeer, item, static_cast<PlayerInfo*>(peer->data)->netID, -1, 200, 0, xx * 32 + 16, yy * 32 + 16);
								if (world->items.at(i).fruitcount <= 0) {
									sendMag(currentPeer, world->items.at(i).foreground, xx, yy, world->items.at(i).intdata, 0, true, true, world->items.at(i).background);
								}
								else if (world->items.at(i).fruitcount >= 5000 && world->items.at(i).intdata != 112) {
									sendMag(currentPeer, world->items.at(i).foreground, xx, yy, world->items.at(i).intdata, -1, true, true, world->items.at(i).background);
								}
								else {
									sendMag(currentPeer, world->items.at(i).foreground, xx, yy, world->items.at(i).intdata, 1, true, true, world->items.at(i).background);
								}
							}
						}
						break;
					}
				}
			}
		}
	}
	if (hasmag == true) return -1;
	try {

		bool e = false;
		if (item == 112)
		{
			if (count == 1) world->items[blockX + (blockY * world->width)].yellowGems++;
			if (count == 5) world->items[blockX + (blockY * world->width)].blueGems++;
			if (count == 10) world->items[blockX + (blockY * world->width)].redGems++;
			if (count == 50) world->items[blockX + (blockY * world->width)].greenGems++;
			if (count == 100) world->items[blockX + (blockY * world->width)].purpleGems++;
			vector<int> idstoremove;


			if (world->items[blockX + (blockY * world->width)].yellowGems > 4)
			{
				for (int i = 0; i < world->droppedItems.size(); i++) {
					if (blockX == (int)(world->droppedItems.at(i).x / 32) && blockY == (int)(world->droppedItems.at(i).y / 32)) {
						if (world->droppedItems.at(i).count == 1) {

							RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
							idstoremove.push_back(world->droppedItems.at(i).uid);

						}
					}
				}
				world->items[blockX + (blockY * world->width)].yellowGems = 0;
				world->items[blockX + (blockY * world->width)].blueGems++;
				count = 5;
				e = true;
			}
			if (world->items[blockX + (blockY * world->width)].blueGems > 1) {
				for (int i = 0; i < world->droppedItems.size(); i++) {
					if (blockX == (int)(world->droppedItems.at(i).x / 32) && blockY == (int)(world->droppedItems.at(i).y / 32)) {
						if (world->droppedItems.at(i).count == 5) {

							RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
							idstoremove.push_back(world->droppedItems.at(i).uid);

						}
					}
				}
				world->items[blockX + (blockY * world->width)].blueGems = 0;
				world->items[blockX + (blockY * world->width)].redGems++;
				count = 10;
				e = true;
			}
			if (world->items[blockX + (blockY * world->width)].redGems > 4) {
				for (int i = 0; i < world->droppedItems.size(); i++) {
					if (blockX == (int)(world->droppedItems.at(i).x / 32) && blockY == (int)(world->droppedItems.at(i).y / 32)) {
						if (world->droppedItems.at(i).count == 10) {

							RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
							idstoremove.push_back(world->droppedItems.at(i).uid);

						}
					}
				}
				world->items[blockX + (blockY * world->width)].redGems = 0;
				world->items[blockX + (blockY * world->width)].greenGems++;
				count = 50;
				e = true;
			}
			if (world->items[blockX + (blockY * world->width)].greenGems > 1) {
				for (int i = 0; i < world->droppedItems.size(); i++) {
					if (blockX == (int)(world->droppedItems.at(i).x / 32) && blockY == (int)(world->droppedItems.at(i).y / 32)) {
						if (world->droppedItems.at(i).count == 50) {

							RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
							idstoremove.push_back(world->droppedItems.at(i).uid);

						}
					}
				}
				world->items[blockX + (blockY * world->width)].greenGems = 0;
				world->items[blockX + (blockY * world->width)].purpleGems++;
				count = 100;
				e = true;

			}


			for (int i = 0; i < idstoremove.size(); i++) processTakeServer(world, peer, idstoremove.at(i));


		}
		else {
			vector<int> idstoremove;
			for (int i = 0; i < world->droppedItems.size(); i++) {
				if (blockX == (int)world->droppedItems.at(i).x / 32 && blockY == (int)world->droppedItems.at(i).y / 32) {
					if (world->droppedItems.at(i).count < 200 && world->droppedItems.at(i).id == item && world->droppedItems.at(i).count + count <= 200) {
						count = world->droppedItems.at(i).count + count;
						x = world->droppedItems.at(i).x;
						y = world->droppedItems.at(i).y;
						RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
						idstoremove.push_back(world->droppedItems.at(i).uid);
					}
				}
			}
			for (auto i = 0; i < idstoremove.size(); i++) processTakeServer(world, peer, idstoremove.at(i));
		}
		DroppedItem itemDropped;
		itemDropped.id = item;
		itemDropped.count = count;
		itemDropped.x = x;
		itemDropped.y = y;
		itemDropped.uid = world->droppedCount++;
		world->droppedItems.push_back(itemDropped);
		sendDrop(peer, netID, x, y, item, count, specialEffect);
		return world->droppedCount - 1;
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}

}

int chance_to_get_seed(int item) {
	if (itemDefs.at(item).properties & Property_NoSeed || itemDefs.at(item).properties & Property_Mod || itemDefs.at(item).properties & Property_Dropless || item == 0 || item == 1) {
		return 0;
	}
	else {
		int count = 0;
		int rarity = getItemDef(item).rarity;
		if (rarity == 0) return 0;
		if (rarity < 25) {
			count = (rand() % 80) + 1;
		}
		if (rarity < 40) {
			count = (rand() % 115) + 1;
		}
		else if (rarity < 60) {
			count = (rand() % 130) + 1;
		}
		else if (rarity < 80) {
			count = (rand() % 135) + 1;
		}
		else if (rarity < 100) {
			count = (rand() % 140) + 1;
		}
		else if (rarity >= 100) {
			count = (rand() % 150) + 1;
		}
		return count;
	}
}

void add_gems_object(WorldInfo* world, ENetPeer* peer, int gems, int x, int y)
{
	if (world == NULL) return;
	if (!world) return;
	while (gems != 0)
	{
		if (world->enablecolleciton == false) {
			if (gems >= 100) {
				dropItem(world, peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 100, 0);
				gems -= 100;
			}
			else if (gems >= 50) {
				dropItem(world, peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 50, 0);
				gems -= 50;
			}
			else if (gems >= 10) {
				dropItem(world, peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 10, 0);
				gems -= 10;
			}
			else if (gems >= 5) {
				dropItem(world, peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 5, 0);
				gems -= 5;
			}
			else if (gems >= 1) {
				dropItem(world, peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 1, 0);
				gems -= 1;
			}
		}
		else {
			int hmuch = 0;
			if (gems >= 100) {
				gems -= 100;
				hmuch += 100;
			}
			else if (gems >= 50) {
				gems -= 50;
				hmuch += 50;
			}
			else if (gems >= 10) {
				gems -= 10;
				hmuch += 10;
			}
			else if (gems >= 5) {
				gems -= 5;
				hmuch += 5;
			}
			else if (gems >= 1)
			{
				gems -= 1;
				hmuch += 1;
			}
			if (hmuch > 0) {
				world->magplantGems += hmuch;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
					if (isHere(peer, currentPeer))
						SendThrowEffect(currentPeer, 112, ((PlayerInfo*)(peer->data))->netID, -1, 200, 0, world->magX * 32 + 16, world->magY * 32 + 16);
				}
			}
		}
	}
}
void add_objects_when_breaking_block(ENetPeer* peer, WorldInfo* world, int tile, int x, int y)
{
	if (world == NULL)
		return;
	if (!world)
		return;
	static float seed_chance = 1.0f / 4.0f;
	static float gems_chance = 2.0f / 3.0f;
	float value = static_cast<float>(rand()) / static_cast<float>(RAND_MAX);

	if (value <= gems_chance)
	{
		if (getItemDef(tile).rarity == 999)
			return;

		float max = getItemDef(tile).rarity / 3.954545454545455f;
		int max_gems = static_cast<int>(std::round(max)) * 5;

		if (max_gems == 0)
		{
			if (static_cast<float>(rand()) / static_cast<float>(RAND_MAX) >= max)
				return;
			max_gems = 5;
		}
		add_gems_object(world, peer, rand() % max_gems, x, y);
	}
	else if (value <= gems_chance + seed_chance) {
		if (itemDefs.at(tile).blockType == BlockTypes::SEED || itemDefs.at(tile).properties & Property_NoSeed || itemDefs.at(tile).properties & Property_Mod || itemDefs.at(tile).properties & Property_Dropless) {
		}
		else {
			dropItem(world, peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), tile + 1, 1, 0);
		}
	}
	else {
		for (int i = 0; i < world->droppedItems.size(); i++) {
			if (x == (int)(world->droppedItems.at(i).x / 32) && y == (int)(world->droppedItems.at(i).y / 32)) {
				if (world->droppedItems.at(i).id == tile + 1 || world->droppedItems.at(i).id == tile) {
					return;
				}
			}
		}
		if (itemDefs.at(tile).blockType == BlockTypes::SEED || itemDefs.at(tile).properties & Property_NoSeed || itemDefs.at(tile).properties & Property_Mod || itemDefs.at(tile).properties & Property_Dropless) {
		}
		else {
			dropItem(world, peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), tile, 1, 0);
		}
	}
}
void SendTake(ENetPeer* peer, int netID, int x, int y, int item) {
	ENetPeer* currentPeer;
	for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			data.packetType = 14;
			data.x = x;
			data.y = y;
			data.netID = netID;
			data.plantingTree = item;
			BYTE* raw = packPlayerMoving(&data);
			SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_EVENT_TYPE_RECEIVE);
		}
	}
	sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
}

int HasItemsInInv(ENetPeer* peer, int itemId, int count = -1)
{
	int idx = -1;
	for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
		if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == itemId && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= count) {
			idx = 1;
			break;
		}
	}
	return idx;
}

void doCancelTrade(ENetPeer* peer)
{
	if (((PlayerInfo*)(peer->data))->isTrading) {
		for (auto currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
			if (!((PlayerInfo*)(currentPeer->data))->haveGrowId) continue;
			if (isHere(peer, currentPeer)) {
				if (((PlayerInfo*)(peer->data))->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
					SendCancelTrade(currentPeer, "Trade was cancelled by the other player.");
					SendCancelTrade(peer, "");
					break;
				}
			}
		}
	}
}

void UpdatePlayerSet(ENetPeer* peer, int32_t targetitem) {
	int clothitem = ((PlayerInfo*)(peer->data))->cloth_hand;
	int clothface = ((PlayerInfo*)(peer->data))->cloth_face;
	int clothneck = ((PlayerInfo*)(peer->data))->cloth_necklace;
	int clothshirt = ((PlayerInfo*)(peer->data))->cloth_shirt;
	int clothback = ((PlayerInfo*)(peer->data))->cloth_back;
	int clothances = ((PlayerInfo*)(peer->data))->cloth_ances;
	int clothpants = ((PlayerInfo*)(peer->data))->cloth_pants;
	int clothfeet = ((PlayerInfo*)(peer->data))->cloth_feet;
	int clothhair = ((PlayerInfo*)(peer->data))->cloth_hair;
	int clothmask = ((PlayerInfo*)(peer->data))->cloth_mask;
	int item = targetitem;
	if (clothmask == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_mask = 0;
			sendClothes(peer);
		}
	}
	if (clothitem == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_hand = 0;
			sendClothes(peer);
			sendState(peer);
		}
	}
	if (clothface == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_face = 0;
			sendClothes(peer);
			sendState(peer);
		}
	}

	if (clothneck == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_necklace = 0;
			sendClothes(peer);
		}
	}

	if (clothshirt == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_shirt = 0;
			sendClothes(peer);
		}
	}

	if (clothback == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_back = 0;
			sendClothes(peer);
		}
	}

	if (clothances == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_ances = 0;
			sendClothes(peer);
		}
	}

	if (clothpants == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_pants = 0;
			sendClothes(peer);
		}
	}

	if (clothfeet == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_feet = 0;
			sendClothes(peer);
		}
	}

	if (clothhair == item && item != 0) {
		if (HasItemsInInv(peer, item, 1) == -1) {
			((PlayerInfo*)(peer->data))->cloth_hair = 0;
			sendClothes(peer);
		}
	}
}


void AddItemToInv(WorldInfo* world, ENetPeer* peer, int id, int amount, bool dropable = true)
{
	try {
		int invsize = static_cast<PlayerInfo*>(peer->data)->inventory.inventorySize;
		if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == invsize && CheckItemExists(peer, id) == false)
		{
			Player::OnConsoleMessage(peer, "Inventory is full!");
			return;
		}
		string amm = "";
		int ido = -1;
		for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
			if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == id) {
				ido = i;
				break;
			}
		}
		if (ido != -1) {
			auto total = static_cast<PlayerInfo*>(peer->data)->inventory.items[ido].itemCount + amount;
			if (total > 200) {
				amm = to_string(total - 200);
				static_cast<PlayerInfo*>(peer->data)->inventory.items.at(ido).itemCount = 200;
				int item = id;
				if (item == 6260 || itemDefs.at(item).properties & Property_Untradable || item == 18 || item == 32 || item == 6336 || item == 1794 || item == 1486 || item == 1794 || item == 5640 || item == 1424) {
				}
				else {
					if (dropable) dropItem(world, peer, -1, static_cast<float>(static_cast<PlayerInfo*>(peer->data)->x) + (32 * (static_cast<PlayerInfo*>(peer->data)->isRotatedLeft ? -1 : 1)), static_cast<float>(static_cast<PlayerInfo*>(peer->data)->y), id, total - 200, 0);
				}
			}
			else {
				amm = to_string(amount);
				static_cast<PlayerInfo*>(peer->data)->inventory.items.at(ido).itemCount = total;
			}
		}
		else {
			amm = to_string(amount);
			InventoryItem item;
			item.itemID = id;
			item.itemCount = amount;
			static_cast<PlayerInfo*>(peer->data)->inventory.items.push_back(item);
		}
		sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
		UpdatePlayerSet(peer, id);
		GamePacket p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), ((PlayerInfo*)(peer->data))->cloth_hair, ((PlayerInfo*)(peer->data))->cloth_shirt, ((PlayerInfo*)(peer->data))->cloth_pants), ((PlayerInfo*)(peer->data))->cloth_feet, ((PlayerInfo*)(peer->data))->cloth_face, ((PlayerInfo*)(peer->data))->cloth_hand), ((PlayerInfo*)(peer->data))->cloth_back, ((PlayerInfo*)(peer->data))->cloth_mask, ((PlayerInfo*)(peer->data))->cloth_necklace), ((PlayerInfo*)(peer->data))->skinColor), ((PlayerInfo*)(peer->data))->cloth_ances, 0.0f, 0.0f));
		memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
		ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet3);
		delete p3.data;
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
void DoRegister(ENetPeer* peer) {
	try {
		if (((PlayerInfo*)(peer->data))->haveGrowId) return;
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID||30|\nadd_text_input|password|Password||100|\nadd_text_input|passwordverify|Password Verify||100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email||100|\nend_dialog|register|Cancel|Get My GrowID!|\n"));
		ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
void RemoveItemFromInv(ENetPeer* peer, int itemId, int count, bool update)
{
	try {
		PlayerInventory* inventory = &((PlayerInfo*)(peer->data))->inventory;
		int idx = 0;
		for (auto& a : inventory->items)
		{
			if (a.itemID == itemId)
			{
				int f = a.itemCount;
				f -= count;
				if (f <= 0)
				{
					inventory->items.erase(inventory->items.begin() + idx);
					break;
				}
				else
				{
					a.itemCount = f;
				}
			}
			idx++;
		}
		if (update) {
			sendInventory(peer, *inventory);
			GamePacket p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), ((PlayerInfo*)(peer->data))->cloth_hair, ((PlayerInfo*)(peer->data))->cloth_shirt, ((PlayerInfo*)(peer->data))->cloth_pants), ((PlayerInfo*)(peer->data))->cloth_feet, ((PlayerInfo*)(peer->data))->cloth_face, ((PlayerInfo*)(peer->data))->cloth_hand), ((PlayerInfo*)(peer->data))->cloth_back, ((PlayerInfo*)(peer->data))->cloth_mask, ((PlayerInfo*)(peer->data))->cloth_necklace), ((PlayerInfo*)(peer->data))->skinColor), ((PlayerInfo*)(peer->data))->cloth_ances, 0.0f, 0.0f));
			memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
			ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3);
			delete p3.data;
		} UpdatePlayerSet(peer, itemId);
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}

void processTake(WorldInfo* world, ENetPeer* peer, PlayerMoving* pMov, int itemIdx, float x, float y)
{
	PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
	if (!world) return;
	if (x == 0 || y == 0) return;
	int blockX = (int)x / 32;
	int blockY = (int)y / 32;
	if (blockX<0 || blockY<0 || blockX>world->width || blockY>world->height) return;
	bool legit = true;
	int atik = -1;
	int errcode = 1;
	for (int i = 0; i < world->droppedItems.size(); i++)
	{
		if (world->droppedItems.at(i).uid == itemIdx)
		{
			atik = i;
			break;
		}
	}
	legit = atik != -1;
	if (legit) {
		try {
			if (world->items.at(blockX + (blockY * world->width)).foreground == 1422 || world->items.at(blockX + (blockY * world->width)).foreground == 2488) {
				if (world->isPublic || isWorldAdmin(peer, world) || ((PlayerInfo*)(peer->data))->rawName == world->owner || world->owner == "" || isDev(peer)) {
				}
				else {
					Player::OnConsoleMessage(peer, "Autocollect?!?!");
					return;
				}
			}
			if (pinfo->x / 32 == blockX || pinfo->x / 32 + 1 == blockX || pinfo->x / 32 - 1 == blockX || pinfo->x / 32 + 2 == blockX || pinfo->x / 32 - 2 == blockX) {
				DroppedItem droppedItem = world->droppedItems.at(atik);
				world->droppedItems.erase(world->droppedItems.begin() + atik);
				int did = droppedItem.id;
				if (droppedItem.id != 112) {
					if (getItemDef(droppedItem.id).rarity == 999) {

						Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o.``");
					}
					else {
						Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "``");
					}
					SendTake(peer, pinfo->netID, pMov->x, pinfo->y, itemIdx + 1);
					AddItemToInv(world, peer, droppedItem.id, droppedItem.count);
				}
				else {
					if (droppedItem.count == 1) world->items[blockX + (blockY * world->width)].yellowGems--;
					if (droppedItem.count == 5)  world->items[blockX + (blockY * world->width)].blueGems--;
					if (droppedItem.count == 10)  world->items[blockX + (blockY * world->width)].redGems--;
					if (droppedItem.count == 50)  world->items[blockX + (blockY * world->width)].greenGems--;
					if (droppedItem.count == 100)  world->items[blockX + (blockY * world->width)].purpleGems--;
					((PlayerInfo*)(peer->data))->gems += droppedItem.count;
					SendTake(peer, pinfo->netID, pMov->x, pinfo->y, itemIdx + 1);
				}
			}
		}
		catch (...) {
			return;
		}
	}
}
/*
void sendItemFly(ENetPeer* peer, float fromX, float fromY, float toX, float toY, uint16_t id) {
	PlayerMoving pmov;
	pmov.packetType = 19;
	pmov.netID = -1;
	*(uint8_t*)(&pmov + 3) = 6;
	*(int*)(&pmov + 8) = -1;
	pmov.x = fromX;
	pmov.y = fromY;
	pmov.XSpeed = toX;
	pmov.YSpeed = toY;
	pmov.punchX = id;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);

	uint8_t* packet = new uint8_t[4 + 56];
	memset(packet, 0, 4 + 56);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);

	ENetPacket* epacket = enet_packet_create(packet, 4 + 56, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete packet;
}
*/
void sendDShelf(ENetPeer* peer, int x, int y, int item1, int item2, int item3, int item4)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 8;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 8 + 16;
	uint8_t* packet = new uint8_t[4 + 56 + 8 + 16];
	memset(packet, 0, 4 + 56 + 8 + 16);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 4 + 56) = 3794; // display shelf id
	*(uint16_t*)(packet + 4 + 56 + 6) = 1;
	*(uint8_t*)(packet + 4 + 56 + 8) = 0x2B;
	*(int*)(packet + 4 + 56 + 9 + 0 * 4) = item1;
	*(int*)(packet + 4 + 56 + 9 + 1 * 4) = item2;
	*(int*)(packet + 4 + 56 + 9 + 2 * 4) = item3;
	*(int*)(packet + 4 + 56 + 9 + 3 * 4) = 242;
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 8 + 16, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;
}


string lockTileDatas(int visual, uint32_t owner, uint32_t adminLength, uint32_t* admins, bool isPublic = false, uint8_t bpm = 0) {
	string data;
	data.resize(4 + 2 + 4 + 4 + adminLength * 4 + 8);
	if (bpm) data.resize(data.length() + 4);
	data[2] = 0x01;
	if (isPublic) data[2] |= 0x80;
	else data[2] |= 0x00;
	data[4] = 3;
	data[5] = visual;
	STRINT(data, 6) = owner;

	STRINT(data, 10) = adminLength;
	for (uint32_t i = 0; i < adminLength; i++) {
		STRINT(data, 14 + i * 4) = admins[i];
	}

	if (bpm) {
		STRINT(data, 10)++;
		STRINT(data, 14 + adminLength * 4) = -bpm;
	}
	return data;
}
void sendArrow(ENetPeer* peer, uint16_t itemid, bool droppeditem) {
	PlayerMoving pmov;
	memset(&pmov, 0, sizeof(PlayerMoving));
	*(uint32_t*)(&pmov) = 37 | (droppeditem << 8);
	pmov.netID = itemid;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	uint8_t* packet = new uint8_t[4 + 56];
	memset(packet, 0, 4 + 56);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, sizeof(PlayerMoving));
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;
}
void sendPlayerFishing(ENetPeer* peer, int netID, int x, int y) {
	PlayerMoving p;
	p.packetType = 0x1F;
	p.netID = netID;
	p.punchX = x;
	p.punchY = y;
	SendPacketRaw(4, packPlayerMoving(&p), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}

uint8_t* lockTileData(uint32_t owner, uint32_t adminLength, uint32_t* admins, bool rainbow) {
	uint8_t* data = new uint8_t[4 + 2 + 4 + 4 + adminLength * 4 + 8];
	memset(data, 0, 4 + 2 + 4 + 4 + adminLength * 4 + 8);
	data[2] = 0x1;
	data[4] = 3;
	data[5] = rainbow ? 0x80 : 0x00;
	*(uint32_t*)(data + 6) = owner;

	*(uint32_t*)(data + 10) = adminLength;
	for (uint32_t i = 0; i < adminLength; i++) {
		*(uint32_t*)(data + 14 + i * 4) = admins[i];
	}
	return data;
}
void sendLock(ENetPeer* peer, int x, int y, int lockid, uint32_t owner, uint32_t adminsize, uint32_t* admins, bool rainbow)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 4 + 22 + adminsize * 4;
	uint8_t* packet = new uint8_t[4 + 56 + 4 + 22 + adminsize * 4];
	memset(packet, 0, 4 + 56 + 4 + 22 + adminsize * 4);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 56 + 4) = lockid;
	uint8_t* tiledata = lockTileData(owner, adminsize, admins, rainbow);
	memcpy(packet + 60 + 4, tiledata, 22 + adminsize + 4);
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 4 + 22 + adminsize * 4, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;
	delete tiledata;
}




uint8_t* luckTileData(uint32_t owner, uint32_t adminLength, uint32_t* admins) {
	uint8_t* data = new uint8_t[4 + 2 + 4 + 4 + adminLength * 4 + 8];
	memset(data, 0, 4 + 2 + 4 + 4 + adminLength * 4 + 8);
	data[2] = 0x1;
	data[4] = 3;
	*(uint32_t*)(data + 6) = owner;

	*(uint32_t*)(data + 10) = adminLength;
	for (uint32_t i = 0; i < adminLength; i++) {
		*(uint32_t*)(data + 14 + i * 4) = admins[i];
	}
	return data;
}
void sendLuck(ENetPeer* peer, int x, int y, int lockid, uint32_t owner, uint32_t adminsize, uint32_t* admins)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 4 + 22 + adminsize * 4;
	uint8_t* packet = new uint8_t[4 + 56 + 4 + 22 + adminsize * 4];
	memset(packet, 0, 4 + 56 + 4 + 22 + adminsize * 4);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 56 + 4) = lockid;
	uint8_t* tiledata = luckTileData(owner, adminsize, admins);
	memcpy(packet + 60 + 4, tiledata, 22 + adminsize + 4);
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 4 + 22 + adminsize * 4, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;
	delete tiledata;
}


void sendHMonitor(WorldInfo* world, ENetPeer* peer, int x, int y, std::string name, bool online)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 8;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	int check = 0;
	if (world->items[x + (y * world->width)].flipped) check = 1 | (online ? 96 : 32);
	else check = 1 | (online ? 0x40 : 0);
	int len = 7 + name.length();
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 8 + len;
	uint8_t* packet = new uint8_t[4 + 56 + 8 + len];
	memset(packet, 0, 4 + 56 + 8 + len);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 4 + 56) = 0x4D8; // display shelf id
	*(uint16_t*)(packet + 4 + 56 + 2) = world->items[x + (y * world->width)].background;
	*(uint16_t*)(packet + 4 + 56 + 6) = check;
	*(uint8_t*)(packet + 4 + 56 + 8) = 0x0B;
	*(uint16_t*)(packet + 4 + 56 + 13) = name.length();
	memcpy(packet + 4 + 56 + 15, name.data(), name.length());
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 8 + len, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete[] packet;
}

void SendParticleEffect(ENetPeer* peer, int x, int y, int size, int id, int delay)
{
	PlayerMoving datx;
	datx.packetType = 0x11;
	datx.x = x;
	datx.y = y;
	datx.plantingTree = delay;
	BYTE* raw = packPlayerMoving(&datx);
	int var = PunchEffect(peer);
	float p3 = size;
	float p4 = id;
	memcpy(raw + 32, &p3, 4);
	memcpy(raw + 36, &p4, 4);
	SendPacketRaw(4, raw, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	/*NO WE DONT EVEN NEEDED IT CUS SENDPACKETRAW HAS DELETE the bytes already*///delete[] raw; // memory leak fix
}
/*
172
5
0
0

0
0
65
0

2
0
0
255
255
255
255

172
5
0
0
0
0
1
0
2
0
0
255
255
255
255
*/


void SendCanvasData(ENetPeer* peer, short fg, short bg, int x, int y, int item, string text) {

	byte* ExtendedData = new byte[15 + item + text.length()];
	int state = 0x0010000;
	int extendedLen = 15 + item + text.length();
	int TextLen = text.length();

	PlayerMoving pmov;
	pmov.packetType = 0x5;
	pmov.characterState = 0x8;
	pmov.punchX = x;
	pmov.punchY = y;

	byte* raw = new byte[56 + 15 + item + TextLen];
	memcpy(raw, packPlayerMoving(&pmov), 56);
	memcpy(raw + 52, &extendedLen, 4);

	memcpy(ExtendedData, &fg, 2);
	memcpy(ExtendedData + 2, &bg, 2);
	memcpy(ExtendedData + 4, &state, 4);
	ExtendedData[8] = 0x23;
	memcpy(ExtendedData + 9, &item, 4);
	memcpy(ExtendedData + 13, &TextLen, 2);
	memcpy(ExtendedData + 15, text.data(), TextLen);

	memcpy(raw + 56, ExtendedData, extendedLen);

	SendPacketRaw3(4, raw, 56 + 15 + item + TextLen, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	delete[] ExtendedData; // fix memleak by playingo

}
void treeModify(ENetPeer* peer, int x, int y, int causedBy) {

	PlayerMoving data_;
	data_.packetType = 0xC;
	data_.x = 0;
	data_.y = 0;
	data_.punchX = x;
	data_.punchY = y;
	data_.netID = causedBy;
	data_.plantingTree = 0;
	BYTE* raw = packPlayerMoving(&data_);
	raw[8] = 0xff; raw[9] = 0xff; raw[10] = 0xff; raw[11] = 0xff;
	SendPacketRaw(4, raw, 102, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}


void SendRainbowShitData(ENetPeer* peer, short fg, short bg, int x, int y, bool rainbow) {

	byte* ExtendedData = new byte[26];
	int state = 0x0010000;
	int extendedLen = 26;

	PlayerMoving pmov;
	pmov.packetType = 0x5;
	pmov.characterState = 0x8;
	pmov.punchX = x;
	pmov.punchY = y;

	int NetID = ((PlayerInfo*)(peer->data))->userID;

	byte* raw = new byte[56 + 26];
	memcpy(raw, packPlayerMoving(&pmov), 56);
	memcpy(raw + 52, &extendedLen, 4);

	memcpy(ExtendedData, &fg, 2);
	memcpy(ExtendedData + 2, &bg, 2);
	memcpy(ExtendedData + 4, &state, 4);
	ExtendedData[8] = 0x3;
	// 64
	//	192
	int flags = 0;

	if (rainbow) {
		flags = 128;
	}
	else {
		flags = 0;
	}

	ExtendedData[9] = flags;
	memcpy(ExtendedData + 10, &NetID, 4);
	//memset(ExtendedData + 11, 0x0, 4);
	ExtendedData[15] = 0;
	ExtendedData[16] = 0;
	ExtendedData[17] = 0;
	ExtendedData[18] = 0;
	ExtendedData[19] = 1;
	ExtendedData[20] = 0;
	ExtendedData[21] = 0;
	ExtendedData[22] = 0;
	ExtendedData[23] = 0;
	ExtendedData[24] = 0;
	ExtendedData[25] = 0;
	ExtendedData[26] = 0;
	memcpy(raw + 56, ExtendedData, extendedLen);

	SendPacketRaw3(4, raw, 56 + 26, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	delete[] ExtendedData; // fix memleak by playingo

}

void displayBlock(ENetPeer* peer, int id, short fg, short bg, int x, int y) {


	byte* all = new byte[9 + std::to_string(id).length()];
	int state = 0x0010000;
	int length = std::to_string(id).length();
	int alllength = 9 + std::to_string(id).length();
	int type = 23;
	PlayerMoving pmov;
	pmov.characterState = 0x8;
	pmov.packetType = 0x5;
	pmov.punchX = x;
	pmov.punchY = y;
	byte* raw = new byte[alllength + 56];

	memcpy(raw, packPlayerMoving(&pmov), 52);
	memcpy(raw + 52, &length, 2);
	memcpy(all, &fg, 2);
	memcpy(all + 2, &bg, 2);
	memcpy(all + 4, &state, 4);
	all[8] = type;
	memcpy(all + 9, &length, 4);
	memcpy(all + 11, &id, length);
	memset(all + 11 + length, 0xFF, 2);
	delete[] all; // fix mem leak by playingo
	SendPacketRaw3(4, raw, 56 + alllength, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	/*
		130
		11
		0

		0
		0

		0
		1
		0
		23
		238
		3
		0
		0*/
}
void sendSign2(ENetPeer* peer, string text, short fg, short bg, int x, int y) {

	byte* all = new byte[15 + text.length()];
	int defaultstate = 0x0010000;
	int textlength = text.length();
	int alllength = text.length() + 15;
	int type = 2;
	PlayerMoving pmov;
	pmov.characterState = 0x8;
	pmov.packetType = 0x5;
	pmov.punchX = x;
	pmov.punchY = y;

	byte* raw = new byte[alllength + 56];

	memcpy(raw, packPlayerMoving(&pmov), 52);
	memcpy(raw + 52, &textlength, 2);
	memcpy(all, &fg, 2); // Foreground
	memcpy(all + 2, &bg, 2); // Backgrou8nd
	memcpy(all + 4, &defaultstate, 4); // state
	all[8] = type;
	memcpy(all + 9, &textlength, 2);

	memcpy(all + 11, text.data(), textlength);
	memset(all + 11 + textlength, 0xFF, 4);

	memcpy(raw + 56, all, alllength);
	delete[] all; // fix memleak by playingo
	SendPacketRaw3(4, raw, 56 + alllength, 0, peer, ENET_PACKET_FLAG_RELIABLE);




}




void setupFport(BYTE* raw) {
	raw[0] = 5;
	raw[1] = 0;
	raw[2] = 0;
	raw[3] = 0;
	raw[4] = 0;
	raw[5] = 0;
	raw[6] = 0;
	raw[7] = 0;
	raw[8] = 0;
	raw[9] = 0;
	raw[10] = 0;
	raw[11] = 2048;
	raw[12] = 8;
	raw[13] = 0;
	raw[14] = 0;
	raw[15] = 0;
	raw[16] = 0;
	raw[17] = 0;
	raw[18] = 0;
	raw[19] = 0;
	raw[20] = 0;
	raw[21] = 0;
	raw[22] = 0;
	raw[23] = 0;
	raw[24] = 0;
	raw[25] = 0;
	raw[26] = 0;
	raw[27] = 0;
	raw[28] = 0;
	raw[29] = 0;
	raw[30] = 0;
	raw[31] = 0;
	raw[32] = 0;
	raw[33] = 0;
	raw[34] = 0;
	raw[35] = 0;
	raw[36] = 0;
	raw[37] = 0;
	raw[38] = 0;
	raw[39] = 0;
	raw[40] = 0;
	raw[41] = 0;
	raw[42] = 0;
	raw[43] = 14592;
	raw[44] = 57;
	raw[45] = 0;
	raw[46] = 0;
	raw[47] = 5632;
	raw[48] = 22;
	raw[49] = 0;
	raw[50] = 0;
	raw[51] = 13824;
	raw[52] = 54;
	raw[53] = 0;
	raw[54] = 0;
	raw[55] = 47616;
	raw[56] = 3002;
	raw[57] = 48139;
	raw[58] = 3004;
	raw[59] = 11;
	raw[60] = 0;
	raw[61] = 256;
	raw[62] = 1;
	raw[63] = 6400;
	raw[64] = 4121;
	raw[65] = 2576;
	raw[66] = 10;
	raw[67] = 0;
	raw[68] = 0;
	raw[69] = 56832;
	raw[70] = 3038;
	raw[71] = 11;
	raw[72] = 0;
	raw[73] = 1024;
	raw[74] = 4;
	raw[75] = 0;
	raw[76] = 0;
	raw[77] = 47104;
	raw[78] = 3000;
	raw[79] = 11;
	raw[80] = 0;
	raw[81] = 1536;
	raw[82] = 6;
	raw[83] = 0;
	raw[84] = 0;
	raw[85] = 55808;
	raw[86] = 3034;
	raw[87] = 11;
	raw[88] = 0;
	raw[89] = 1536;
	raw[90] = 6;
	raw[91] = 0;
	raw[92] = 0;
	raw[93] = 56832;
	raw[94] = 3038;
	raw[95] = 11;
	raw[96] = 0;
	raw[97] = 1792;
	raw[98] = 7;
	raw[99] = 0;
	raw[100] = 0;
	raw[101] = 56832;
	raw[102] = 3038;
	raw[103] = 11;
	raw[104] = 0;
	raw[105] = 512;
	raw[106] = 2;
	raw[107] = 0;
	raw[108] = 0;
	raw[109] = 57344;
	raw[110] = 224;
	raw[111] = 21248;
	raw[112] = 83;
	raw[113] = 0;
	raw[114] = 0;
}
void Fport(ENetPeer* peer, int x, int y, int fg, int bg, int f1, int lb1, int f2, int lb2, int f3, int lb3, int f4, int lb4, int f5, int lb5) {
	if (f1 == 0) { f1 = 6156; lb1 = 0; }
	if (f2 == 0) { f2 = 6156; lb2 = 0; }
	if (f3 == 0) { f3 = 6156; lb3 = 0; }
	if (f4 == 0) { f4 = 6156; lb4 = 0; }
	if (f5 == 0) { f5 = 6156; lb5 = 0; }
	int plength = 75 + (5 * 8), lb = 60;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	setupFport(raw);
	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &fg, sizeof(short));
	memcpy(raw + 58, &bg, sizeof(short));
	memcpy(raw + 70, &f1, sizeof(short));
	memcpy(raw + 74, &lb1, sizeof(short));
	memcpy(raw + 78, &f1, sizeof(short));
	memcpy(raw + 82, &lb2, sizeof(short));
	memcpy(raw + 86, &f3, sizeof(short));
	memcpy(raw + 90, &lb3, sizeof(short));
	memcpy(raw + 94, &f4, sizeof(short));
	memcpy(raw + 98, &lb4, sizeof(short));
	memcpy(raw + 102, &f5, sizeof(short));
	memcpy(raw + 106, &lb5, sizeof(short));
	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);
	enet_peer_send(peer, 0, p);
	delete[] raw;
}
void UpdatePort(ENetPeer* peer, int x, int y, int fg, int bg, string data) {
	int f1 = -1, f2 = -1, f3 = -1, f4 = -1, f5 = -1, lb1 = 0, lb2 = 0, lb3 = 0, lb4 = 0, lb5 = 0;
	const auto p = explode(",", data);
	for (auto& a : p) {
		if (a.length() == 0 || a == "") continue;
		else {
			const auto xd = explode("|", a);
			if (f1 == -1) { f1 = stoi(xd.at(0)); lb1 = stoi(xd.at(1)); }
			else if (f2 == -1) { f2 = stoi(xd.at(0)); lb2 = stoi(xd.at(1)); }
			else if (f3 == -1) { f3 = stoi(xd.at(0)); lb3 = stoi(xd.at(1)); }
			else if (f4 == -1) { f4 = stoi(xd.at(0)); lb4 = stoi(xd.at(1)); }
			else if (f5 == -1) { f5 = stoi(xd.at(0)); lb5 = stoi(xd.at(1)); }
		}
	}
	if (f1 == -1) f1 = 0; if (f2 == -1) f2 = 0; if (f3 == -1) f3 = 0; if (f4 == -1) f4 = 0; if (f5 == -1) f5 = 0;
	Fport(peer, x, y, fg, bg, f1, lb1, f2, lb2, f3, lb3, f4, lb4, f5, lb5);
}
bool isValidFish(ENetPeer* peer, int item) {
	if (item == 3000 || item == 3024 || item == 3026 || item == 3030 || item == 3032 || item == 3034 || item == 3036 || item == 3038 || item == 3092 || item == 3094 || item == 3096 || item == 3220 || item == 3222 || item == 3224 || item == 3226 || item == 3434 || item == 3436 || item == 3438 || item == 3440 || item == 3450 || item == 3452 || item == 3454 || item == 3456 || item == 3458 || item == 3460 || item == 3544 || item == 3550 || item == 3620 || item == 3746 || item == 3814 || item == 3820 || item == 4958 || item == 5100 || item == 5448 || item == 5450 || item == 5538 || item == 5542 || item == 5548 || item == 5552 || item == 5574 || item == 5580 || item == 7472 || item == 7744 || item == 8460 || item == 10264) return true;
	else {
		GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`wErr, that's not a fish."), 1));
		ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet2);
		delete p2.data;
		return false;
	}
}
int sendClearArrayData(ENetPeer* peer, int x, int y, int fg, int bg, int brokentile, WorldInfo* world) {
	PlayerInfo* pinfo = (PlayerInfo*)peer->data;
	bool ___ = false;
	if (world->items.at(x + (y * world->width)).foreground == 3402 || world->items.at(x + (y * world->width)).foreground == 392 || world->items.at(x + (y * world->width)).foreground == 9350) {
		vector<int> list{ 362, 3398, 386, 4422, 364, 9340, 9342, 9332, 9334, 9336, 9338, 366, 2388, 7808, 7810, 4416, 7818, 7820, 5652, 7822, 7824, 5644, 390, 7826, 7830, 9324, 5658, 3396, 2384, 5660, 3400, 4418, 4412, 388, 3408, 1470, 3404, 3406, 2390, 5656, 5648, 2396, 384, 5664, 4424, 4400, 1458, 10660, 10654, 10632, 10652, 10626, 10640, 10662 };
		int itemid = list[rand() % list.size()];
		if (itemid == 1458) {
			int target = 5;
			if (world->items.at(x + (y * world->width)).foreground == 9350) target = 20;
			if ((rand() % 1000) <= target) {}
			else itemid = 7808;
		}

		dropItem(world, peer, -1, x * 32 + rand() % 18, y * 32 + rand() % 18, itemid, 1, 0);
	}
	if (itemDefs.at(brokentile).properties & Property_AutoPickup) {
		if (CheckItemMaxed(peer, brokentile, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, brokentile) && CheckItemMaxed(peer, brokentile, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, brokentile)) {
			Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI better not break that, i have no room to pick it up!", 1);
			return -1;
		}
		___ = true;
	}
	if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::DONATION) {
		auto squaresign = x + (y * world->width);
		auto isdbox = std::experimental::filesystem::exists("donationboxes/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
		if (isdbox) {
			ifstream ifff("donationboxes/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
			json j;
			ifff >> j;
			ifff.close();
			if (j["donated"] > 0) {
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Empty the machine before breaking it!", 0);
				return -1;
			}
			remove(("donationboxes/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json").c_str());
		}
	}
	if (itemDefs.at(brokentile).blockType == BlockTypes::VENDING) {
		if (world->items.at(x + (y * world->width)).growtime != 0 || world->items.at(x + (y * world->width)).fruitcount != 0) {
			Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Empty the machine before breaking it!", 0);
			return -1;
		}
		bool kek = false;
		if (world->items.at(x + (y * world->width)).intdata != 0) world->items.at(x + (y * world->width)).intdata = 0;
		if (world->items.at(x + (y * world->width)).growtime != 0) world->items.at(x + (y * world->width)).growtime = 0;
		if (world->items.at(x + (y * world->width)).fruitcount != 0) world->items.at(x + (y * world->width)).fruitcount = 0;
		if (world->items.at(x + (y * world->width)).vdraw != 0) world->items.at(x + (y * world->width)).vdraw = 0;
		if (world->items.at(x + (y * world->width)).opened) {
			world->items.at(x + (y * world->width)).opened = false;
			kek = true;
		}
		if (world->items.at(x + (y * world->width)).rm) {
			world->items.at(x + (y * world->width)).rm = false;
			kek = true;
		}
		if (kek) SaveBlockState(world, peer, x, y);
	}
	if (getItemDef(brokentile).blockType == BlockTypes::LOCK && brokentile != 202 && brokentile != 204 && brokentile != 206 && brokentile != 4994) {
		string lol99 = "", lol999 = "";
		if (((PlayerInfo*)(peer->data))->adminLevel == 0)
		{
			lol99 += ((PlayerInfo*)(peer->data))->displayName = ((PlayerInfo*)(peer->data))->tankIDName;
			((PlayerInfo*)(peer->data))->displayName = ((PlayerInfo*)(peer->data))->tankIDName;
		}
		else { lol99 += ((PlayerInfo*)(peer->data))->displayName; }
		Player::OnNameChanged(peer, ((PlayerInfo*)(peer->data))->netID, lol99);
		((PlayerInfo*)(peer->data))->worldsowned.erase(std::remove(((PlayerInfo*)(peer->data))->worldsowned.begin(), ((PlayerInfo*)(peer->data))->worldsowned.end(), world->name), ((PlayerInfo*)(peer->data))->worldsowned.end());
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				if (((PlayerInfo*)(currentPeer->data))->adminLevel == 0)
				{
					if ((find(world->accessworld.begin(), world->accessworld.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != world->accessworld.end())) {
						lol999 += ((PlayerInfo*)(currentPeer->data))->displayName = ((PlayerInfo*)(currentPeer->data))->tankIDName;
						((PlayerInfo*)(currentPeer->data))->displayName = ((PlayerInfo*)(currentPeer->data))->tankIDName;
						Player::OnNameChanged(currentPeer, ((PlayerInfo*)(currentPeer->data))->netID, lol999);
					}
				}
				Player::OnConsoleMessage(currentPeer, "`w" + ((PlayerInfo*)(peer->data))->currentWorld + " `ohas had it's lock `oremoved.");

			}
		}
		world->owner = "";
		world->ownerID = 0;
		world->isPublic = false;
		world->ownerDisplayName = "";
		world->accessworld.clear();
	}
	if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::SUCKER) {
		if (world->items.at(x + (y * world->width)).intdata != 0 && world->items.at(x + (y * world->width)).fruitcount != 0) {
			if (world->items.at(x + (y * world->width)).fruitcount == 0) {
				if (world->items.at(x + (y * world->width)).fruitcount != 0) world->items.at(x + (y * world->width)).fruitcount = 0;
				if (world->items.at(x + (y * world->width)).intdata != 0) world->items.at(x + (y * world->width)).intdata = 0;
				if (world->items.at(x + (y * world->width)).rm) {
					world->items.at(x + (y * world->width)).rm = false;
					SaveBlockState(world, peer, x, y);
				}
			}
			else {
				Player::OnConsoleMessage(peer, "`oCan't destroy the magplant, it still contains `$" + std::to_string(world->items.at(x + (y * world->width)).fruitcount) + " ``left.``");
				return -1;
			}
		}
		else {
			if (world->items.at(x + (y * world->width)).fruitcount != 0) world->items.at(x + (y * world->width)).fruitcount = 0;
			if (world->items.at(x + (y * world->width)).intdata != 0) world->items.at(x + (y * world->width)).intdata = 0;
			if (world->items.at(x + (y * world->width)).rm) {
				world->items.at(x + (y * world->width)).rm = false;
				SaveBlockState(world, peer, x, y);
			}
		}
	}
	if (getItemDef(brokentile).blockType == BlockTypes::DOOR || getItemDef(brokentile).blockType == BlockTypes::PORTAL) {
		if (world->items.at(x + (y * world->width)).destWorld != "") world->items.at(x + (y * world->width)).destWorld = "";
		if (world->items.at(x + (y * world->width)).destId != "") world->items.at(x + (y * world->width)).destId = "";
		if (world->items.at(x + (y * world->width)).currId != "") world->items.at(x + (y * world->width)).currId = "";
		if (world->items.at(x + (y * world->width)).sign != "") world->items.at(x + (y * world->width)).sign = "";
		if (world->items.at(x + (y * world->width)).opened) {
			world->items.at(x + (y * world->width)).opened = false;
			SaveBlockState(world, peer, x, y);
		}
	}
	if (brokentile == 6016) {
		bool kek = false;
		if (world->items.at(x + (y * world->width)).rm) {
			world->items.at(x + (y * world->width)).rm = false;
			kek = true;
		}
		if (world->items.at(x + (y * world->width)).opened) {
			world->items.at(x + (y * world->width)).opened = false;
			kek = true;
		}
		Player::OnConsoleMessage(peer, "`oCollected `w1 " + getItemDef(brokentile).name + ".");
		if (kek) SaveBlockState(world, peer, x, y);
	}
	if (brokentile == 3798) {
		if (world->items[x + (y * world->width)].rm) {
			world->items[x + (y * world->width)].rm = false;
			world->viplist.clear();
			SaveBlockState(world, peer, x, y);
		}
	}
	if (getItemDef(brokentile).blockType == BlockTypes::MAILBOX) {
		auto squaresign = x + (y * world->width);
		auto isdbox = std::experimental::filesystem::exists("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
		if (isdbox) {
			remove(("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json").c_str());
		}
	}
	if (itemDefs.at(brokentile).blockType == BlockTypes::Mannequin || brokentile == 3394 || brokentile == 1240 || brokentile == 3818 || brokentile == 3002 || brokentile == 3528 || brokentile == 3794 || getItemDef(brokentile).blockType == BlockTypes::SIGN) {
		if (world->items.at(x + (y * world->width)).sign != "") world->items.at(x + (y * world->width)).sign = "";
	}
	if (getItemDef(brokentile).blockType == BlockTypes::RANDOM_BLOCK || getItemDef(brokentile).blockType == BlockTypes::Painting_Easel || brokentile == 2946) {
		if (world->items.at(x + (y * world->width)).intdata != 0) world->items.at(x + (y * world->width)).intdata = 0;
	}
	if (getItemDef(brokentile).blockType == BlockTypes::TOGGLE_FOREGROUND || getItemDef(brokentile).blockType == BlockTypes::CHEST || getItemDef(brokentile).blockType == BlockTypes::SWITCH_BLOCK) {
		if (world->items.at(x + (y * world->width)).activated) {
			world->items.at(x + (y * world->width)).activated = false;
			SaveBlockState(world, peer, x, y);
		}
	}
	if (itemDefs.at(brokentile).properties & Property_MultiFacing) {
		if (world->items.at(x + (y * world->width)).flipped) {
			world->items.at(x + (y * world->width)).flipped = false;
			SaveBlockState(world, peer, x, y);
		}
	}
	if (getItemDef(brokentile).blockType == BlockTypes::GATEWAY) {
		if (world->items.at(x + (y * world->width)).entrance_open) {
			world->items.at(x + (y * world->width)).entrance_open = false;
			SaveBlockState(world, peer, x, y);
		}
	}
	if (brokentile == 410 || brokentile == 1832 || brokentile == 1770) {
		int x1 = 0;
		int y1 = 0;
		for (int i = 0; i < world->width * world->height; i++)
		{
			if (world->items.at(i).foreground == 6) {
				x1 = (i % world->width) * 32;
				y1 = (i / world->width) * 32;
				break;
			}
		}
		ENetPeer* currentPeer;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				if (((PlayerInfo*)(currentPeer->data))->respawnX != 0 && ((PlayerInfo*)(currentPeer->data))->respawnY != 0) {
					if (((PlayerInfo*)(currentPeer->data))->respawnX / 32 == x && ((PlayerInfo*)(currentPeer->data))->respawnY / 32 == y) {
						((PlayerInfo*)(currentPeer->data))->respawnX = x1;
						((PlayerInfo*)(currentPeer->data))->respawnY = y1;
						Player::SetRespawnPos(currentPeer, x1 / 32, (world->width * (y1 / 32)), ((PlayerInfo*)(currentPeer->data))->netID);
					}
				}
			}
		}
	}
	add_objects_when_breaking_block(peer, world, fg, x, y);
	world->items.at(x + (y * world->width)).foreground = 0;
	if (getItemDef(fg).rarity != 999 && getItemDef(bg).rarity != 999) {

		if (((PlayerInfo*)(peer->data))->xptime != 0) {
			int to = ((PlayerInfo*)(peer->data))->xpboost;

			time_t now = time(NULL);
			time_t muted = ((PlayerInfo*)(peer->data))->xptime;

			if (now - muted > to) {
				((PlayerInfo*)(peer->data))->xpboost = 0;
				((PlayerInfo*)(peer->data))->xptime = 0;
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYour `1XP-BOOST`w have been removed please behave better this time", true);
			}
			else {
				string a = "";
				int left = now - muted;
				int start = to - left;
				int n = start;
				int day = n / (24 * 3600);
				n = n % (24 * 3600);
				int hour = n / 3600;
				n %= 3600;
				int minutes = n / 60;
				n %= 60;
				int seconds = n;
				if (hour != 0) {
					a = "`4" + std::to_string(hour) + " `whours, `4" + std::to_string(minutes) + " `wmins, `4" + std::to_string(seconds) + "`w secs.``";
				}
				else {
					a = "`4" + std::to_string(minutes) + " `wmins, `4" + std::to_string(seconds) + "`w secs.``";
				}
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wremaining xp boost: " + a + "", false);
				((PlayerInfo*)(peer->data))->xp = ((PlayerInfo*)(peer->data))->xp + (rand() % 10);
			}
		}
		else ((PlayerInfo*)(peer->data))->xp++;
		if (((PlayerInfo*)(peer->data))->xp >= GetMaxExpForNextLevel(((PlayerInfo*)(peer->data))->level)) {
			int effect = 46;
			int x = ((PlayerInfo*)(peer->data))->x;
			int y = ((PlayerInfo*)(peer->data))->y;
			((PlayerInfo*)(peer->data))->xp = 0;
			((PlayerInfo*)(peer->data))->level = ((PlayerInfo*)(peer->data))->level + 1;
			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
					continue;
				if (isHere(peer, currentPeer)) {
					string name = ((PlayerInfo*)(peer->data))->displayName;
					GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `wis now level " + std::to_string(((PlayerInfo*)(peer->data))->level) + "!"));
					string text = "action|play_sfx\nfile|audio/levelup2.wav\ndelayMS|0\n";
					BYTE* data = new BYTE[5 + text.length()];
					BYTE zero = 0;
					int type = 3;
					memcpy(data, &type, 4);
					memcpy(data + 4, text.c_str(), text.length());
					memcpy(data + 4 + text.length(), &zero, 1);
					ENetPacket* packet = enet_packet_create(p.data,
						p.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet);

					ENetPacket* packet2 = enet_packet_create(data,
						5 + text.length(),
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(currentPeer, 0, packet2);
					GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

					ENetPacket* packetd = enet_packet_create(psp.data,
						psp.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packetd);
					delete psp.data;
					delete[] data;
					delete p.data;

					GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), name + " `wis now level " + std::to_string(((PlayerInfo*)(peer->data))->level) + "!"));
					ENetPacket* packet3 = enet_packet_create(p3.data,
						p3.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet3);
					delete p3.data;
				}
			}
		}
	}




	if (brokentile == 6) {
		int x1 = 0;
		int y1 = 0;
		for (int i = 0; i < world->width * world->height; i++)
		{
			if (world->items.at(i).foreground == 6) {
				x1 = (i % world->width) * 32;
				y1 = (i / world->width) * 32;
				break;
			}
		}
		ENetPeer* currentPeer;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				if (((PlayerInfo*)(currentPeer->data))->respawnX != 0 && ((PlayerInfo*)(currentPeer->data))->respawnY != 0) {
					if (((PlayerInfo*)(currentPeer->data))->respawnX / 32 == x && ((PlayerInfo*)(currentPeer->data))->respawnY / 32 == y) {
						((PlayerInfo*)(currentPeer->data))->respawnX = x1;
						((PlayerInfo*)(currentPeer->data))->respawnY = y1;
						Player::SetRespawnPos(currentPeer, x1 / 32, (world->width * (y1 / 32)), ((PlayerInfo*)(currentPeer->data))->netID);
					}
				}
			}
		}
	}
	if (___) {
		AddItemToInv(world, peer, brokentile, 1);
	}
	return 0;
}


void updateMannequin(WorldInfo* world, ENetPeer* peer, int x, int y, int fg, int bg, std::string sign, int head, int shirt, int pants, int feet, int mask, int hand, int back, int hair, int neck)
{
	try {
		int plength = 95 + sign.size();
		BlockData data;
		data.packetType = 5;
		data.plength = plength;
		data.charState = 8;
		data.x = x;
		data.y = y;
		data.fg = fg;
		data.bg = bg;
		data.visual = 0;
		data.visual2 = 14;
		short shorter = sign.size(), Blocks_State = 33;
		if (!world->items[x + (y * world->width)].flipped) Blocks_State = 1;
		BYTE* raw = makeData(data);

		memcpy(raw + 62, &Blocks_State, 2);
		memcpy(raw + 65, &shorter, 4);
		memcpy(raw + 67, sign.c_str(), sign.size());
		memcpy(raw + 72 + sign.size(), &head, 2);
		memcpy(raw + 74 + sign.size(), &shirt, 2);
		memcpy(raw + 76 + sign.size(), &pants, 2);
		memcpy(raw + 78 + sign.size(), &feet, 2);
		memcpy(raw + 80 + sign.size(), &mask, 2);
		memcpy(raw + 82 + sign.size(), &hand, 2);
		memcpy(raw + 84 + sign.size(), &back, 2);
		memcpy(raw + 86 + sign.size(), &hair, 2);
		memcpy(raw + 88 + sign.size(), &neck, 2);

		SendPacketRaw3(4, raw, data.plength, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}


void sendWorld(ENetPeer* peer, WorldInfo* worldInfo)
{
	try {
		if (!worldInfo) return;

		int zero = 0;
		((PlayerInfo*)(peer->data))->droppeditemcount = worldInfo->droppedCount;
#ifdef TOTAL_LOG
		cout << "Entering a world..." << endl;
#endif
		((PlayerInfo*)(peer->data))->joinClothesUpdated = false;
		string asdf = "0400000004A7379237BB2509E8E0EC04F8720B050000000000000000FBBB0000010000007D920100FDFDFDFD04000000040000000000000000000000070000000000"; // 0400000004A7379237BB2509E8E0EC04F8720B050000000000000000FBBB0000010000007D920100FDFDFDFD04000000040000000000000000000000080000000000000000000000000000000000000000000000000000000000000048133A0500000000BEBB0000070000000000
		string worldName = worldInfo->name;
		int xSize = worldInfo->width;
		int ySize = worldInfo->height;
		int square = xSize * ySize;
		__int16 nameLen = (__int16)worldName.length();
		int payloadLen = asdf.length() / 2;
		int dataLen = payloadLen + 2 + nameLen + 12 + (square * 8) + 4 + 100;
		int offsetData = dataLen - 100;
		int allocMem = payloadLen + 2 + nameLen + 12 + (square * 8) + 4 + 16000 + 100 + (worldInfo->droppedItems.size() * 20);
		BYTE* data = new BYTE[allocMem];
		memset(data, 0, allocMem);
		for (int i = 0; i < asdf.length(); i += 2)
		{
			char x = ch2n(asdf.at(i));
			x = x << 4;
			x += ch2n(asdf[i + 1]);
			memcpy(data + (i / 2), &x, 1);
		}

		__int16 item = 0;
		int smth = 0;
		for (int i = 0; i < square * 8; i += 4) memcpy(data + payloadLen + i + 14 + nameLen, &zero, 4);
		for (int i = 0; i < square * 8; i += 8) memcpy(data + payloadLen + i + 14 + nameLen, &item, 2);
		memcpy(data + payloadLen, &nameLen, 2);
		memcpy(data + payloadLen + 2, worldName.c_str(), nameLen);
		memcpy(data + payloadLen + 2 + nameLen, &xSize, 4);
		memcpy(data + payloadLen + 6 + nameLen, &ySize, 4);
		memcpy(data + payloadLen + 10 + nameLen, &square, 4);
		BYTE* blockPtr = data + payloadLen + 14 + nameLen;

		int sizeofblockstruct = 8;


		for (int i = 0; i < square; i++) {

			int tile = worldInfo->items.at(i).foreground;
			int backg = worldInfo->items.at(i).background;
			sizeofblockstruct = 8;

			if (tile == 6) {
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items.at(i).activated)
					type |= 0x00200000;
				if (worldInfo->items.at(i).entrance_open)
					type |= 8388608;
				if (worldInfo->items.at(i).flipped)
					type |= 0x00400000;
				if (worldInfo->items.at(i).water)
					type |= 0x04000000;
				if (worldInfo->items.at(i).glue)
					type |= 0x08000000;
				if (worldInfo->items.at(i).fire)
					type |= 0x10000000;
				if (worldInfo->items.at(i).red)
					type |= 0x20000000;
				if (worldInfo->items.at(i).green)
					type |= 0x40000000;
				if (worldInfo->items.at(i).blue)
					type |= 0x80000000;
				if (worldInfo->items.at(i).silenced)
					type |= 0x02000000;
				memcpy(blockPtr, &tile, 2);
				memcpy(blockPtr + 4, &type, 4);
				BYTE btype = 1;
				memcpy(blockPtr + 8, &btype, 1);

				string doorText = "EXIT";
				const char* doorTextChars = doorText.c_str();
				short length = (short)doorText.size();
				memcpy(blockPtr + 9, &length, 2);
				memcpy(blockPtr + 11, doorTextChars, length);
				sizeofblockstruct += 4 + length;
				dataLen += 4 + length; // it's already 8.

			}
			else if (worldInfo->items.at(i).foreground == 456) {
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items.at(i).activated)
					type |= 0x00200000;
				if (worldInfo->items.at(i).entrance_open)
					type |= 8388608;
				if (worldInfo->items.at(i).flipped)
					type |= 0x00400000;
				if (worldInfo->items.at(i).water)
					type |= 0x04000000;
				if (worldInfo->items.at(i).glue)
					type |= 0x08000000;
				if (worldInfo->items.at(i).fire)
					type |= 0x10000000;
				if (worldInfo->items.at(i).red)
					type |= 0x20000000;
				if (worldInfo->items.at(i).green)
					type |= 0x40000000;
				if (worldInfo->items.at(i).blue)
					type |= 0x80000000;
				if (worldInfo->items.at(i).silenced)
					type |= 0x02000000;
				memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
				blockPtr[8] = 8;
				memcpy(blockPtr + 4, &type, 4);
				blockPtr[9] = worldInfo->items.at(i).intdata;
				blockPtr += 2; dataLen += 2;
			}
			else if (getItemDef(tile).blockType == BlockTypes::SIGN) {
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items.at(i).activated)
					type |= 0x00200000;
				if (worldInfo->items.at(i).entrance_open)
					type |= 8388608;
				if (worldInfo->items.at(i).flipped)
					type |= 0x00400000;
				if (worldInfo->items.at(i).water)
					type |= 0x04000000;
				if (worldInfo->items.at(i).glue)
					type |= 0x08000000;
				if (worldInfo->items.at(i).fire)
					type |= 0x10000000;
				if (worldInfo->items.at(i).red)
					type |= 0x20000000;
				if (worldInfo->items.at(i).green)
					type |= 0x40000000;
				if (worldInfo->items.at(i).blue)
					type |= 0x80000000;
				if (worldInfo->items.at(i).silenced)
					type |= 0x02000000;
				memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
				memcpy(blockPtr + 4, &type, 4);
				BYTE btype = 2;
				memcpy(blockPtr + 8, &btype, 1);
				string signText = worldInfo->items.at(i).sign;
				const char* signTextChars = signText.c_str();
				short length = (short)signText.size();
				memcpy(blockPtr + 9, &length, 2);
				memcpy(blockPtr + 11, signTextChars, length);
				int minus1 = -1;
				memcpy(blockPtr + 11 + length, &minus1, 4);
				sizeofblockstruct += 3 + length + 4;
				dataLen += 3 + length + 4; // it's already 8.
			}
			else if (tile == 3832)
			{
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items.at(i).activated)
					type |= 0x00200000;
				if (worldInfo->items.at(i).entrance_open)
					type |= 8388608;
				if (worldInfo->items.at(i).flipped)
					type |= 0x00400000;
				if (worldInfo->items.at(i).water)
					type |= 0x04000000;
				if (worldInfo->items.at(i).glue)
					type |= 0x08000000;
				if (worldInfo->items.at(i).fire)
					type |= 0x10000000;
				if (worldInfo->items.at(i).red)
					type |= 0x20000000;
				if (worldInfo->items.at(i).green)
					type |= 0x40000000;
				if (worldInfo->items.at(i).blue)
					type |= 0x80000000;
				if (worldInfo->items.at(i).silenced)
					type |= 0x02000000;

				memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
				memcpy(blockPtr + 4, &type, 4);
				blockPtr[8] = 0x31;
				int lul = worldInfo->stuff_spin | (worldInfo->stuff_spin << 1);
				memcpy(blockPtr + 9, &worldInfo->stuffID, 4);
				memcpy(blockPtr + 13, &worldInfo->stuff_gravity, 4);
				memcpy(blockPtr + 17, &lul, 4);
				sizeofblockstruct += 10;
				dataLen += 10;
			}
			else if (tile == 2946) {
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items.at(i).activated)
					type |= 0x00200000;
				if (worldInfo->items.at(i).entrance_open)
					type |= 8388608;
				if (worldInfo->items.at(i).flipped)
					type |= 0x00400000;
				if (worldInfo->items.at(i).water)
					type |= 0x04000000;
				if (worldInfo->items.at(i).glue)
					type |= 0x08000000;
				if (worldInfo->items.at(i).fire)
					type |= 0x10000000;
				if (worldInfo->items.at(i).red)
					type |= 0x20000000;
				if (worldInfo->items.at(i).green)
					type |= 0x40000000;
				if (worldInfo->items.at(i).blue)
					type |= 0x80000000;
				if (worldInfo->items.at(i).silenced)
					type |= 0x02000000;
				memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
				memcpy(blockPtr + 4, &type, 4);
				BYTE btype = 0x17;
				memcpy(blockPtr + 8, &btype, 1);
				int item = worldInfo->items.at(i).intdata;
				memcpy(blockPtr + 9, &item, 4);
				sizeofblockstruct += 5;
				dataLen += 5;

			}

			else if (tile == 5000) {
				memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items.at(i).activated)
					type |= 0x00200000;
				if (worldInfo->items.at(i).entrance_open)
					type |= 8388608;
				if (worldInfo->items.at(i).flipped)
					type |= 0x00400000;
				if (worldInfo->items.at(i).water)
					type |= 0x04000000;
				if (worldInfo->items.at(i).glue)
					type |= 0x08000000;
				if (worldInfo->items.at(i).fire)
					type |= 0x10000000;
				if (worldInfo->items.at(i).red)
					type |= 0x20000000;
				if (worldInfo->items.at(i).green)
					type |= 0x40000000;
				if (worldInfo->items.at(i).blue)
					type |= 0x80000000;
				if (worldInfo->items.at(i).silenced)
					type |= 0x02000000;
				memcpy(blockPtr + 4, &type, 4);
				BYTE btype = 0x28;
				memcpy(blockPtr + 8, &btype, 1);
				int item = 0;
				int gravity = 0;
				short flags = 0;
				item = worldInfo->bgID;
				memcpy(blockPtr + 9, &item, 4);
				sizeofblockstruct += 5;
				dataLen += 5;
			}
			else if (worldInfo->items.at(i).foreground == 5638 || worldInfo->items.at(i).foreground == 6946 || worldInfo->items.at(i).foreground == 6948) {

				BYTE btype = 0x3E;
				if (blockPtr)
				{
					int type = 0x00000000;

					// type 1 = locked
					if (worldInfo->items.at(i).activated)
						type |= 0x00200000;
					if (worldInfo->items.at(i).entrance_open)
						type |= 8388608;
					if (worldInfo->items.at(i).flipped)
						type |= 0x00400000;
					if (worldInfo->items.at(i).water)
						type |= 0x04000000;
					if (worldInfo->items.at(i).glue)
						type |= 0x08000000;
					if (worldInfo->items.at(i).fire)
						type |= 0x10000000;
					if (worldInfo->items.at(i).red)
						type |= 0x20000000;
					if (worldInfo->items.at(i).green)
						type |= 0x40000000;
					if (worldInfo->items.at(i).blue)
						type |= 0x80000000;
					if (worldInfo->items.at(i).silenced)
						type |= 0x02000000;
					int item = 0;
					int itemCount = 0;
					short magnetEnabled = 0;
					int maxCapacity = 0;
					item = worldInfo->items.at(i).intdata;
					itemCount = 256;
					magnetEnabled = 1;
					maxCapacity = 0;



					memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
					memcpy(blockPtr + 4, &type, 4);
					memcpy(blockPtr + 8, &btype, 1);
					memcpy(blockPtr + 9, &item, 4);
					memcpy(blockPtr + 13, &itemCount, 4);
					memcpy(blockPtr + 17, &magnetEnabled, 2);
					memcpy(blockPtr + 19, &maxCapacity, 4);
				}
				sizeofblockstruct += 15;
				dataLen += 15;
			}
			else if (getItemDef(tile).blockType == BlockTypes::LOCK && tile != 4994 && tile != 202 && tile != 204 && tile != 206)
			{

				if (worldInfo->items.at(i).foreground == 5814)
				{
					// Special Case #1 - Guild Lock
					int type = 0x00000000;

					// type 1 = locked
					if (worldInfo->items.at(i).activated)
						type |= 0x00200000;
					if (worldInfo->items.at(i).entrance_open)
						type |= 8388608;
					if (worldInfo->items.at(i).flipped)
						type |= 0x00400000;
					if (worldInfo->items.at(i).water)
						type |= 0x04000000;
					if (worldInfo->items.at(i).glue)
						type |= 0x08000000;
					if (worldInfo->items.at(i).fire)
						type |= 0x10000000;
					if (worldInfo->items.at(i).red)
						type |= 0x20000000;
					if (worldInfo->items.at(i).green)
						type |= 0x40000000;
					if (worldInfo->items.at(i).blue)
						type |= 0x80000000;
					if (worldInfo->items.at(i).silenced)
						type |= 0x02000000;
					int adminCount = 1;
					auto ownerID = worldInfo->ownerID;// ((PlayerInfo*)peer->data)->userID;
					// int admins[...]
					int szExtra = 10 + adminCount * 4 + 16;
					memset(blockPtr + 8, 0, szExtra);
					BYTE yes = 0x00;
					if (worldInfo->invisible_music == 1) yes = 32;
					BYTE btype = 0x3;
					int o = -worldInfo->bpm;
					memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
					memcpy(blockPtr + 4, &type, 4);
					memcpy(blockPtr + 8, &btype, 1);
					memcpy(blockPtr + 5 + 4, &yes, 1);
					memcpy(blockPtr + 8 + 2, &ownerID, 4);
					memcpy(blockPtr + 8 + 6, &adminCount, 1);
					memcpy(blockPtr + 8 + 10, &o, 4);
					short id1 = 14;
					short id2 = 1;
					memcpy(blockPtr + 8 + 12, &id1, 2);
					memcpy(blockPtr + 8 + 16, &id2, 2);
					sizeofblockstruct += szExtra;
					dataLen += szExtra;
				}
				else
				{
					int type = 0x00000000;

					// type 1 = locked
					if (worldInfo->items.at(i).activated)
						type |= 0x00200000;
					if (worldInfo->items.at(i).entrance_open)
						type |= 8388608;
					if (worldInfo->items.at(i).flipped)
						type |= 0x00400000;
					if (worldInfo->items.at(i).water)
						type |= 0x04000000;
					if (worldInfo->items.at(i).glue)
						type |= 0x08000000;
					if (worldInfo->items.at(i).fire)
						type |= 0x10000000;
					if (worldInfo->items.at(i).red)
						type |= 0x20000000;
					if (worldInfo->items.at(i).green)
						type |= 0x40000000;
					if (worldInfo->items.at(i).blue)
						type |= 0x80000000;
					if (worldInfo->items.at(i).silenced)
						type |= 0x02000000;
					int adminCount = 1;
					int ownerID = worldInfo->ownerID;// ((PlayerInfo*)peer->data)->userID;
					// int admins[...]
					int szExtra = 10 + adminCount * 4;
					memset(blockPtr + 8, 0, szExtra);
					BYTE yes = 0x00;
					if (worldInfo->invisible_music == 1) yes = 32;
					BYTE btype = 0x3;
					int o = -worldInfo->bpm;
					memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
					memcpy(blockPtr + 4, &type, 4);
					memcpy(blockPtr + 8, &btype, 1);
					memcpy(blockPtr + 5 + 4, &yes, 1);
					memcpy(blockPtr + 8 + 2, &ownerID, 4);
					memcpy(blockPtr + 8 + 6, &adminCount, 1);
					memcpy(blockPtr + 8 + 10, &o, 4);
					sizeofblockstruct += szExtra;
					dataLen += szExtra;
				}

			}
			else if (worldInfo->items.at(i).foreground == 1008)
			{
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items.at(i).activated)
					type |= 0x00200000;
				if (worldInfo->items.at(i).entrance_open)
					type |= 8388608;
				if (worldInfo->items.at(i).flipped)
					type |= 0x00400000;
				if (worldInfo->items.at(i).water)
					type |= 0x04000000;
				if (worldInfo->items.at(i).glue)
					type |= 0x08000000;
				if (worldInfo->items.at(i).fire)
					type |= 0x10000000;
				if (worldInfo->items.at(i).red)
					type |= 0x20000000;
				if (worldInfo->items.at(i).green)
					type |= 0x40000000;
				if (worldInfo->items.at(i).blue)
					type |= 0x80000000;
				if (worldInfo->items.at(i).silenced)
					type |= 0x02000000;
				BYTE btype = 9;
				int timeIntoGrowth = 13665;
				memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
				memcpy(blockPtr + 4, &type, 4);
				memcpy(blockPtr + 8, &btype, 1);
				memcpy(blockPtr + 9, &timeIntoGrowth, 4);
				sizeofblockstruct += 5;
				dataLen += 5;
			}



			else if ((getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::FOREGROUND) && !isGFLAGS(worldInfo->items.at(i).foreground) || (worldInfo->items.at(i).foreground == 0) || (worldInfo->items.at(i).foreground == 2) || (worldInfo->items.at(i).foreground == 8) || (worldInfo->items.at(i).foreground == 100) || (worldInfo->items.at(i).foreground == 4) || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::BACKGROUND || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::GATEWAY && worldInfo->items.at(i).foreground != 5818 || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::TOGGLE_FOREGROUND || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::CHEST || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::SWITCH_BLOCK)
			{

				memcpy(blockPtr, &worldInfo->items.at(i).foreground, 2);
				int type = 0;
				// type 1 = locked
				if (worldInfo->items.at(i).activated)
					type |= 0x00400000;
				if (worldInfo->items.at(i).entrance_open)
					type |= 8388608;
				if (worldInfo->items.at(i).flipped)
					type |= 0x00200000;
				if (worldInfo->items.at(i).water)
					type |= 0x04000000;
				if (worldInfo->items.at(i).glue)
					type |= 0x08000000;
				if (worldInfo->items.at(i).fire)
					type |= 0x10000000;
				if (worldInfo->items.at(i).red)
					type |= 0x20000000;
				if (worldInfo->items.at(i).green)
					type |= 0x40000000;
				if (worldInfo->items.at(i).blue)
					type |= 0x80000000;
				if (worldInfo->items.at(i).silenced)
					type |= 0x02000000;

				memcpy(blockPtr + 4, &type, 4);

				// int type = 0x04000000; = water
				// int type = 0x08000000 = glue
				// int type = 0x10000000; = fire
				// int type = 0x20000000; = red color
				// int type = 0x40000000; = green color
				// int type = 0x80000000; = blue color



				/*if (worldInfo->items.at(i).foreground % 2)
				{
					blockPtr += 6;
				}*/
			}
			else
			{
				memcpy(blockPtr, &zero, 2);
			}
			memcpy(blockPtr + 2, &worldInfo->items.at(i).background, 2);
			blockPtr += sizeofblockstruct;

		}

		dataLen += 8;
		if (worldInfo->name == "DEATHMATCH") { // TODO
			worldInfo->droppedCount = 0;
			worldInfo->droppedItems.clear();
			worldInfo->weather = 9;
		}
		int itemcount = worldInfo->droppedItems.size();
		int itemuid = worldInfo->droppedCount;
		memcpy(blockPtr, &itemcount, 4);
		memcpy(blockPtr + 4, &itemuid, 4);
		blockPtr += 8;

		int iteminfosize = 16;
		int itemSize = itemcount * iteminfosize;
		for (int i = 0; i < itemcount; i++)
		{
			int item = worldInfo->droppedItems.at(i).id;
			int count = worldInfo->droppedItems.at(i).count;
			int uid = worldInfo->droppedItems.at(i).uid + 1;
			float x = (float)worldInfo->droppedItems.at(i).x;
			float y = (float)worldInfo->droppedItems.at(i).y;
			memcpy(blockPtr, &item, 2);
			memcpy(blockPtr + 2, &x, 4);
			memcpy(blockPtr + 6, &y, 4);
			memcpy(blockPtr + 10, &count, 2);
			memcpy(blockPtr + 12, &uid, 4);
			blockPtr += iteminfosize;
			dataLen += iteminfosize;
		}
		if (worldInfo->weather == 23)
			worldInfo->weather = 0;
		dataLen += 100;
		blockPtr += 4;
		memcpy(blockPtr, &worldInfo->weather, 4);
		blockPtr += 4;


		offsetData = dataLen - 100;

		//cout << dataLen << " <- dataLen allocMem -> " << allocMem << endl;
		memcpy(data + dataLen - 4, &smth, 4);
		ENetPacket* packet2 = enet_packet_create(data, dataLen, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet2);
		delete[] data;
		//enet_host_flush(server);
		for (int i = 0; i < square; i++) {
			if (isGFLAGS(worldInfo->items.at(i).foreground) || worldInfo->items.at(i).foreground == 5818) {
				worldInfo->items.at(i).foreground = 0x00;
			}
			else if ((getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::FOREGROUND) || worldInfo->items.at(i).foreground == 456 || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::GATEWAY || (worldInfo->items.at(i).foreground == 0) || (getItemDef(worldInfo->items.at(i).foreground).blockType) == BlockTypes::LOCK && worldInfo->items.at(i).foreground != 4994 && worldInfo->items.at(i).foreground != 202 && worldInfo->items.at(i).foreground != 204 && worldInfo->items.at(i).foreground != 206 || worldInfo->items.at(i).foreground == 5638 || worldInfo->items.at(i).foreground == 6946 || worldInfo->items.at(i).foreground == 6948 || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::BACKGROUND || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::CHEST || getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::SWITCH_BLOCK || (getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::TOGGLE_FOREGROUND) || (worldInfo->items.at(i).foreground == 1008) || (worldInfo->items.at(i).foreground == 5000) || (getItemDef(worldInfo->items.at(i).foreground).blockType) == BlockTypes::SIGN || (worldInfo->items.at(i).foreground == 3832) || (worldInfo->items.at(i).foreground == 2946) || (worldInfo->items.at(i).foreground == 6) || (worldInfo->items.at(i).foreground == 242) || (worldInfo->items.at(i).foreground == 1796) || (worldInfo->items.at(i).foreground == 4) || (worldInfo->items.at(i).foreground == 2) || (worldInfo->items.at(i).foreground == 8) || (worldInfo->items.at(i).foreground == 100))
				; // nothing
			else if (worldInfo->items.at(i).foreground == 3528) {
				int xx = i % xSize, yy = i / xSize;
				SendCanvasData(peer, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, xx, yy, worldInfo->items.at(i).intdata, worldInfo->items.at(i).sign);
			}
			else if (worldInfo->items.at(i).foreground == 1240) {
				bool found = false;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
					if (static_cast<PlayerInfo*>(currentPeer->data)->tankIDName == worldInfo->items.at(i).sign) {
						found = true;
						sendHMonitor(worldInfo, peer, i % worldInfo->width, i / worldInfo->width, worldInfo->items.at(i).sign, true);
						break;
					}
				}
				if (!found) sendHMonitor(worldInfo, peer, i % worldInfo->width, i / worldInfo->width, worldInfo->items.at(i).sign, false);
			}
			else if (itemDefs.at(worldInfo->items.at(i).foreground).blockType == BlockTypes::Mannequin) {
				int x = i % xSize, y = i / xSize;
				int squaresign = x + (y * worldInfo->width);
				std::ifstream ifs("mannequin/" + worldInfo->name + "/X" + std::to_string(squaresign) + ".json");
				if (ifs.is_open()) {
					ifstream fs("mannequin/" + worldInfo->name + "/X" + std::to_string(squaresign) + ".json");
					json j;
					fs >> j;
					fs.close();
					updateMannequin(worldInfo, peer, x, y, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, worldInfo->items.at(i).sign, atoi(j["clothHead"].get<string>().c_str()), atoi(j["clothShirt"].get<string>().c_str()), atoi(j["clothPants"].get<string>().c_str()), atoi(j["clothFeet"].get<string>().c_str()), atoi(j["clothMask"].get<string>().c_str()), atoi(j["clothHand"].get<string>().c_str()), atoi(j["clothBack"].get<string>().c_str()), atoi(j["clothHair"].get<string>().c_str()), atoi(j["clothNeck"].get<string>().c_str()));
				}
			}
			else if (worldInfo->items.at(i).foreground == 3394) {
				int x = i % xSize, y = i / xSize;
				CountryFlag(worldInfo, peer, x, y, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, worldInfo->items.at(i).sign);
			}
			else if (worldInfo->items.at(i).foreground == 3798) {
				int x = i % xSize, y = i / xSize;
				if (worldInfo->owner == "" || isWorldOwner(peer, worldInfo) || worldInfo->items[x + (y * worldInfo->width)].rm == true || (find(worldInfo->viplist.begin(), worldInfo->viplist.end(), ((PlayerInfo*)(peer->data))->rawName) != worldInfo->viplist.end())) sendTileData(peer, x, y, 0x10, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, EntranceTiles(0x20, ((PlayerInfo*)(peer->data))->userID));
				else sendTileData(peer, x, y, 0x10, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, EntranceTilesLocked(0x00, ((PlayerInfo*)(peer->data))->userID));
			}
			else if (worldInfo->items.at(i).foreground == 2978 || worldInfo->items.at(i).foreground == 9268) {
				auto islocks = false;
				if (worldInfo->items.at(i).vdraw >= 1) {
					islocks = true;
				}
				if (worldInfo->items.at(i).intdata == 0 && worldInfo->items.at(i).growtime == 0 && worldInfo->items.at(i).fruitcount != 0) {
					UpdateVend(peer, i % worldInfo->width, i / worldInfo->width, 0, islocks, 0, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, worldInfo->items.at(i).opened, worldInfo);
				}
				else if (worldInfo->items.at(i).opened && worldInfo->items.at(i).intdata < worldInfo->items.at(i).growtime) {
					UpdateVend(peer, i % worldInfo->width, i / worldInfo->width, 0, islocks, worldInfo->items.at(i).growtime, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, worldInfo->items.at(i).opened, worldInfo);
				}
				else UpdateVend(peer, i % worldInfo->width, i / worldInfo->width, worldInfo->items.at(i).fruitcount, islocks, worldInfo->items.at(i).growtime, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, worldInfo->items.at(i).opened, worldInfo);
			}
			else if (getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::DISPLAY_SHELF && worldInfo->items.at(i).sign != "")
			{
				const auto xd = explode("|", worldInfo->items.at(i).sign);
				if (worldInfo->items.at(i).sign != "") UpdateDisplayShelf(peer, i % worldInfo->width, i / worldInfo->width, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, stoi(xd.at(0)), stoi(xd.at(1)), stoi(xd.at(2)), stoi(xd.at(3)));
			}
			else if (getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::SEED) {
				int growTimeSeed = getItemDef(worldInfo->items.at(i).foreground - 1).rarity * getItemDef(worldInfo->items.at(i).foreground - 1).rarity * getItemDef(worldInfo->items.at(i).foreground - 1).rarity;
				growTimeSeed += 30 * getItemDef(worldInfo->items.at(i).foreground - 1).rarity;
				if (worldInfo->items.at(i).foreground - 1 == 954) growTimeSeed = 1800;
				if (worldInfo->items.at(i).foreground - 1 == 340) growTimeSeed = 3600;
				if (worldInfo->items.at(i).foreground - 1 == 5666) growTimeSeed = 2700;
				if (worldInfo->items.at(i).foreground - 1 == 4584) growTimeSeed = 2400;
				if (worldInfo->items.at(i).foreground - 1 == 4762) growTimeSeed = 14544;
				if (worldInfo->items.at(i).foreground - 1 == 7382) growTimeSeed = 22544;
				if (worldInfo->items.at(i).foreground - 1 == 9460) growTimeSeed = 29544;
				if (worldInfo->items.at(i).foreground - 1 == 9468) growTimeSeed = 36544;
				if (worldInfo->items.at(i).foreground - 1 == 10024) growTimeSeed = 56544;
				if (worldInfo->items.at(i).foreground - 1 == 10028) growTimeSeed = 86400;
				UpdateTreeVisuals(peer, worldInfo->items.at(i).foreground, i % xSize, i / xSize, worldInfo->items.at(i).background, worldInfo->items.at(i).fruitcount, growTimeSeed - calcBanDuration(worldInfo->items.at(i).growtime), false, 0, worldInfo);
			}
			else if (worldInfo->items.at(i).foreground == 3002 && worldInfo->items.at(i).background == 3004) {
				UpdatePort(peer, i % worldInfo->width, i / worldInfo->width, 3002, 3004, worldInfo->items.at(i).sign);
			}
			else if (getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::DOOR && worldInfo->items.at(i).sign != "")
			{
				string labelForDoor = worldInfo->items.at(i).sign == "" ? (worldInfo->items.at(i).destId == "" ? worldInfo->items.at(i).destWorld : worldInfo->items.at(i).destWorld + "...") : worldInfo->items.at(i).sign;
				if (worldInfo->items.at(i).opened) {
					if (isWorldOwner(peer, worldInfo) || isWorldAdmin(peer, worldInfo) || ((PlayerInfo*)(peer->data))->adminLevel > 1) {
						updateDoor(peer, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, i % worldInfo->width, i / worldInfo->width, labelForDoor);
					}
					else  UpdateUnlockedDoorVisuals(peer, worldInfo->items.at(i).foreground, i % worldInfo->width, i / worldInfo->width, worldInfo->items.at(i).background, "`w<Locked>", true, 0);
				}
				else updateDoor(peer, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, i % worldInfo->width, i / worldInfo->width, labelForDoor);
			}
			else if (getItemDef(worldInfo->items.at(i).foreground).blockType == BlockTypes::PORTAL && worldInfo->items.at(i).sign != "")
			{
				string labelForDoor = worldInfo->items.at(i).sign == "" ? (worldInfo->items.at(i).destId == "" ? worldInfo->items.at(i).destWorld : worldInfo->items.at(i).destWorld + "...") : worldInfo->items.at(i).sign;
				if (worldInfo->items.at(i).opened) {
					if (isWorldOwner(peer, worldInfo) || isWorldAdmin(peer, worldInfo) || ((PlayerInfo*)(peer->data))->adminLevel > 1) {
						updateDoor(peer, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, i % worldInfo->width, i / worldInfo->width, labelForDoor);
					}
					else  UpdateUnlockedDoorVisuals(peer, worldInfo->items.at(i).foreground, i % worldInfo->width, i / worldInfo->width, worldInfo->items.at(i).background, "`w<Locked>", true, 0);
				}
				else updateDoor(peer, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, i % worldInfo->width, i / worldInfo->width, labelForDoor);
			}
			else if (getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::MAILBOX) {
				int x = i % xSize, y = i / xSize;
				auto ismailbox = std::experimental::filesystem::exists("mailbox/_" + worldInfo->name + "/X" + std::to_string(i) + ".json");
				if (ismailbox)
				{
					ifstream ifff("mailbox/_" + worldInfo->name + "/X" + std::to_string(i) + ".json");
					json basic_json;
					ifff >> basic_json;
					ifff.close();
					if (basic_json["inmail"] > 0)
					{
						auto x = i % worldInfo->width;
						auto y = i / worldInfo->width;
						SendDonateData(worldInfo, peer, worldInfo->items[i].foreground, worldInfo->items[i].background, x, y, 65);
					}
					else SendDonateData(worldInfo, peer, worldInfo->items[i].foreground, worldInfo->items[i].background, x, y, 0);
				}
			}
			else if (itemDefs.at(worldInfo->items.at(i).foreground).blockType == BlockTypes::DONATION) {
				int x = i % worldInfo->width; int y = i / worldInfo->width;
				int squaresign = x + (y * worldInfo->width);
				auto isdbox = std::experimental::filesystem::exists("donationboxes/_" + worldInfo->name + "/X" + std::to_string(squaresign) + ".json");
				if (isdbox)
				{
					ifstream ifff("donationboxes/_" + worldInfo->name + "/X" + std::to_string(squaresign) + ".json");
					json basic_json;
					ifff >> basic_json;
					ifff.close();
					if (basic_json["donated"] > 0) {
						SendDonateData2(peer, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, x, y, 65);
					}
					else SendDonateData2(peer, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, x, y, 0);
				}
			}
			else if (worldInfo->items.at(i).foreground == 3798) {
				int x = i % xSize, y = i / xSize;
				if (worldInfo->owner == "" || isWorldOwner(peer, worldInfo) || worldInfo->items[x + (y * worldInfo->width)].rm == true || (find(worldInfo->viplist.begin(), worldInfo->viplist.end(), ((PlayerInfo*)(peer->data))->rawName) != worldInfo->viplist.end())) sendTileData(peer, x, y, 0x10, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, EntranceTiles(0x20, ((PlayerInfo*)(peer->data))->userID));
				else sendTileData(peer, x, y, 0x10, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, EntranceTilesLocked(0x00, ((PlayerInfo*)(peer->data))->userID));
			}
			else if (worldInfo->items[i].foreground == 3818 && worldInfo->items[i].sign != "") {
				auto st = explode("|", worldInfo->items[i].sign);
				int x = i % worldInfo->width; int y = i / worldInfo->width;
				int hair = stoi(st.at(0)), mask = stoi(st.at(1)), face = stoi(st.at(2)), skin = stoi(st.at(3)), emoji = stoi(st.at(5));
				Portrait(peer, x, y, worldInfo->items[i].foreground, worldInfo->items[i].background, mask, hair, face, skin, emoji, st[4], 65536 + getBlockState(worldInfo, x, y));
			}
			else if (worldInfo->items.at(i).foreground == 4802 && worldInfo->rainbows) {

				int xx = i % xSize, yy = i / xSize;
				SendRainbowShitData(peer, worldInfo->items.at(i).foreground, worldInfo->items.at(i).background, xx, yy, true);
			}
			else if (worldInfo->items[i].foreground == 3694) {
				int x = i % xSize, y = i / xSize;
				sendHeatwave(peer, x, y, worldInfo->hw_red, worldInfo->hw_green, worldInfo->hw_blue);
				GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), 28));
				ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet2);
				delete p2.data;
			}
			else
			{
				PlayerMoving data;
				data.packetType = 0x3;
				data.characterState = 0x0;
				data.x = i % worldInfo->width;
				data.y = i / worldInfo->height;
				data.punchX = i % worldInfo->width;
				data.punchY = i / worldInfo->width;
				data.netID = -1;
				data.plantingTree = worldInfo->items.at(i).foreground;
				SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
			}
		}
		string wname = worldInfo->name;
		((PlayerInfo*)(peer->data))->currentWorld = wname;
		if (((PlayerInfo*)(peer->data))->platformID == "0") ADBlocker(peer);
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}

std::vector<int> path_find(WorldInfo* world, int x, int y) {
	std::vector<int> new_tiles{};
	if (world->items.at(x + 1 + (y * world->width)).foreground != 0)
		new_tiles.push_back(x + 1 + (y * world->width));
	if (world->items.at(x - 1 + (y * world->width)).foreground != 0)
		new_tiles.push_back(x - 1 + (y * world->width));
	if (world->items.at(x + (y * world->width + 100)).foreground != 0)
		new_tiles.push_back(x + (y * world->width + 100));
	if (world->items.at(x + (y * world->width - 100)).foreground != 0)
		new_tiles.push_back(x + (y * world->width - 100));
	return new_tiles;
}
void sendPlayerLeave2(ENetPeer* peer, PlayerInfo* player) {
	if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") return;
	doCancelTrade(peer);
	ENetPeer* currentPeer;
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnRemove"), "netID|" + std::to_string(player->netID) + "\n")); // ((PlayerInfo*)(server->peers.at(i).data))->tankIDName
	GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5<`w" + player->displayName + "`` `5left, `w" + std::to_string(getPlayersCountInWorld(player->currentWorld) - 1) + "`` others here>``"));
	GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`5<`w" + ((PlayerInfo*)(peer->data))->displayName + "`` `5left, `w" + std::to_string(getPlayersCountInWorld(player->currentWorld) - 1) + "`` `5others here>```w"));
	ENetPacket* packet4 = enet_packet_create(p4.data, p4.len, ENET_PACKET_FLAG_RELIABLE);
	ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(currentPeer, 0, packet);
			if (((PlayerInfo*)(peer->data))->isInvisible == false)
			{
				Player::PlayAudio(currentPeer, "audio/door_shut.wav", 0);
				enet_peer_send(currentPeer, 0, packet4);
				enet_peer_send(currentPeer, 0, packet2);
			}
		}
	}

	delete p4.data;
	delete p.data;
	delete p2.data;
	((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
	((PlayerInfo*)(peer->data))->x = -1;
	((PlayerInfo*)(peer->data))->y = -1;
	return;
}

void sendPlayerLeave(ENetPeer* peer, PlayerInfo* player) {
	if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") return;
	doCancelTrade(peer);
	if ((getPlayersCountInWorld(player->currentWorld) - 1) == 0) {
		save_world(((PlayerInfo*)(peer->data))->currentWorld, true, true);
	}
	else {
		ENetPeer* currentPeer;
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnRemove"), "netID|" + std::to_string(player->netID) + "\n")); // ((PlayerInfo*)(server->peers.at(i).data))->tankIDName
		GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5<`w" + player->displayName + "`` `5left, `w" + std::to_string(getPlayersCountInWorld(player->currentWorld) - 1) + "`` others here>``"));
		GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`5<`w" + ((PlayerInfo*)(peer->data))->displayName + "`` `5left, `w" + std::to_string(getPlayersCountInWorld(player->currentWorld) - 1) + "`` `5others here>```w"));
		ENetPacket* packet4 = enet_packet_create(p4.data, p4.len, ENET_PACKET_FLAG_RELIABLE);
		ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet);
				if (((PlayerInfo*)(peer->data))->isInvisible == false)
				{
					Player::PlayAudio(currentPeer, "audio/door_shut.wav", 0);
					enet_peer_send(currentPeer, 0, packet4);
					enet_peer_send(currentPeer, 0, packet2);
				}
			}
		}

		delete p4.data;
		delete p.data;
		delete p2.data;
	}
	((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
	((PlayerInfo*)(peer->data))->x = -1;
	((PlayerInfo*)(peer->data))->y = -1;
	return;
}



void joinWorld(ENetPeer* peer, string act, int x2 = 0, int y2 = 0, bool door_ = false) { //TODO DOORS
	try {
		if (not ((PlayerInfo*)(peer->data))->haveGrowId) return;
		if (((PlayerInfo*)(peer->data))->lastJoinReq + 1500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
		{
			((PlayerInfo*)(peer->data))->lastJoinReq = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		}
		else {
			if (not door_) {
				Player::OnTextOverlay(peer, "Oops! an error occured, please try again.");
				Player::OnFailedToEnterWorld(peer);
				((PlayerInfo*)(peer->data))->kipaskiek_turi_kainoti++;
				return;
			}
		}
		WorldInfo info = worldDB.get(act);
		string upsd = act;
		std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);

		int x = 3040;
		int y = 736;

		if (((PlayerInfo*)(peer->data))->isCursed == true) {
			WorldInfo info2 = worldDB.get("HELL");
			sendWorld(peer, &info2);
		}
		else {
			sendWorld(peer, &info);
		}

		if (((PlayerInfo*)(peer->data))->haveGrowId)
		{
			if (((PlayerInfo*)(peer->data))->adminLevel == 0)
			{
				if (((PlayerInfo*)(peer->data))->lName) {}
				else {
					if (isWorldOwner(peer, &info))
					{
						((PlayerInfo*)(peer->data))->displayName = "`2" + ((PlayerInfo*)(peer->data))->tankIDName;
					}
					else if (isWorldAdmin(peer, &info))
					{
						((PlayerInfo*)(peer->data))->displayName = "`^" + ((PlayerInfo*)(peer->data))->tankIDName;
					}
					else
					{
						((PlayerInfo*)(peer->data))->displayName = ((PlayerInfo*)(peer->data))->tankIDName;
					}
				}
			}
		}
		for (int j = 0; j < info.width * info.height; j++)
		{
			if (info.items.at(j).foreground == 6) {
				x = (j % info.width) * 32;
				y = (j / info.width) * 32;
			}
		}
		if (x2 != 0 && y2 != 0)
		{
			x = x2;
			y = y2;
		}
		((PlayerInfo*)(peer->data))->respawnX = x;
		((PlayerInfo*)(peer->data))->respawnY = y;
		int userIDE = ((PlayerInfo*)(peer->data))->userID;

		if (info.isPublic) {
			Player::OnSpawn(peer, cId, 1, x, y,
				((PlayerInfo*)(peer->data))->displayName, ((PlayerInfo*)(peer->data))->country, ((PlayerInfo*)(peer->data))->isInvisible, ((PlayerInfo*)(peer->data))->mstate,
				((PlayerInfo*)(peer->data))->smstate);
		}
		else {
			Player::OnSpawn(peer, cId, userIDE, x, y,
				((PlayerInfo*)(peer->data))->displayName, ((PlayerInfo*)(peer->data))->country, ((PlayerInfo*)(peer->data))->isInvisible, ((PlayerInfo*)(peer->data))->mstate,
				((PlayerInfo*)(peer->data))->smstate);
		}
		((PlayerInfo*)(peer->data))->netID = cId;
		onPeerConnect(peer);
		sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
		cId++;


		if (((PlayerInfo*)(peer->data))->isInvisible == false) {
			GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5<`w" + ((PlayerInfo*)(peer->data))->displayName + " `5entered, `w" + std::to_string(getPlayersCountInWorld(((PlayerInfo*)(peer->data))->currentWorld) - 1) + "`` others here>``"));
			GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`5<`w" + ((PlayerInfo*)(peer->data))->displayName + " `5entered, `w" + std::to_string(getPlayersCountInWorld(((PlayerInfo*)(peer->data))->currentWorld) - 1) + "`` others here>``"));
			ENetPacket* packet4 = enet_packet_create(p4.data, p4.len, ENET_PACKET_FLAG_RELIABLE);
			ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
			string text = "action|play_sfx\nfile|audio/door_open.wav\ndelayMS|0\n";
			BYTE* data = new BYTE[5 + text.length()];
			BYTE zero = 0;
			int type = 3;
			memcpy(data, &type, 4);
			memcpy(data + 4, text.c_str(), text.length());
			memcpy(data + 4 + text.length(), &zero, 1);
			ENetPacket* packet23 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
				if (isHere(peer, currentPeer)) {
					enet_peer_send(currentPeer, 0, packet4);
					enet_peer_send(currentPeer, 0, packet2);
					enet_peer_send(currentPeer, 0, packet23);
				}
			}
			delete[] data;
			delete p4.data;
			delete p2.data;
		}
		Player::OnConsoleMessage(peer, "`oWorld `w" + info.name + "`o entered. There are `w" + to_string(getPlayersCountInWorld(info.name)) + "`o other people here, `w" + GetPlayerCountServer() + " `oonline.");
		if (info.owner != "") {
			if (info.owner == ((PlayerInfo*)(peer->data))->rawName || isWorldAdmin2(peer, info) || adminLevel(peer) > 1) {
				string test = "`5[`w" + info.name + "`$ World Locked`o by " + info.ownerDisplayName + " `o(`2ACCESS GRANTED`o)`5]";
				sendConsoleMsg(peer, test);
			}
			else
			{
				string test = "`5[`w" + info.name + "`$ World Locked`o by " + info.ownerDisplayName + "`5]";
				sendConsoleMsg(peer, test);
			}

		}

	} catch (exception& e) {
		std::cout << e.what() << std::endl;
	} catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}


void DoCancelTransitionAndTeleport(ENetPeer* peer, int x, int y)
{
	Player::SmoothZoom(peer);
	GamePacket p2 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
	memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	SendGamePacket(peer, &p2);
	GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnFailedToEnterWorld"), 1));
	SendGamePacket(peer, &p3);
	GamePacket p4 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x * 32, y * 32));
	memcpy(p4.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	SendGamePacket(peer, &p4);
}

void handle_world(ENetPeer* peer, string act, int x = 0, int y = 0, bool door_ = false) {
	try {
		toUpperCase(act);
		if (not ((PlayerInfo*)(peer->data))->haveGrowId || not ((PlayerInfo*)(peer->data))->registerverify) {
			/*Player::*/DoRegister(peer);
			Player::OnFailedToEnterWorld(peer);
			return;
		}
		if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT" && not door_) {
			Player::OnConsoleMessage(peer, "`4Please wait you will be disconnected..!");
			enet_peer_disconnect_later(peer, 0);
			return;
		}
		if (!std::regex_match(act, std::regex("^[A-Za-z0-9]+$"))) {
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Please use only letters.``"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;

			GamePacket p3 = packetEnd(appendString(appendInt(appendString(createPacket(), "OnFailedToEnterWorld"), 1), "Sorry"));
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3);
			delete p3.data;

			return;
		}
		if (act == "")
		{
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Where are we going?``"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;

			GamePacket p3 = packetEnd(appendString(appendInt(appendString(createPacket(), "OnFailedToEnterWorld"), 1), "Sorry"));
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3);
			delete p3.data;

			return;
		}
		if (act == "")
		{
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Where are we going?``"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;

			GamePacket p3 = packetEnd(appendString(appendInt(appendString(createPacket(), "OnFailedToEnterWorld"), 1), "Sorry"));
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3);
			delete p3.data;

			return;
		}


		if (act == "CON" || act == "EXIT" || act == "NUL" || act == "PRN" || act == "AUX" || act == "CLOCK$" || act == "COM0" || act == "COM1" || act == "COM2" || act == "COM3" || act == "COM4" || act == "COM5" || act == "COM6" || act == "COM7" || act == "COM8" || act == "COM9" || act == "LPT0" || act == "LPT1" || act == "LPT2" || act == "LPT3" || act == "LPT4" || act == "LPT5" || act == "LPT6" || act == "LPT7" || act == "LPT8" || act == "LPT9")
		{
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Maybe try another one?``"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;

			GamePacket p3 = packetEnd(appendString(appendInt(appendString(createPacket(), "OnFailedToEnterWorld"), 1), "Sorry"));
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3);
			delete p3.data;

			return;
		}
		if (act == "DEATHMATCH" && !((PlayerInfo*)(peer->data))->playing) {
			Player::OnConsoleMessage(peer, "Waiting Players..");
			Player::OnFailedToEnterWorld(peer);
			return;
		}
		WorldInfo info = worldDB.get(act);
		auto banned = false;
		for (int i = 0; i < info.wbans.size(); i++) {
			if (info.wbans.at(i).userID == ((PlayerInfo*)(peer->data))->userID)
			{
				if (info.wbans.at(i).bannedAt > GetCurrentTimeInternalSeconds()) {
					banned = true;
					break;
				}
				else {
					info.wbans.erase(info.wbans.begin() + i);
				}
				break;
			}
		}
		if (info.name == "error" || info.name == "ERROR") {
			Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
			Player::OnFailedToEnterWorld(peer);
			return;
		}
		if (banned) {
			Player::OnFailedToEnterWorld(peer);
			Player::OnConsoleMessage(peer, "`4Oh no! ``You've been banned from that world by its owner! Try again later after ban wears off.````");
			return;
		}
		if (info.isNuked)
		{
			if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0) {
				joinWorld(peer, act);
				sendConsoleMsg(peer, "This world is inaccessible by others!");

			}
			else
			{

				GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oThis world is inaccessible.``"));
				ENetPacket* packet = enet_packet_create(p.data,
					p.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet);
				delete p.data;

				GamePacket p3 = packetEnd(appendString(appendInt(appendString(createPacket(), "OnFailedToEnterWorld"), 1), "Sorry"));
				ENetPacket* packet3 = enet_packet_create(p3.data,
					p3.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet3);
				delete p3.data;

				return;
			}
		}

		else {
			if (HasItemsInInv(peer, 5640, 1) != -1) {
				((PlayerInfo*)(peer->data))->magplantitemid = 0;
				RemoveItemFromInv(peer, 5640, 1, true);
			}
			if (HasItemsInInv(peer, 18, 1) == -1) {
				AddItemToInv(&info, peer, 18, 1, false);
			}
			if (HasItemsInInv(peer, 32, 1) == -1) {
				AddItemToInv(&info, peer, 32, 1, false);
			}
			joinWorld(peer, act, x, y, door_);
		}
	}
	catch (exception& e) {
		std::cerr << e.what() << endl;
	}
	catch (const std::out_of_range& e) {
		std::cerr << e.what() << endl;
	}
}


void sendWorldOffers(ENetPeer* peer)
{
	try {
		if (!((PlayerInfo*)(peer->data))->isIn) return;
		//auto worlds = worldDB.getRandomWorlds();
		string worldOffers = "add_filter|\nadd_heading|Top Worlds<ROW2>|";
		string worlds_owned = "";
		worldOffers += "\nadd_floater|START|0|0.8|16764109\n";
		if (worlds.size() > 0) {
			for (auto i = 0; i < worlds.size(); i++)
			{
				if (i >= 15) break;
				if (worlds[i].name == "START" || worlds[i].name == "DEATHMATCH" || worlds[i].name == "EXIT" || worlds[i].isNuked || worlds[i].name.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) continue;
				float size = 0.50;
				size += 0.03 * getPlayersCountInWorld(worlds[i].name);
				if (size > 0.75) size = 0.75;
				worldOffers += "add_floater|" + worlds[i].name + "|" + std::to_string(getPlayersCountInWorld(worlds[i].name)) + "|" + to_string(size) + "|3529161471\n";
			}
		}
		if (((PlayerInfo*)(peer->data))->worldsowned.size() != 0) {
			worlds_owned += "\nadd_heading|My Worlds<CR>|";
			for (int i = 0; i < ((PlayerInfo*)(peer->data))->worldsowned.size(); i++) {
				worlds_owned += "\nadd_floater|" + ((PlayerInfo*)(peer->data))->worldsowned.at(i) + "|0|0.5|2147418367";
			}
		}
		GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), worldOffers + worlds_owned));
		ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet3);
		delete p3.data;
		sendConsoleMsg(peer, "Where would you like to go? (`w" + GetPlayerCountServer() + "`` online)");
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
void DoEnterDoor(ENetPeer* peer, WorldInfo* world, int x, int y)
{
	try {
		int idx = x + world->width * y;
		//// First determine door data
		//if (world->blocks[idx].blockData == NULL)
		//{
		//	// fail
		//	DoCancelTransitionAndTeleport(peer, x, y);
		//}
		//else if (world->blocks[idx].blockData->type != 2)
		//{
		//	// fail
		//	DoCancelTransitionAndTeleport(peer, x, y);
		//}
		//else
		{
			auto exitsnuke = world->isNuked == true;
			WorldItem block = world->items[idx];
			if (block.destWorld == "EXIT")
			{
				// fail
				sendPlayerLeave(peer, ((PlayerInfo*)(peer->data)));
				sendWorldOffers(peer); // this essentially acts just like a Main Door would
			}
			if (((PlayerInfo*)(peer->data))->isCursed == true) {
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wCannot using DOOR Whle CURSED.", false);
				DoCancelTransitionAndTeleport(peer, x, y);
				return;
			}
			if (block.opened)
			{
				if (isWorldOwner(peer, world) || isWorldAdmin(peer, world) || ((PlayerInfo*)(peer->data))->adminLevel > 1) {
				}
				else {
					Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wThe door is locked.", false);
					DoCancelTransitionAndTeleport(peer, x, y);
					return;
				}
			}
			if (exitsnuke)
			{
				if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0) {
					sendConsoleMsg(peer, "This world is inaccessible by others!");
				}
				else
				{

					Player::OnConsoleMessage(peer, "`oThis world is inaccessible.``");
					DoCancelTransitionAndTeleport(peer, x, y);
					return;
				}
			}
			if (block.destWorld == "")
			{
				// it's this world, find a door here
				int x = 0;
				int y = 0;
				for (int i = 0; i < world->width * world->height; i++)
				{
					ItemDefinition def = getItemDef(world->items.at(i).foreground);
					if (def.blockType == BlockTypes::DOOR || def.blockType == BlockTypes::PORTAL) {
						WorldItem blockDest = world->items.at(i);
						if (blockDest.currId == block.destId)
						{
							x = (i % world->width);
							y = (i / world->width);
							DoCancelTransitionAndTeleport(peer, x, y);
							return;
						}
					}
				}
				x = 0;
				y = 0;

				for (int j = 0; j < world->width * world->height; j++)
				{
					if (world->items.at(j).foreground == 6) {
						x = (j % world->width);
						y = (j / world->width);
					}
				}
				DoCancelTransitionAndTeleport(peer, x, y);
			}
			else
			{
				try
				{

					WorldInfo worldDest = worldDB.get(block.destWorld);
					auto banned = false;
					for (int i = 0; i < worldDest.wbans.size(); i++) {
						if (worldDest.wbans.at(i).userID == ((PlayerInfo*)(peer->data))->userID)
						{
							if (worldDest.wbans.at(i).bannedAt > GetCurrentTimeInternalSeconds()) {
								banned = true;
								break;
							}
							else {
								worldDest.wbans.erase(worldDest.wbans.begin() + i);
							}
							break;
						}
					}
					if (banned) {
						Player::OnConsoleMessage(peer, "`4Oh no! ``You've been banned from that world by its owner! Try again later after ban wears off.````");
						DoCancelTransitionAndTeleport(peer, x, y);
						return;
					}
					if (block.destId == "")
					{
						int x_ = 0;
						int y_ = 0;

						for (int j = 0; j < worldDest.width * worldDest.height; j++)
						{
							if (worldDest.items.at(j).foreground == 6) {
								x_ = (j % worldDest.width);
								y_ = (j / worldDest.width);
							}
						}
						if (block.destWorld != ((PlayerInfo*)(peer->data))->currentWorld) sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
						handle_world(peer, block.destWorld, x_ * 32, y_ * 32, true);
						return;
					}
					else
					{
						int x_ = 0;
						int y_ = 0;
						bool found = false;
						for (int i = 0; i < worldDest.width * worldDest.height; i++)
						{
							ItemDefinition def = getItemDef(worldDest.items.at(i).foreground);
							if (def.blockType == BlockTypes::DOOR || def.blockType == BlockTypes::PORTAL) {
								WorldItem blockDest = worldDest.items.at(i);
								if (block.currId == blockDest.destId)
								{
									x_ = (i % world->width);
									y_ = (i / world->width);
									if (block.destWorld != ((PlayerInfo*)(peer->data))->currentWorld) sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
									handle_world(peer, block.destWorld, x_ * 32, y_ * 32, true);
									found = true;
									break;
								}
							}
						}
						if (!found)
						{
							int x = 0;
							int y = 0;

							for (int j = 0; j < worldDest.width * worldDest.height; j++)
							{
								if (worldDest.items.at(j).foreground == 6) {
									x = (j % worldDest.width);
									y = (j / worldDest.width);
								}
							}
							if (block.destWorld != ((PlayerInfo*)(peer->data))->currentWorld) sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
							handle_world(peer, block.destWorld, x * 32, y * 32, true);
						}
					}
				}
				catch (int e) {
					if (e == 1) {
						DoCancelTransitionAndTeleport(peer, x, y);
						Player::OnConsoleMessage(peer, "");
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "You have exited the world.", 0);
					}
					else if (e == 2) {
						DoCancelTransitionAndTeleport(peer, x, y);
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "You have entered bad characters in the world name!", 0);
					}
					else if (e == 3) {
						DoCancelTransitionAndTeleport(peer, x, y);
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Exit from what? Click back if you're done playing.", 0);
					}
					else {
						DoCancelTransitionAndTeleport(peer, x, y);
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "I know this menu is magical and all, but you can't visit this world!", 0);
					}
				}
			}
		}
		GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetFreezeState"), 0));
		memcpy(p5.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
		ENetPacket* packet5 = enet_packet_create(p5.data,
			p5.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet5);
		delete p5.data;

		GamePacket p4 = packetEnd(appendIntx(appendString(createPacket(), "OnFailedToEnterWorld"), 1));
		ENetPacket* packet4 = enet_packet_create(p4.data,
			p4.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet4);
		delete p4.data;
	}
	catch (std::exception& e) {
		std::cout << e.what() << endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}

void sendPuncheffect(ENetPeer* peer, int punch) {
	//return; // TODO
	PlayerInfo* info = ((PlayerInfo*)(peer->data));
	int netID = info->netID;
	ENetPeer* currentPeer;
	int state = getState(info);

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {


			PlayerMoving data;
			data.packetType = 0x14;
			data.characterState = 0; // animation
			data.x = 1000;
			data.y = 100;
			data.punchX = 0;
			data.punchY = 0;
			data.netID = netID;
			data.plantingTree = state;
			BYTE* raw = packPlayerMoving(&data);
			int var = punch; // punch effect
			memcpy(raw + 1, &var, 3);
			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);


		}

	}
	// TODO 
}



void Send_Cancel_Game(ENetPeer* peer)
{
	try {
		if (started) {
			if (player1 == ((PlayerInfo*)(peer->data))->tankIDName || player2 == ((PlayerInfo*)(peer->data))->tankIDName) {
				ENetPeer* currentPeer;
				bool found = false;
				for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
					if (isHere(peer, currentPeer)) {
						if (peer != currentPeer) {
							((PlayerInfo*)(currentPeer->data))->playing = false;
							started = false;
							player1 = "";
							player2 = "";
							reinterpret_cast<PlayerInfo*>(currentPeer->data)->gems += 250;
							sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
							((PlayerInfo*)(currentPeer->data))->currentWorld = "EXIT";
							sendWorldOffers(currentPeer);
							Player::OnTextOverlay(currentPeer, "The game has been canceled!");
						}
					}
				}
				started = false;
				player1 = "";
				player2 = "";
				((PlayerInfo*)(peer->data))->playing = false;
				sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
				((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
				sendWorldOffers(peer);
			}
		}
		else
		{
			if (player1 == ((PlayerInfo*)(peer->data))->tankIDName)
				player1 = "";
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
void sendTileUpdate(WorldInfo* world, int x, int y, int tile, int causedBy, ENetPeer* peer)
{
	int dicenr = 0;
	PlayerMoving data;
	//data.packetType = 0x14;
	data.packetType = 0x3;

	//data.characterState = 0x924; // animation
	data.characterState = 0x0; // animation
	data.x = x;
	data.y = y;
	data.punchX = x;
	data.punchY = y;
	data.netID = causedBy;
	data.plantingTree = tile;
	bool updateState = false;
	bool VendUpdate = false;
	bool isCountry = false;
	bool isLock = false;
	bool isMonitor = false;
	bool isTree = false;
	int netID = ((PlayerInfo*)(peer->data))->netID;
	if (world == nullptr || x < 0 || y < 0 || x > world->width - 1 || y > world->height - 1 || tile > itemDefs.size()) return;
	doCancelTrade(peer);
	if (world->WorldSaved) world->WorldSaved = false;
	try {
		if (itemDefs.at(tile).blockType == BlockTypes::CONSUMABLE) {
			for (int i = 0; i < world->width * world->height; i++) {
				if (world->items.at(i).foreground == 3616 && world->items.at(i).activated) {
					if (world->isPublic || isWorldAdmin(peer, world) || ((PlayerInfo*)(peer->data))->rawName == world->owner || world->owner == "" || isDev(peer)) {
					}
					else {
						Player::OnTalkBubble(peer, netID, "`wYou cant use consumables here!", false);
						return;
					}
				}
			}
		}
		if (tile == 1404) {
			if (world->owner != "" && !isWorldOwner(peer, world) && !isWorldAdmin(peer, world) && !world->isPublic && ((PlayerInfo*)(peer->data))->adminLevel < 1) return;
			if (world->items.at(x + (y * world->width)).foreground != 0 || world->items[x + (y * world->width + world->width)].foreground != 0) {
				Player::OnTextOverlay(peer, "There's no free space for main door");
				return;
			}
			else {
				try {
					for (int i = 0; i < world->width * world->height; i++)
					{
						if (i >= 5400) {
							world->items.at(i).foreground = 8;
						}
						else if (world->items.at(i).foreground == 6) {
							world->items.at(i).foreground = 0;
							world->items[i + 100].foreground = 0;
						}
						else if (world->items.at(i).foreground != 6) {
							world->items.at(x + (y * world->width)).foreground = 6;
							world->items[x + (y * world->width) + 100].foreground = 8;
						}
					}
				}
				catch (const std::out_of_range& e) {
					std::cout << e.what() << std::endl;
				}
				RemoveItemFromInv(peer, 1404, 1, true);
				for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
					if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
					if (isHere(peer, net_peer)) {
						sendPlayerLeave(net_peer, (PlayerInfo*)(net_peer->data));
						handle_world(net_peer, world->name);
						Player::OnTalkBubble(peer, netID, "You have used door mover!", 0);
					}
				}
			}
		}
		if (tile == 1360) {
			vector<int> Dailyb{ 242, 242, 242, 828, 68, 82, 5158, 98, 404, 400, 3402, 3400 };
			const int Index = rand() % Dailyb.size();
			const auto ItemID = Dailyb[Index];
			RemoveItemFromInv(peer, 1360, 1, true);
			Player::OnTalkBubble(peer, netID, "`wYou received " + itemDefs.at(ItemID).name, 0);
			Player::OnConsoleMessage(peer, "`oYou received " + itemDefs.at(ItemID).name);
			bool success = true;
			AddItemToInv(world, peer, ItemID, 1);
			return;
		}
		if (tile == 6204) {
			auto iscontains = false;
			if (HasItemsInInv(peer, 6104, 1) != -1)
				return;
			else {
				RemoveItemFromInv(peer, 6204, 1, true);
				auto kuriPrizaDuot = rand() % 2 + 1;
				if (kuriPrizaDuot == 1) {
					auto gemChance = rand() % 20000;
					((PlayerInfo*)(peer->data))->gems += gemChance;
					GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems));
					ENetPacket* packetpp = enet_packet_create(pp.data, pp.len, ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packetpp);
					delete pp.data;
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + to_string(gemChance) + " `ogems");
					Player::OnTalkBubble(peer, netID, " `wYou obtained " + to_string(gemChance) + " `wgems", 0);
					const int effect = 30;
					const int x = static_cast<PlayerInfo*>(peer->data)->x;
					const int y = static_cast<PlayerInfo*>(peer->data)->y;
					Player::OnParticleEffect(peer, effect, x, y, 0);
				}
				if (kuriPrizaDuot == 2) {
					int itemuMas[5] = { 7912, 7912, 7912, 5078, 8834 };
					auto randIndex = rand() % 5;
					auto itemId = itemuMas[randIndex];
					AddItemToInv(world, peer, itemId, 1);
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + itemDefs.at(6204).name + "`o");
				}
			}
			return;
		}
		if (tile == 6202)
		{
			auto iscontains = false;
			if (HasItemsInInv(peer, 6102, 1) != -1)
				return;
			else {
				RemoveItemFromInv(peer, 6202, 1, true);
				auto kuriPrizaDuot = rand() % 2 + 1;
				if (kuriPrizaDuot == 1) {
					auto gemChance = rand() % 70000;
					((PlayerInfo*)(peer->data))->gems += gemChance;
					GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems));
					ENetPacket* packetpp = enet_packet_create(pp.data, pp.len, ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packetpp);
					delete pp.data;
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + to_string(gemChance) + " `ogems");
					Player::OnTalkBubble(peer, netID, " `wYou obtained " + to_string(gemChance) + " `wgems", 0);
					const int effect = 30;
					const int x = static_cast<PlayerInfo*>(peer->data)->x;
					const int y = static_cast<PlayerInfo*>(peer->data)->y;
					Player::OnParticleEffect(peer, effect, x, y, 0);
				}
				if (kuriPrizaDuot == 2) {
					int itemuMas[5] = { 7912, 5078, 5078, 5078, 8834 };
					auto randIndex = rand() % 5;
					auto itemId = itemuMas[randIndex];
					AddItemToInv(world, peer, itemId, 1);
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + itemDefs.at(6202).name + "`o");
				}
			}
			return;
		}
		if (tile == 6200)
		{
			auto iscontains = false;
			if (HasItemsInInv(peer, 6200, 1) != -1)
				return;
			else {
				RemoveItemFromInv(peer, 6200, 1, true);
				auto kuriPrizaDuot = rand() % 2 + 1;
				if (kuriPrizaDuot == 1) {
					auto gemChance = rand() % 120000;
					((PlayerInfo*)(peer->data))->gems += gemChance;
					GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems));
					ENetPacket* packetpp = enet_packet_create(pp.data, pp.len, ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packetpp);
					delete pp.data;
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + to_string(gemChance) + " `ogems");
					Player::OnTalkBubble(peer, netID, " `wYou obtained " + to_string(gemChance) + " `wgems", 0);
					const int effect = 30;
					const int x = static_cast<PlayerInfo*>(peer->data)->x;
					const int y = static_cast<PlayerInfo*>(peer->data)->y;
					Player::OnParticleEffect(peer, effect, x, y, 0);
				}
				if (kuriPrizaDuot == 2) {
					int itemuMas[8] = { 7912, 7912, 7912, 7912, 5078, 5078, 5078, 8834 };
					auto randIndex = rand() % 8;
					auto itemId = itemuMas[randIndex];
					AddItemToInv(world, peer, itemId, 1);
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + itemDefs.at(6200).name + "`o");
				}
			}
			return;
		}
		if (tile == 7484)
		{
			auto iscontains = false;
			if (HasItemsInInv(peer, 7484, 1) != -1)
				return;
			else {
				RemoveItemFromInv(peer, 7484, 1, true);
				auto kuriPrizaDuot = rand() % 2 + 1;
				if (kuriPrizaDuot == 1) {
					auto gemChance = rand() % 170000;
					((PlayerInfo*)(peer->data))->gems += gemChance;
					GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems));
					ENetPacket* packetpp = enet_packet_create(pp.data, pp.len, ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packetpp);
					delete pp.data;
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + to_string(gemChance) + " `ogems");
					Player::OnTalkBubble(peer, netID, " `wYou obtained " + to_string(gemChance) + " `wgems", 0);
					const int effect = 30;
					const int x = static_cast<PlayerInfo*>(peer->data)->x;
					const int y = static_cast<PlayerInfo*>(peer->data)->y;
					Player::OnParticleEffect(peer, effect, x, y, 0);
				}
				if (kuriPrizaDuot == 2) {
					int itemuMas[12] = { 7912, 7912, 7912, 7912, 5078, 5078, 5078, 8834, 8834, 8834, 8834, 8834 };
					auto randIndex = rand() % 12;
					int itemId = itemuMas[randIndex];
					AddItemToInv(world, peer, itemId, 1);
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + itemDefs.at(7484).name + "`o");
				}
			}
			return;
		}
		if (tile == 7954)
		{
			auto iscontains = false;
			if (HasItemsInInv(peer, 7954, 1) != -1)
				return;
			else {
				RemoveItemFromInv(peer, 7954, 1, true);
				auto kuriPrizaDuot = rand() % 2 + 1;
				if (kuriPrizaDuot == 1) {
					int gemChance = rand() % 200000;
					((PlayerInfo*)(peer->data))->gems += gemChance;
					GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems));
					ENetPacket* packetpp = enet_packet_create(pp.data, pp.len, ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packetpp);
					delete pp.data;
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + to_string(gemChance) + " `ogems");
					Player::OnTalkBubble(peer, netID, " `wYou obtained " + to_string(gemChance) + " `wgems", 0);
					const int effect = 30;
					const int x = static_cast<PlayerInfo*>(peer->data)->x;
					const int y = static_cast<PlayerInfo*>(peer->data)->y;
					Player::OnParticleEffect(peer, effect, x, y, 0);
				}
				if (kuriPrizaDuot == 2) {
					int itemuMas[12] = { 7912, 7912, 7912, 7912, 5078, 5078, 5078, 8834, 8834, 8834, 8834, 8834 };
					auto randIndex = rand() % 12;
					auto itemId = itemuMas[randIndex];
					AddItemToInv(world, peer, itemId, 1);
					Player::OnConsoleMessage(peer, "`oYou have obtained `$" + itemDefs.at(7954).name + "`o");
				}
			}
			return;
		}
		if (tile == 11398) {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
				if (isHere(peer, currentPeer)) {
					if (x == ((PlayerInfo*)(peer->data))->x / 32 && y == ((PlayerInfo*)(peer->data))->y / 32) {
						RemoveItemFromInv(peer, 11398, 1, true);
						vector<int> alien_pod{ 10990, 11000, 11410, 11426, 10952, 10956, 10954, 10958, 10960, 10996, 11408, 11412, 11414, 10998, 11422, 10994 };
						int rand_item = alien_pod[rand() % alien_pod.size()];
						int count = 1;
						if (rand_item == 10990) count = 1;
						if (rand_item == 11000) count = 1;
						if (rand_item == 11410) count = 1;
						if (rand_item == 11426) count = 1;
						if (rand_item == 10952) count = 1;
						if (rand_item == 10956) count = 1;
						if (rand_item == 10954) count = 1;
						if (rand_item == 10958) count = 1;
						if (rand_item == 10960) count = 1;
						if (rand_item == 10958) count = 1;
						if (rand_item == 10996) count = 1;
						if (rand_item == 11408) count = 1;
						if (rand_item == 11412) count = 1;
						if (rand_item == 11414) count = 1;
						if (rand_item == 10998) count = 1;
						if (rand_item == 11422) count = 1;
						if (rand_item == 10994) count = 1;
						if (rand_item == 10960 || rand_item == 10956 || rand_item == 10958 || rand_item == 10954) {
							int target = 5;
							if (tile == 9286) target = 10;
							if ((rand() % 1000) <= target) {}
							else rand_item = 11422;
						}
						Player::OnTalkBubble(peer, netID, "You received `2" + to_string(count) + " " + itemDefs.at(rand_item).name + "`` from the Alien Landing Pod.", 0);
						Player::OnConsoleMessage(peer, "You received `2" + to_string(count) + " " + itemDefs.at(rand_item).name + "`` from the Alien Landing Pod.");
						bool success = true;
						SendTradeEffect(peer, rand_item, netID, netID, 10);
						AddItemToInv(world, peer, rand_item, count);
						return;
					}
					else {
						Player::OnTalkBubble(peer, netID, "Must be used on a person.", 0);
						return;
					}
				}
			}
		}
		if (itemDefs.at(tile).name == "Enchanted Spatula")
		{
			if (getItemDef(world->items[x + y * world->height].foreground).properties & Property_MultiFacing)
			{
				if (world->owner != ((PlayerInfo*)(peer->data))->rawName) return;
				if (world->items[x + y * world->height].flipped)
				{
					world->items[x + y * world->height].flipped = false;
					UpdateBlockState(peer, x, y, true, world);
					SaveBlockState(world, peer, x, y);
				}
				else
				{
					world->items[x + y * world->height].flipped = true;
					UpdateBlockState(peer, x, y, true, world);
					SaveBlockState(world, peer, x, y);
				}
				RemoveItemFromInv(peer, tile, 1, true);
				ENetPeer* net_peer;
				for (net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
					if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
					if (isHere(peer, net_peer)) {
						Player::OnParticleEffect(net_peer, 97, x * 32, y * 32, 0);
					}
				}
			}
			return;
		}
		if (world->items.at(x + (y * world->width)).foreground == 6016 && tile == 32) {
			((PlayerInfo*)(peer->data))->lastPunchX = x;
			((PlayerInfo*)(peer->data))->lastPunchY = y;
			try {
				string EditableDialog = "";
				string button_dialog = "";
				string allowFloat = "0";
				string allowDrop = "0";
				string endDialog = "";
				if (world->items.at(x + (y * world->width)).rm) allowFloat = "1";
				if (world->items.at(x + (y * world->width)).opened) allowDrop = "1";
				if (isWorldOwner(peer, world)) {
					endDialog = "\nend_dialog|statsblock|Cancel|Apply|";
					button_dialog = "\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|\nadd_button|floatingItems|Floating Items|noflags|0|0|";
					EditableDialog = "\nadd_textbox|`wYou can set the stats to be usable by the public.|left\nadd_checkbox|isStatsWorldBlockUsableByPublic|World blocks is usable by public|" + allowDrop + "\nadd_checkbox|isStatsFloatingItemsUsableByPublic|Floating items is usable by public|" + allowFloat + "\nadd_spacer|small|";
				}
				else if (world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).opened) {
					endDialog = "\nend_dialog|statsblock|Cancel||";
					button_dialog = "\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|\nadd_button|floatingItems|Floating Items|noflags|0|0|";
				}
				else if (world->items.at(x + (y * world->width)).rm) {
					endDialog = "\nend_dialog|statsblock|Cancel||";
					button_dialog = "\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|floatingItems|Floating Items|noflags|0|0|";
				}
				else if (world->items.at(x + (y * world->width)).opened) {
					endDialog = "\nend_dialog|statsblock|Cancel||";
					button_dialog = "\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|";
				}
				else {
					endDialog = "\nend_dialog|statsblock|Cancel||";
					button_dialog = "\nadd_textbox|`wThis growscan options are set to private!|left";
				}
				Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|\nadd_textbox|`wThis amazing block can show the stats for the whole world!|left\nadd_spacer|small|" + button_dialog + "\nadd_spacer|small|" + EditableDialog + "" + endDialog + "");
			}
			catch (std::exception& e) {
				std::cout << e.what() << std::endl;
			}
			catch (const std::out_of_range& e) {
				std::cout << e.what() << std::endl;
			}
			return;
		}
		if (world->items.at(x + (y * world->width)).foreground == 3898)
		{
			if (isWorldOwner(peer, world) || world->owner == "" || isDev(peer) || isWorldAdmin(peer, world)) {
				Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wTelephone`|left|3898|\n\nadd_spacer|small|\nadd_label|small|`oDial a number to call somebody in Growtopia. Phone numbers have 5 digits. Most numbers are not in service!|\nadd_spacer|small|\nadd_text_input|telephonenumber|Phone #||5|\nend_dialog|usetelephone|Hang Up|`wDial|\n");
			}
			return;
		}
		if (itemDefs.at(tile).blockType == BlockTypes::MAILBOX) {
			int squaresign = x + (y * world->width);
			namespace fs = std::experimental::filesystem;
			if (!fs::is_directory("mailbox/_" + world->name) || !fs::exists("mailbox/_" + world->name))
			{
				fs::create_directory("mailbox/_" + world->name);
			}
			ofstream of("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
			json j;
			j["x"] = x;
			j["y"] = y;
			j["inmail"] = 0;
			json jArray = json::array();
			json jmid;
			for (int i = 1; i <= 90; i++)
			{
				jmid["aposition"] = i;
				jmid["growid"] = "";
				jmid["text"] = "";
				jArray.push_back(jmid);
			}
			j["mails"] = jArray;
			of << j << std::endl;
			of.close();
		}
		if (itemDefs.at(tile).blockType == BlockTypes::DONATION)
		{
			int squaresign = x + (y * world->width);
			namespace fs = std::experimental::filesystem;
			if (!fs::is_directory("donationboxes/_" + world->name) || !fs::exists("donationboxes/_" + world->name))
			{
				fs::create_directory("donationboxes/_" + world->name);
			}
			ofstream of("donationboxes/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
			json j;
			j["donated"] = 0;
			json jArray = json::array();
			json jmid;
			for (int i = 1; i <= 20; i++)
			{
				jmid["aposition"] = i;
				jmid["sentBy"] = "";
				jmid["note"] = "";
				jmid["itemid"] = 0;
				jmid["itemcount"] = 0;
				jArray.push_back(jmid);
			}
			j["donatedItems"] = jArray;
			of << j << std::endl;
			of.close();
		}
		if (tile == 10072 || tile == 10076 || tile == 10078 || tile == 1420 || tile == 10074 || tile == 6214) {
			try {
				namespace fs = std::experimental::filesystem;
				if (!fs::is_directory("mannequin/" + world->name) || !fs::exists("mannequin/" + world->name))
				{
					fs::create_directory("mannequin/" + world->name);
				}
				json j;
				int squaresign = x + (y * world->width);
				auto seedexist = std::experimental::filesystem::exists("mannequin/" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
				if (!seedexist) {
					j["clothHead"] = "0";
					j["clothHair"] = "0";
					j["clothMask"] = "0";
					j["clothNeck"] = "0";
					j["clothBack"] = "0";
					j["clothShirt"] = "0";
					j["clothPants"] = "0";
					j["clothFeet"] = "0";
					j["clothHand"] = "0";
					ofstream of("mannequin/" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(x + (y * 100)) + ".json");
					of << j;
					of.close();
				}
			}
			catch (std::exception& e) {
				std::cout << e.what() << std::endl;
			}
			catch (const std::out_of_range& e) {
				std::cout << e.what() << std::endl;
			}
		}
		if (itemDefs.at(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::Mannequin) {
			ifstream ifs("mannequin/" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(x + (y * 100)) + ".json");
			if (getItemDef(tile).blockType == BlockTypes::CLOTHING)
			{
				if (ifs.is_open()) {
					json j;
					ifstream fs("mannequin/" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(x + (y * 100)) + ".json");
					fs >> j;
					fs.close();
					if (tile != 18) {
						if (world->isPublic || isWorldAdmin(peer, world) || ((PlayerInfo*)(peer->data))->rawName == world->owner || world->owner == "" || isDev(peer)) {
							switch (getItemDef(tile).clothType)
							{
							case 0:
								j["clothHead"] = to_string(tile);
								break;
							case 7:
								j["clothHair"] = to_string(tile);
								break;
							case 4:
								j["clothMask"] = to_string(tile);
								break;
							case 8:
								j["clothNeck"] = to_string(tile);
								break;
							case 6:
								j["clothBack"] = to_string(tile);
								break;
							case 1:
								j["clothShirt"] = to_string(tile);
								break;
							case 2:
								j["clothPants"] = to_string(tile);
								break;
							case 3:
								j["clothFeet"] = to_string(tile);
								break;
							case 5:
								j["clothHand"] = to_string(tile);
								break;
							}
							auto c = getItemDef(tile).clothType;
							if (c != 10) {
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
									if (isHere(peer, currentPeer))  updateMannequin(world, currentPeer, x, y, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].sign, atoi(j["clothHead"].get<string>().c_str()), atoi(j["clothShirt"].get<string>().c_str()), atoi(j["clothPants"].get<string>().c_str()), atoi(j["clothFeet"].get<string>().c_str()), atoi(j["clothMask"].get<string>().c_str()), atoi(j["clothHand"].get<string>().c_str()), atoi(j["clothBack"].get<string>().c_str()), atoi(j["clothHair"].get<string>().c_str()), atoi(j["clothNeck"].get<string>().c_str())); ((PlayerInfo*)(peer->data))->wrenchedBlockLocation = x + (y * world->width);
									ofstream of("mannequin/" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(x + (y * 100)) + ".json");
									of << j;
									of.close();
								}
							}
						}
					}
					else {
						if (world->isPublic || isWorldAdmin(peer, world) || ((PlayerInfo*)(peer->data))->rawName == world->owner || world->owner == "" || isDev(peer)) {
							if (j["clothHead"].get<string>() != "0")
							{
								j["clothHead"] = "0";
							}
							else if (j["clothHair"].get<string>() != "0") {
								j["clothHair"] = "0";
							}
							else if (j["clothMask"].get<string>() != "0") {
								j["clothMask"] = "0";
							}
							else if (j["clothNeck"].get<string>() != "0") {
								j["clothNeck"] = "0";
							}
							else if (j["clothBack"].get<string>() != "0") {
								j["clothBack"] = "0";
							}
							else if (j["clothShirt"].get<string>() != "0") {
								j["clothShirt"] = "0";
							}
							else if (j["clothPants"].get<string>() != "0") {
								j["clothPants"] = "0";
							}
							else if (j["clothFeet"].get<string>() != "0") {
								j["clothFeet"] = "0";
							}
							else if (j["clothHand"].get<string>() != "0") {
								j["clothHand"] = "0";
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
								if (isHere(peer, currentPeer))  updateMannequin(world, currentPeer, x, y, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].sign, atoi(j["clothHead"].get<string>().c_str()), atoi(j["clothShirt"].get<string>().c_str()), atoi(j["clothPants"].get<string>().c_str()), atoi(j["clothFeet"].get<string>().c_str()), atoi(j["clothMask"].get<string>().c_str()), atoi(j["clothHand"].get<string>().c_str()), atoi(j["clothBack"].get<string>().c_str()), atoi(j["clothHair"].get<string>().c_str()), atoi(j["clothNeck"].get<string>().c_str()));
								ofstream of("mannequin/" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(x + (y * 100)) + ".json");
								of << j;
								of.close();
							}
						}
					}
				}
			}
		}
		if (world->items[x + (y * world->width)].foreground == 3798 && tile == 32) {
			((PlayerInfo*)(peer->data))->lastPunchX = x;
			((PlayerInfo*)(peer->data))->lastPunchY = y;
			if ((find(world->viplist.begin(), world->viplist.end(), ((PlayerInfo*)(peer->data))->rawName) != world->viplist.end())) {
				Player::OnDialogRequest(peer, "set_default_colorset_default_color|`o\n\nadd_label_with_icon|big|`wEdit VIP Entrance|left|3798|\nadd_textbox|`oThis Entrance is owned by `w" + world->owner + "`o, but i have access on it.|\nend_dialog|RemoveMyVipAccess|Cancel|`wRemove my Access|");
				return;
			}
			if (((PlayerInfo*)(peer->data))->rawName == world->owner || (find(world->viplist.begin(), world->viplist.end(), ((PlayerInfo*)(peer->data))->rawName) != world->viplist.end())) {
				string offlinelist = ""; string offname = ""; int ischecked;
				for (std::vector<string>::const_iterator i = world->viplist.begin(); i != world->viplist.end(); ++i) {
					offname = *i;
					offlinelist += "\nadd_checkbox|VipAccess|" + offname + "|1|\n";
				}
				if (world->items[x + (y * world->width)].rm == true) {
					ischecked = 1;
				}
				else {
					ischecked = 0;
				}
				string VipPublic = to_string(ischecked);
				if (world->viplist.size() == 0) {
					((PlayerInfo*)(peer->data))->lastPunchX = x;
					((PlayerInfo*)(peer->data))->lastPunchY = y;
					Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit VIP Entrance|left|3798|\nadd_label|small|`wVip list:``|left\nadd_spacer|small|\nadd_label|small|`oNobody!``|left\nadd_spacer|small|\nadd_player_picker|VipAcc|`wAdd``|\nadd_checkbox|vip_public|Allow Anyone to enter|" + VipPublic + "|\nend_dialog|vip_entrance|Cancel|OK|");
				}
				else {
					((PlayerInfo*)(peer->data))->lastPunchX = x;
					((PlayerInfo*)(peer->data))->lastPunchY = y;
					Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit VIP Entrance|left|3798|\nadd_label|small|`wVip list:``|left|\nadd_spacer|small|" + offlinelist + "nadd_spacer|small|\nadd_player_picker|VipAcc|`wAdd``|\nadd_checkbox|vip_public|Allow Anyone to enter|" + VipPublic + "|\nend_dialog|vip_entrance|Cancel|OK|");
				}
			}
			else {
				Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wEdit VIP Entrance|left|3798|\nadd_textbox|`oYou're not on the VIP list!|left|\nend_dialog|close|Close|");
			}
		}
		if (tile == 10456) {
			if (x == ((PlayerInfo*)(peer->data))->x / 32 && y == ((PlayerInfo*)(peer->data))->y / 32) {
				if (((PlayerInfo*)(peer->data))->cloth_back != 10456) {
					((PlayerInfo*)(peer->data))->cloth_back = 10456;
					sendState(peer);
					sendClothes(peer);
				}
				else {
					((PlayerInfo*)(peer->data))->cloth_back = 0;
					sendState(peer);
					sendClothes(peer);
				}
			}
			else {
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Must be used on a person.", 0);
			}
		}
		if (tile == 7480) {
			if (x == ((PlayerInfo*)(peer->data))->x / 32 && y == ((PlayerInfo*)(peer->data))->y / 32) {
				if (((PlayerInfo*)(peer->data))->cloth_back != 7480) {
					((PlayerInfo*)(peer->data))->cloth_back = 7480;
					sendState(peer);
					sendClothes(peer);
				}
				else {
					((PlayerInfo*)(peer->data))->cloth_back = 0;
					sendState(peer);
					sendClothes(peer);
				}
			}
			else {
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Must be used on a person.", 0);
			}
		}
		if (tile == 1866) {
			if (world->owner == "" || isWorldOwner(peer, world) || isDev(peer)) {
				if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::LOCK) {
					return;
				}
				world->items.at(x + (y * world->width)).glue = !world->items.at(x + (y * world->width)).glue;
				UpdateBlockState(peer, x, y, true, world);
			}
			return;
		}
		if (tile == 9286 || tile == 5750) /*lucky fortune cookie*/
		{
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
				if (isHere(peer, currentPeer)) {
					if (x == ((PlayerInfo*)(peer->data))->x / 32 && y == ((PlayerInfo*)(peer->data))->y / 32) {
						RemoveItemFromInv(peer, tile, 1, true);
						vector<int> lunar_new_year{ 10616, 10582, 10580, 10664, 10596, 10598, 10586, 10590, 10592, 10576, 10578, 202, 204, 206, 4994, 2978, 5766, 5768, 5744, 5756, 5758, 5760, 5762, 5754, 7688, 7690, 7694, 7686, 7692, 7698, 7696, 9286, 9272, 9290, 9280, 9282, 9292, 9284 };
						vector<string> lunar_messages{ "`5Fortune: You will only get what you have the courage to pursue.``", "`5Fortune: You will live two lives.The second will begin when you realize you only have one.``", "`5Fortune: Looking on your past is fine. Same for the future. Just don't get caught staring.``", "`5Fortune: Your reality check is about to bounce.``", "`5Fortune: Telling people their future is easy. The hard part is being right.``", "`5Fortune: Deal with the faults of others as gently as your own.``", "`5Fortune: Things could always be better. The key is knowing if they're good enough.``", "`5Fortune: You will live two lives. The second will begin when you realize you only have one.``", "`5Fortune: Things could always be better. The key is knowing if they're good enough.``", "`5Fortune: Knowledge is worthless unless put into practice.``", "`5Fortune: You can't stop the waves, but you can learn to surf.``", "`5Fortune: A block in the hand is worth two on the tree.``", "`5Fortune: If it feels like you're always arguing with idiots, consider the company you keep.``", "`5Fortune: Don't chase happiness - create it.``", "`5Fortune: Even a fish wouldn't get into trouble if it kept its mouth shut.``", "`5Fortune: One's measure is in how they treat those that cannot help them.``" };
						if (tile == 5750) lunar_new_year.push_back(9286);
						int rand_item = lunar_new_year[rand() % lunar_new_year.size()];
						string rand_message = lunar_messages[rand() % lunar_messages.size()];
						int count = 1;
						if (rand_item == 5768) count = 4;
						if (rand_item == 5766) count = 3;
						if (rand_item == 5744 || rand_item == 9290) count = 8;
						if (rand_item == 7696 || rand_item == 9272 || rand_item == 5754 || rand_item == 10576) {
							int target = 5;
							if (tile == 9286) target = 10;
							if ((rand() % 1000) <= target) {}
							else rand_item = 5744;
						}
						Player::OnTalkBubble(peer, netID, "You received `2" + to_string(count) + " " + itemDefs.at(rand_item).name + "`` from the Lucky Fortune Cookie.", 0);
						Player::OnConsoleMessage(peer, "You received `2" + to_string(count) + " " + itemDefs.at(rand_item).name + "`` from the Lucky Fortune Cookie.");
						Player::OnTalkBubble(peer, netID, rand_message, 0);
						Player::OnConsoleMessage(peer, rand_message);
						AddItemToInv(world, peer, rand_item, count);
						break;
					}
					else if (x == static_cast<PlayerInfo*>(currentPeer->data)->x / 32 && y == static_cast<PlayerInfo*>(currentPeer->data)->y / 32) {
						Player::OnTalkBubble(peer, netID, "You can only use that on yourself.", 0);
						break;
					}
					else {
						Player::OnTalkBubble(peer, netID, "Must be used on a person.", 0);
					}
				}
			}
		}
		if (tile == 1826) {
			if (!isWorldOwner(peer, world)) return;
			bool FoundSomething = false;
			for (int i = 0; i < world->width * world->height; i++) {
				if (getItemDef(world->items.at(i).foreground).blockType == BlockTypes::SEED) {
					sendTileUpdate(world, (i % world->width), (i / world->width), 18, netID, peer);
					ENetPeer* net_peer;
					for (net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							Player::OnParticleEffect(net_peer, 182, (i % world->width) * 32, (static_cast<float>(i) / world->width) * 32, 0);
						}
					}
					FoundSomething = true;
				}
			}
			if (FoundSomething) RemoveItemFromInv(peer, 1826, 1, true);
			return;
		}
		if (tile == 1402) {
			Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wThermonuclear Blast`|left|1402|\nadd_textbox|This item creates a new world!  Enter a unique name for it.|left|\nadd_text_input|thermoname|New World Name||24|\nend_dialog|usethermoblast|Cancel|`5Create!|\n");
			return;
		}
		if (((PlayerInfo*)(peer->data))->cloth_hand == 3494) {
			if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner)) {
				switch (tile) {
				case 3478:
				{
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::MAIN_DOOR || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 8) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That's too special to paint.", 0);
						return;
					}
					if (world->items[x + (y * world->width)].red && !world->items[x + (y * world->width)].green && !world->items[x + (y * world->width)].blue) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That block is already painted that color!", 0);
						return;
					}
					if (world->items[x + (y * world->width)].foreground == 0 && world->items[x + (y * world->width)].background == 0) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "There's nothing to paint!", 0);
						return;
					}
					RemoveItemFromInv(peer, 3478, 1, true);
					if (world->items[x + (y * world->width)].foreground == 0 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED) {
						if (rand() % 100 <= 15) {
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 3479, 1, 0);
						}
						else if (rand() % 100 <= 35) {
							int cn = rand() % 15;
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 112, cn, 0);
						}
					}
					world->items[x + (y * world->width)].red = true;
					world->items[x + (y * world->width)].green = false;
					world->items[x + (y * world->width)].blue = false;
					for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							UpdateBlockState(net_peer, x, y, true, world);
							SaveBlockState(world, net_peer, x, y);
							SendParticleEffect(net_peer, x * 32 + 16, y * 32 + 16, 1953289573, 168, 0);
						}
					}
					return;
				}
				case 3480:
				{
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::MAIN_DOOR || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 8) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That's too special to paint.", 0);
						return;
					}
					if (world->items[x + (y * world->width)].red && world->items[x + (y * world->width)].green && !world->items[x + (y * world->width)].blue) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That block is already painted that color!", 0);
						return;
					}
					if (world->items[x + (y * world->width)].foreground == 0 && world->items[x + (y * world->width)].background == 0) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "There's nothing to paint!", 0);
						return;
					}
					RemoveItemFromInv(peer, 3480, 1, true);
					if (world->items[x + (y * world->width)].foreground == 0 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED) {
						if (rand() % 100 <= 15) {
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 3481, 1, 0);
						}
						else if (rand() % 100 <= 35) {
							int cn = rand() % 15;
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 112, cn, 0);
						}
					}
					world->items[x + (y * world->width)].red = true;
					world->items[x + (y * world->width)].green = true;
					world->items[x + (y * world->width)].blue = false;
					for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							UpdateBlockState(net_peer, x, y, true, world);
							SaveBlockState(world, net_peer, x, y);
							SendParticleEffect(net_peer, x * 32 + 16, y * 32 + 16, 1153289573, 168, 0);
						}
					}
					return;
				}
				case 3482:
				{
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::MAIN_DOOR || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 8) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That's too special to paint.", 0);
						return;
					}
					if (!world->items[x + (y * world->width)].red && world->items[x + (y * world->width)].green && !world->items[x + (y * world->width)].blue) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That block is already painted that color!", 0);
						return;
					}
					if (world->items[x + (y * world->width)].foreground == 0 && world->items[x + (y * world->width)].background == 0) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "There's nothing to paint!", 0);
						return;
					}
					RemoveItemFromInv(peer, 3482, 1, true);
					if (world->items[x + (y * world->width)].foreground == 0 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED) {
						if (rand() % 100 <= 15) {
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 3483, 1, 0);
						}
						else if (rand() % 100 <= 35) {
							int cn = rand() % 15;
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 112, cn, 0);
						}
					}
					world->items[x + (y * world->width)].red = false;
					world->items[x + (y * world->width)].green = true;
					world->items[x + (y * world->width)].blue = false;
					for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							UpdateBlockState(net_peer, x, y, true, world);
							SaveBlockState(world, net_peer, x, y);
							SendParticleEffect(net_peer, x * 32 + 16, y * 32 + 16, 94634864, 168, 0);
						}
					}
					return;
				}
				case 3484:
				{
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::MAIN_DOOR || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 8) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That's too special to paint.", 0);
						return;
					}
					if (!world->items[x + (y * world->width)].red && world->items[x + (y * world->width)].green && world->items[x + (y * world->width)].blue) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That block is already painted that color!", 0);
						return;
					}
					if (world->items[x + (y * world->width)].foreground == 0 && world->items[x + (y * world->width)].background == 0) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "There's nothing to paint!", 0);
						return;
					}
					RemoveItemFromInv(peer, 3484, 1, true);
					if (world->items[x + (y * world->width)].foreground == 0 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED) {
						if (rand() % 100 <= 15) {
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 3485, 1, 0);
						}
						else if (rand() % 100 <= 35) {
							int cn = rand() % 15;
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 112, cn, 0);
						}
					}
					world->items[x + (y * world->width)].red = false;
					world->items[x + (y * world->width)].green = true;
					world->items[x + (y * world->width)].blue = true;
					for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							UpdateBlockState(net_peer, x, y, true, world);
							SaveBlockState(world, net_peer, x, y);
							SendParticleEffect(net_peer, x * 32 + 16, y * 32 + 16, 3253289573, 168, 0);
						}
					}
					return;
				}
				case 3486:
				{
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::MAIN_DOOR || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 8) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That's too special to paint.", 0);
						return;
					}
					if (!world->items[x + (y * world->width)].red && !world->items[x + (y * world->width)].green && world->items[x + (y * world->width)].blue) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That block is already painted that color!", 0);
						return;
					}
					if (world->items[x + (y * world->width)].foreground == 0 && world->items[x + (y * world->width)].background == 0) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "There's nothing to paint!", 0);
						return;
					}
					RemoveItemFromInv(peer, 3486, 1, true);
					if (world->items[x + (y * world->width)].foreground == 0 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED) {
						if (rand() % 100 <= 15) {
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 3486, 1, 0);
						}
						else if (rand() % 100 <= 35) {
							int cn = rand() % 15;
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 112, cn, 0);
						}
					}
					world->items[x + (y * world->width)].red = false;
					world->items[x + (y * world->width)].green = false;
					world->items[x + (y * world->width)].blue = true;
					for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							UpdateBlockState(net_peer, x, y, true, world);
							SaveBlockState(world, net_peer, x, y);
							SendParticleEffect(net_peer, x * 32 + 16, y * 32 + 16, 2553289573, 168, 0);
						}
					}
					return;
				}
				case 3488:
				{
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::MAIN_DOOR || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 8) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That's too special to paint.", 0);
						return;
					}
					if (world->items[x + (y * world->width)].red && !world->items[x + (y * world->width)].green && world->items[x + (y * world->width)].blue) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That block is already painted that color!", 0);
						return;
					}
					if (world->items[x + (y * world->width)].foreground == 0 && world->items[x + (y * world->width)].background == 0) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "There's nothing to paint!", 0);
						return;
					}
					RemoveItemFromInv(peer, 3488, 1, true);
					if (world->items[x + (y * world->width)].foreground == 0 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED) {
						if (rand() % 100 <= 15) {
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 3489, 1, 0);
						}
						else if (rand() % 100 <= 35) {
							int cn = rand() % 15;
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 112, cn, 0);
						}
					}
					world->items[x + (y * world->width)].red = true;
					world->items[x + (y * world->width)].green = false;
					world->items[x + (y * world->width)].blue = true;
					for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							UpdateBlockState(net_peer, x, y, true, world);
							SaveBlockState(world, net_peer, x, y);
							SendParticleEffect(net_peer, x * 32 + 16, y * 32 + 16, 3205873253, 168, 0);
						}
					}
					return;
				}
				case 3490:
				{
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::MAIN_DOOR || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 8) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That's too special to paint.", 0);
						return;
					}
					if (world->items[x + (y * world->width)].red && world->items[x + (y * world->width)].green && world->items[x + (y * world->width)].blue) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That block is already painted that color!", 0);
						return;
					}
					if (world->items[x + (y * world->width)].foreground == 0 && world->items[x + (y * world->width)].background == 0) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "There's nothing to paint!", 0);
						return;
					}
					RemoveItemFromInv(peer, 3490, 1, true);
					if (world->items[x + (y * world->width)].foreground == 0 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED) {
						if (rand() % 100 <= 15) {
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 3491, 1, 0);
						}
						else if (rand() % 100 <= 35) {
							int cn = rand() % 15;
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 112, cn, 0);
						}
					}
					world->items[x + (y * world->width)].red = true;
					world->items[x + (y * world->width)].green = true;
					world->items[x + (y * world->width)].blue = true;
					for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							UpdateBlockState(net_peer, x, y, true, world);
							SaveBlockState(world, net_peer, x, y);
							SendParticleEffect(net_peer, x * 32 + 16, y * 32 + 16, 0, 168, 0);
						}
					}
					return;
				}
				case 3492:
				{
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::MAIN_DOOR || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 8) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That's too special to paint.", 0);
						return;
					}
					if (!world->items[x + (y * world->width)].red && !world->items[x + (y * world->width)].green && !world->items[x + (y * world->width)].blue) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Don't waste your varnish on an unpainted block!", 0);
						return;
					}
					if (world->items[x + (y * world->width)].foreground == 0 && world->items[x + (y * world->width)].background == 0) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "There's nothing to paint!", 0);
						return;
					}
					RemoveItemFromInv(peer, 3492, 1, true);
					if (world->items[x + (y * world->width)].foreground == 0 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED) {
						if (rand() % 100 <= 15) {
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 3493, 1, 0);
						}
						else if (rand() % 100 <= 35) {
							int cn = rand() % 15;
							dropItem(world, peer, -1, data.punchX * 32 + rand() % 18, data.punchY * 32 + rand() % 18, 112, cn, 0);
						}
					}
					world->items[x + (y * world->width)].red = false;
					world->items[x + (y * world->width)].green = false;
					world->items[x + (y * world->width)].blue = false;
					for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer)) {
							UpdateBlockState(net_peer, x, y, true, world);
							SaveBlockState(world, net_peer, x, y);
							SendParticleEffect(net_peer, x * 32 + 16, y * 32 + 16, -1, 168, 0);
						}
					}
					return;
				}
				default: break;
				}
			}
		}
		if (world->items.at(x + (y * world->width)).foreground == 5638 && tile == 18) {
			PlayerInfo* pData = (PlayerInfo*)peer->data;
			bool canuseremote = true;
			if (canuseremote) {
				if (pData->inventory.items.size() == pData->inventory.inventorySize) {
				}
				else {
					if (!CheckItemExists(peer, 5640)) {
						if (isWorldOwner(peer, world) && world->items.at(x + (y * world->width)).intdata != 0 && world->items.at(x + (y * world->width)).fruitcount != 0 || world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).intdata != 0 && world->items.at(x + (y * world->width)).fruitcount != 0) {
							bool Farmable = false;
							if (world->items.at(x + (y * world->width)).intdata == 7382 || world->items.at(x + (y * world->width)).intdata == 4762 || world->items.at(x + (y * world->width)).intdata == 5140 || world->items.at(x + (y * world->width)).intdata == 5138 || world->items.at(x + (y * world->width)).intdata == 5136 || world->items.at(x + (y * world->width)).intdata == 5154 || world->items.at(x + (y * world->width)).intdata == 340 || world->items.at(x + (y * world->width)).intdata == 954 || world->items.at(x + (y * world->width)).intdata == 5666) Farmable = true;
							if (world->items.at(x + (y * world->width)).foreground == 5638 && itemDefs.at(world->items.at(x + (y * world->width)).intdata).blockType == BlockTypes::FOREGROUND || world->items.at(x + (y * world->width)).foreground == 5638 && Farmable || world->items.at(x + (y * world->width)).foreground == 5638 && itemDefs.at(world->items.at(x + (y * world->width)).intdata).blockType == BlockTypes::BACKGROUND || world->items.at(x + (y * world->width)).foreground == 5638 && itemDefs.at(world->items.at(x + (y * world->width)).intdata).blockType == BlockTypes::GROUND_BLOCK) {
								if (itemDefs.at(world->items.at(x + (y * world->width)).intdata).properties & Property_AutoPickup) {
									/*...*/
								}
								else {
									Player::OnTalkBubble(peer, pData->netID, "`wYou received a MAGPLANT 5000 Remote.", 0);
									bool success = true;
									AddItemToInv(world, peer, 5640, 1);
									GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnPlanterActivated"), world->items.at(x + (y * world->width)).intdata));
									ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet3);
									delete p3.data;
									pData->magplantitemid = world->items.at(x + (y * world->width)).intdata;
									pData->magplantx = x;
									pData->magplanty = y;
								}
							}
						}
					}
					else {
						GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnPlanterActivated"), world->items.at(x + (y * world->width)).intdata));
						ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet3);
						delete p3.data;
						pData->magplantitemid = world->items.at(x + (y * world->width)).intdata;
						pData->magplantx = x;
						pData->magplanty = y;
					}
				}
			}
		}
		if (tile == 5640) {
			bool aryra = false;
			for (int i = 0; i < world->width * world->height; i++) {
				if (world->items.at(i).foreground == 5638) {
					aryra = true;
				}
			}
			if (aryra == true) {
				if (((PlayerInfo*)(peer->data))->magplantx != 0 && ((PlayerInfo*)(peer->data))->magplanty != 0) {
					int squaresign = ((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width);
					string currentworld = ((PlayerInfo*)(peer->data))->currentWorld + "X" + std::to_string(squaresign);
					if (world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).intdata == ((PlayerInfo*)(peer->data))->magplantitemid && world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).fruitcount > 0) {
						int magplantid = ((PlayerInfo*)(peer->data))->magplantitemid;
						bool RotatedRight = false;
						auto xpos = x * 32;
						auto ppos = ((PlayerInfo*)(peer->data))->x;
						if (((PlayerInfo*)(peer->data))->x < x * 32) RotatedRight = true;
						if (RotatedRight) ppos += 19;
						xpos = xpos / 32;
						ppos = ppos / 32;
						if (world->items.at(x + (y * world->width)).foreground != 0 && itemDefs.at(magplantid).blockType != BlockTypes::BACKGROUND && itemDefs.at(magplantid).blockType != BlockTypes::GROUND_BLOCK) return;
						ENetPeer* currentPeer;
						for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
							if (isHere(peer, currentPeer)) {
								bool RotatedRight = false;
								auto xpos = x * 32;
								auto ppos = static_cast<PlayerInfo*>(currentPeer->data)->x;
								if (static_cast<PlayerInfo*>(currentPeer->data)->x < x * 32) RotatedRight = true;
								if (RotatedRight) ppos += 19;
								xpos = xpos / 32;
								ppos = ppos / 32;
								if (ppos == xpos && static_cast<PlayerInfo*>(currentPeer->data)->y / 32 == y && itemDefs.at(magplantid).properties != Property_NoSeed && itemDefs.at(magplantid).properties != Property_MultiFacing && itemDefs.at(magplantid).blockType != BlockTypes::SEED && itemDefs.at(magplantid).blockType != BlockTypes::UNKNOWN && itemDefs.at(magplantid).blockType != BlockTypes::VENDING && itemDefs.at(magplantid).blockType != BlockTypes::ANIM_FOREGROUND && itemDefs.at(magplantid).blockType != BlockTypes::BULLETIN_BOARD && itemDefs.at(magplantid).blockType != BlockTypes::FACTION && itemDefs.at(magplantid).blockType != BlockTypes::CHEST && itemDefs.at(magplantid).blockType != BlockTypes::GEMS && itemDefs.at(magplantid).blockType != BlockTypes::MAGIC_EGG && itemDefs.at(magplantid).blockType != BlockTypes::MAILBOX && itemDefs.at(magplantid).blockType != BlockTypes::PORTAL && itemDefs.at(magplantid).blockType != BlockTypes::PLATFORM && itemDefs.at(magplantid).blockType != BlockTypes::SFX_FOREGROUND && itemDefs.at(magplantid).blockType != BlockTypes::SWITCH_BLOCK && itemDefs.at(magplantid).blockType != BlockTypes::TRAMPOLINE && itemDefs.at(magplantid).blockType != BlockTypes::TOGGLE_FOREGROUND && itemDefs.at(magplantid).blockType != BlockTypes::GROUND_BLOCK && itemDefs.at(magplantid).blockType != BlockTypes::BACKGROUND && itemDefs.at(magplantid).blockType != BlockTypes::MAIN_DOOR && itemDefs.at(magplantid).blockType != BlockTypes::SIGN && itemDefs.at(magplantid).blockType != BlockTypes::DOOR && itemDefs.at(magplantid).blockType != BlockTypes::CHECKPOINT && itemDefs.at(magplantid).blockType != BlockTypes::GATEWAY && itemDefs.at(magplantid).blockType != BlockTypes::TREASURE && itemDefs.at(magplantid).blockType != BlockTypes::WEATHER) return;
							}
						}
						if (world->isPublic || isWorldAdmin(peer, world) || ((PlayerInfo*)(peer->data))->rawName == world->owner || world->owner == "" || isDev(peer)) {
							world->items.at(x + (y * world->width)).foreground = magplantid;
							world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).fruitcount -= 1;
							PlayerMoving data3{};
							data3.packetType = 0x3;
							data3.characterState = 0x0;
							data3.x = x;
							data3.y = y;
							data3.punchX = x;
							data3.punchY = y;
							data3.netID = -1;
							data3.plantingTree = magplantid;
							for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
								if (isHere(peer, currentPeer)) {
									auto raw = packPlayerMoving(&data3);
									raw[2] = dicenr;
									raw[3] = dicenr;
									SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
								if (isHere(peer, currentPeer)) {
									if (world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).fruitcount <= 0) {
										sendMag(currentPeer, 5638, ((PlayerInfo*)(peer->data))->magplantx, ((PlayerInfo*)(peer->data))->magplanty, world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).intdata, 0, true, true, world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).background);
									}
									else if (world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).fruitcount >= 5000) {
										sendMag(currentPeer, 5638, ((PlayerInfo*)(peer->data))->magplantx, ((PlayerInfo*)(peer->data))->magplanty, world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).intdata, -1, true, true, world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).background);
									}
									else {
										sendMag(currentPeer, 5638, ((PlayerInfo*)(peer->data))->magplantx, ((PlayerInfo*)(peer->data))->magplanty, world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).intdata, 1, true, true, world->items.at(((PlayerInfo*)(peer->data))->magplantx + (((PlayerInfo*)(peer->data))->magplanty * world->width)).background);
									}
								}
							}
						}
					}
					else {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wThe `2MAGPLANT 5000 `wis empty!", 0);
					}
				}
			}
			return;
		}
		if (getItemDef(tile).blockType == BlockTypes::SEED && !world->items.at(x + (y * world->width)).fire) {
			if (((PlayerInfo*)(peer->data))->lqueststep == 5 && ((PlayerInfo*)(peer->data))->lquestprogress < 50000) {
				if (getItemDef(tile).rarity != 999) {
					int plusItem = ((PlayerInfo*)(peer->data))->lquestprogress + getItemDef(tile).rarity;
					if (plusItem > 50000) {
						((PlayerInfo*)(peer->data))->lquestprogress = 50000;
						FlushPlayer(peer);
					}
					else {
						((PlayerInfo*)(peer->data))->lquestprogress = ((PlayerInfo*)(peer->data))->lquestprogress += getItemDef(tile).rarity;
						FlushPlayer(peer);
					}
				}
			}
			if (((PlayerInfo*)(peer->data))->lqueststep == 5 && ((PlayerInfo*)(peer->data))->lquestprogress > 49999) {
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`9Legendary Quest step complete! I'm off to see a Wizard!", 0);
				Player::OnConsoleMessage(peer, "`9Legendary Quest step complete! I'm off to see a Wizard!");
			}
			if (world->items.at(x + (y * world->width)).foreground != 0) {
				if (getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::SEED) {
					if (world->isPublic || isWorldAdmin(peer, world) || ((PlayerInfo*)(peer->data))->rawName == world->owner || world->owner == "" || isDev(peer)) {
						if (calcBanDuration(world->items.at(x + (y * world->width)).growtime) == 0) {
							Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "This tree is already too big to splice another seed with.", 0);
							return;
						}
						if (getItemDef(world->items.at(x + (y * world->width)).foreground).name == getItemDef(tile).name || getItemDef(world->items.at(x + (y * world->width)).foreground).rarity == 999 || getItemDef(tile).rarity == 999) {
							Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Hmm, it looks like `w" + getItemDef(world->items.at(x + (y * world->width)).foreground).name + "`` and `w" + getItemDef(tile).name + "`` can't be spliced.", 1);
							return;
						}
						if (HasItemsInInv(peer, tile, 1) == -1) return;
						if (!world->items.at(x + (y * world->width)).spliced) {
							auto targetvalue = getItemDef(world->items.at(x + (y * world->width)).foreground).rarity + getItemDef(tile).rarity;
							for (auto i = 0; i < 10016; i++) {
								if (getItemDef(i).rarity == targetvalue) {
									RemoveItemFromInv(peer, tile, 1, true);
									world->items.at(x + (y * world->width)).spliced = true;
									Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`w" + getItemDef(world->items.at(x + (y * world->width)).foreground).name + "`` and `w" + getItemDef(tile).name + "`` have been spliced to make a `$" + getItemDef(i + 1).name + "``!", 0);
									Player::PlayAudio(peer, "audio/success.wav", 0);
									world->items.at(x + (y * world->width)).foreground = i + 1;
									int growTimeSeed = getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity;
									growTimeSeed += 30 * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 954) growTimeSeed = 1800;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 340) growTimeSeed = 3600;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 5666) growTimeSeed = 2700;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 4584) growTimeSeed = 2400;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 4762) growTimeSeed = 14544;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 7382) growTimeSeed = 22544;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 9460) growTimeSeed = 29544;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 9468) growTimeSeed = 36544;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 10024) growTimeSeed = 56544;
									if (world->items.at(x + (y * world->width)).foreground - 1 == 10028) growTimeSeed = 86400;
									world->items.at(x + (y * world->width)).growtime = (GetCurrentTimeInternalSeconds() + growTimeSeed);
									if (getItemDef(world->items.at(x + (y * world->width)).foreground).rarity == 999) {
										world->items.at(x + (y * world->width)).fruitcount = (rand() % 1) + 1;
									}
									else {
										world->items.at(x + (y * world->width)).fruitcount = (rand() % 3) + 1;
									}
									if (getItemDef(world->items.at(x + (y * world->width)).foreground - 1).blockType == BlockTypes::CLOTHING) world->items.at(x + (y * world->width)).fruitcount = 1;
									PlayerMoving data3;
									data3.packetType = 0x3;
									data3.characterState = 0x0;
									data3.x = x;
									data3.y = y;
									data3.punchX = x;
									data3.punchY = y;
									data3.netID = -1;
									data3.plantingTree = i + 1;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (isHere(peer, currentPeer)) {
											auto raw = packPlayerMoving(&data3);
											raw[2] = dicenr;
											raw[3] = dicenr;
											SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									UpdateTreeVisuals(peer, world->items.at(x + (y * world->width)).foreground, x, y, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).fruitcount, 0, true, 0, world);
									break;
								}
								else if (i >= 10015) {
									Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Hmm, it looks like `w" + getItemDef(world->items.at(x + (y * world->width)).foreground).name + "`` and `w" + getItemDef(tile).name + "`` can't be spliced.", 0);
									break;
								}
							}
						}
						else {
							Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "It would be too dangerous to try to mix three seeds.", 0);
						}
					}
					return;
				}
			}
			else {
				isTree = true;
			}
		}
		if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::GATEWAY && tile == 32)
		{
			if (world->owner != "") {
				if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || adminLevel(peer) > 1) {
					if (world->items[x + (y * world->width)].entrance_open)
					{
						Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(getItemDef(world->items[x + (y * world->width)].foreground).id) + "|\n\nadd_checkbox|public|Is open to public|1\nend_dialog|change_block|Cancel|OK|");
					}
					else
					{
						Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(getItemDef(world->items[x + (y * world->width)].foreground).id) + "|\n\nadd_checkbox|public|Is open to public|0\nend_dialog|change_block|Cancel|OK|");
					}
					((PlayerInfo*)(peer->data))->wrenchedBlockLocation = x + (y * world->width);
				}
			}
			else {
				Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(world->items[x + (y * world->width)].foreground) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nend_dialog|change_block|Cancel|OK|");
			}
		}
		if (tile == 2978 || tile == 9268) /*vend*/
		{
			if (world->owner == "" || isWorldOwner(peer, world) || isDev(peer) || isWorldAdmin(peer, world)) {
				VendUpdate = true;
				world->items.at(x + (y * world->width)).intdata = 0;
				world->items.at(x + (y * world->width)).growtime = 0;
				world->items.at(x + (y * world->width)).fruitcount = 0;
				world->items.at(x + (y * world->width)).vdraw = 0;
				world->items.at(x + (y * world->width)).opened = true;
				world->items.at(x + (y * world->width)).rm = false;
				SaveBlockState(world, peer, x, y);
			}
		}
		if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::SUCKER && tile == 32) {
			if (world->isPublic) return;
			int squaresign = x + (y * world->width);
			string currentworld = ((PlayerInfo*)(peer->data))->currentWorld + "X" + std::to_string(squaresign);
			string Sucker = "";
			if (world->items.at(x + (y * world->width)).foreground == 5638) {
				Sucker = "magplant";
				((PlayerInfo*)(peer->data))->suckername = "magplant";
				((PlayerInfo*)(peer->data))->suckerid = 5638;
			}
			if (world->items.at(x + (y * world->width)).foreground == 6946) {
				Sucker = "gaiabeacon";
				((PlayerInfo*)(peer->data))->suckername = "gaiabeacon";
				((PlayerInfo*)(peer->data))->suckerid = 6946;
			}
			if (world->items.at(x + (y * world->width)).foreground == 6948) {
				Sucker = "unstabletesseract";
				((PlayerInfo*)(peer->data))->suckername = "unstabletesseract";
				((PlayerInfo*)(peer->data))->suckerid = 6948;
			}
			((PlayerInfo*)(peer->data))->lastPunchX = x;
			((PlayerInfo*)(peer->data))->lastPunchY = y;
			if (((PlayerInfo*)(peer->data))->rawName != world->owner && !isDev(peer)) {
				if (world->items.at(x + (y * world->width)).rm) {
					string label = "`6The machine is currently empty!";
					string RemoteDialog = "";
					if (world->items.at(x + (y * world->width)).fruitcount >= 1) {
						RemoteDialog = "\nadd_textbox|`oUse the " + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + " Remote to build `2" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + " `odirectly from the " + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "'s storage.|\nadd_button|getremote|`oGet Remote|";
						label = "`oThe machine contains " + to_string(world->items.at(x + (y * world->width)).fruitcount) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + "";
					}
					Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|small|`5" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + "|left|" + to_string(world->items.at(x + (y * world->width)).intdata) + "|\nadd_textbox|" + label + "|" + RemoteDialog + "|\nend_dialog|magplantupdate|Close||");
				}
				return;
			}
			if (world->items.at(x + (y * world->width)).intdata != 0) {
				string label = "`6The machine is currently empty!";
				string RemoteDialog = "";
				string publicremotecheck = "";
				string gemDialog = "";
				bool Farmable = false;
				if (world->items.at(x + (y * world->width)).intdata == 7382 || world->items.at(x + (y * world->width)).intdata == 4762 || world->items.at(x + (y * world->width)).intdata == 5140 || world->items.at(x + (y * world->width)).intdata == 5138 || world->items.at(x + (y * world->width)).intdata == 5136 || world->items.at(x + (y * world->width)).intdata == 5154 || world->items.at(x + (y * world->width)).intdata == 340 || world->items.at(x + (y * world->width)).intdata == 954 || world->items.at(x + (y * world->width)).intdata == 5666) Farmable = true;
				if (Sucker == "magplant" && itemDefs.at(world->items.at(x + (y * world->width)).intdata).blockType == BlockTypes::FOREGROUND || Sucker == "magplant" && Farmable || Sucker == "magplant" && itemDefs.at(world->items.at(x + (y * world->width)).intdata).blockType == BlockTypes::BACKGROUND || Sucker == "magplant" && itemDefs.at(world->items.at(x + (y * world->width)).intdata).blockType == BlockTypes::GROUND_BLOCK) {
					if (itemDefs.at(world->items.at(x + (y * world->width)).intdata).properties & Property_AutoPickup) {
						/*...*/
					}
					else {
						if (world->items.at(x + (y * world->width)).rm) {
							publicremotecheck = "\nadd_checkbox|checkbox_publicremote|`oAllow visitors to take remote|1|";
						}
						else {
							publicremotecheck = "\nadd_checkbox|checkbox_publicremote|`oAllow visitors to take remote|0|";
						}
						RemoteDialog = "\nadd_textbox|`oUse the " + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + " Remote to build `2" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + " `odirectly from the " + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "'s storage.|\nadd_button|getremote|`oGet Remote|";
					}
				}
				if (world->items.at(x + (y * world->width)).fruitcount >= 1) {
					label = "`oThe machine contains " + to_string(world->items.at(x + (y * world->width)).fruitcount) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + ""; /*The message if something exists in item sucker*/
					Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|small|`5" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + "|left|" + to_string(world->items.at(x + (y * world->width)).intdata) + "|\nadd_textbox|" + label + "|\nadd_button|retrieveitem|`oRetrieve Items|" + RemoteDialog + "|" + publicremotecheck + "|\nend_dialog|magplantupdate|Close|`wUpdate|");
				}
				else {
					Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|small|`5" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + "|left|" + to_string(world->items.at(x + (y * world->width)).intdata) + "|\nadd_textbox|" + label + "|\nadd_item_picker|magplantitem|Change Item|Choose an item to put in the " + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "!|" + publicremotecheck + "|" + gemDialog + "\nend_dialog|magplantupdate|Close|`wUpdate|");
				}
			}
			else {
				if (Sucker == "magplant") Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_textbox|`6The machine is empty.|\nadd_item_picker|magplantitem|Choose Item|Choose an item to put in the " + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "!|\nend_dialog|magplantcheck|Close|`wUpdate|");
				else Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_textbox|`6The machine is empty.|\nadd_item_picker|magplantitem|Choose Item|Choose an item to put in the " + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "!|\nend_dialog|magplant|Close||");
			}
			return;
		}
		if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::VENDING && tile == 32)
		{
			if (x == ((PlayerInfo*)(peer->data))->x / 32 && y == ((PlayerInfo*)(peer->data))->y / 32)
			{
				((PlayerInfo*)(peer->data))->lastPunchX = x;
				((PlayerInfo*)(peer->data))->lastPunchY = y;
				if (world->owner == "" || isWorldOwner(peer, world) || isDev(peer)) {
					try {
						int x = ((PlayerInfo*)(peer->data))->lastPunchX;
						int y = ((PlayerInfo*)(peer->data))->lastPunchY;
						int squaresign = x + (y * world->width);
						string type = "";
						if (world->items.at(x + (y * world->width)).rm) {
							type = "\nadd_checkbox|chk_peritem|World Locks per Item|1\nadd_checkbox|chk_perlock|Items per World Lock|0";
						}
						if (world->items.at(x + (y * world->width)).opened) {
							type = "\nadd_checkbox|chk_peritem|World Locks per Item|0\nadd_checkbox|chk_perlock|Items per World Lock|1";
						}
						if (world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).opened) {
							type = "\nadd_checkbox|chk_peritem|World Locks per Item|1\nadd_checkbox|chk_perlock|Items per World Lock|1";
						}
						string currentworld = ((PlayerInfo*)(peer->data))->currentWorld + "X" + std::to_string(squaresign);
						string withdrawdialog = "";
						if (world->items.at(x + (y * world->width)).vdraw > 0) withdrawdialog = "\nadd_smalltext|`oYou have earned " + to_string(world->items.at(x + (y * world->width)).vdraw) + " World Locks.``|left|\nadd_button|withdraw|Withdraw World Locks|";
						if (world->items.at(x + (y * world->width)).fruitcount == 0 || world->items.at(x + (y * world->width)).intdata == 0) {
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_textbox|This machine is empty.|left|\nadd_item_picker|stockitem|`wPut an item in``|Choose an item to put in the machine!|" + withdrawdialog + "|\nend_dialog|vending|Close||");
						}
						else if (world->items.at(x + (y * world->width)).intdata != 0) {
							string addthemdialog = "";
							auto mtitems = 0;
							for (auto i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == world->items.at(x + (y * world->width)).fruitcount) {
									mtitems = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
									break;
								}
							}
							if (mtitems != 0) {
								addthemdialog = "\nadd_smalltext|`oYou have " + to_string(mtitems) + " " + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + " in your backpack.``|left|\nadd_button|addvend|Add them to the machine|";
							}
							string saledialog = "\nadd_textbox|Not currently for sale!|left|";
							if (world->items.at(x + (y * world->width)).growtime != 0) {
								if (world->items.at(x + (y * world->width)).opened) saledialog = "\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|1 x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|";
								else saledialog = "\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|1 x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|";
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|" + saledialog + "|" + addthemdialog + "|\nadd_button|pullstock|Empty the machine|noflags|0|0|\nadd_smalltext|`5(" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + to_string(world->items.at(x + (y * world->width)).growtime) + "|5|" + type + "|" + withdrawdialog + "|\nend_dialog|vending|Close|Update|");
						}
						else if (world->items.at(x + (y * world->width)).intdata != 0 && world->items.at(x + (y * world->width)).growtime != 0) {
							if (world->items.at(x + (y * world->width)).opened) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|1 x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_button|pullstock|Empty the machine|noflags|0|0|\nadd_smalltext|`5(" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + to_string(world->items.at(x + (y * world->width)).growtime) + "|5|" + type + "|" + withdrawdialog + "|\nend_dialog|vending|Close|Update|");
							else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|1 x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_button|pullstock|Empty the machine|noflags|0|0|\nadd_smalltext|`5(" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + to_string(world->items.at(x + (y * world->width)).growtime) + "|5|" + type + "|" + withdrawdialog + "|\nend_dialog|vending|Close|Update|");
						}
					}
					catch (std::exception& e) {
						std::cout << e.what() << std::endl;
					}
					catch (const std::out_of_range& e) {
						std::cout << e.what() << std::endl;
					}
					return;
				}
				try {
					int x = ((PlayerInfo*)(peer->data))->lastPunchX;
					int y = ((PlayerInfo*)(peer->data))->lastPunchY;
					int squaresign = x + (y * world->width);
					string currentworld = ((PlayerInfo*)(peer->data))->currentWorld + "X" + std::to_string(squaresign);
					if (world->items.at(x + (y * world->width)).fruitcount == 0 || world->items.at(x + (y * world->width)).intdata == 0 || world->items.at(x + (y * world->width)).growtime == 0 || world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime && world->items.at(x + (y * world->width)).opened) {
						Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_textbox|This machine is out of order.|left|\nend_dialog|vending|Close||");
					}
					else if (world->items.at(x + (y * world->width)).intdata != 0 && world->items.at(x + (y * world->width)).growtime == 0) {
						if (world->items.at(x + (y * world->width)).opened) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|1 x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|You'll need to wait for the owner to stock up to at least 1 World Lock's worth before you can buy.|left|\nend_dialog|vending|Close||");
						else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|1 x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|You'll need to wait for the owner to stock up to at least 1 World Lock's worth before you can buy.|left|\nend_dialog|vending|Close||");
					}
					else if (world->items.at(x + (y * world->width)).intdata != 0) {
						auto worldlocks = 0;
						auto diamondlocks = 0;
						auto locks = 0;
						for (auto i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
							if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242) {
								worldlocks = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
							}
							if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1796) {
								diamondlocks = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
							}
						}
						if (diamondlocks > 0) {
							locks = diamondlocks * 100;
						}
						locks += worldlocks;
						if (world->items.at(x + (y * world->width)).opened) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|1 x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|You have " + to_string(locks) + " World Locks.|left|\nadd_text_input|buycount|How many would you like to buy?|0|3|\nend_dialog|vending|Close|Buy|");
						else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|1 x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|You have " + to_string(locks) + " World Locks.|left|\nadd_text_input|buycount|How many would you like to buy?|0|3|\nend_dialog|vending|Close|Buy|");
					}
				}
				catch (std::exception& e) {
					std::cout << e.what() << std::endl;
				}
				catch (const std::out_of_range& e) {
					std::cout << e.what() << std::endl;
				}
			}
			else {
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wGet closer!", 0);
			}
			return;
		}
		if (world->items.at(x + (y * world->width)).foreground == 10 && tile == 3400)
		{
			if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || adminLevel(peer) > 1 || world->owner == "") {
				RemoveItemFromInv(peer, 3400, 1, true);
				world->items.at(x + (y * world->width)).foreground = 392;
				PlayerMoving data3{};
				data3.packetType = 0x3;
				data3.characterState = 0x0;
				data3.x = x;
				data3.y = y;
				data3.punchX = x;
				data3.punchY = y;
				data3.netID = -1;
				data3.plantingTree = 392;
				ENetPeer* currentPeer;
				for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
					if (isHere(peer, currentPeer))
					{
						SendPacketRaw(4, packPlayerMoving(&data3), 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
						Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
					}
				}
			}
		}
		if (((PlayerInfo*)(peer->data))->cloth_hand == 3066 && tile == 18) {
			if (world->items.at(x + (y * world->width)).fire) {
				world->items.at(x + (y * world->width)).fire = false;
				UpdateBlockState(peer, x, y, true, world);
				SaveBlockState(world, peer, x, y);
				for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
					if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
					if (isHere(peer, net_peer)) {
						Player::OnParticleEffect(net_peer, 149, x * 32, y * 32, 0);
					}
				}
				return;
			}
			else {
			}
		}
		if (((PlayerInfo*)(peer->data))->cloth_hand == 4996 && !world->items.at(x + (y * world->width)).fire && tile == 18) {
			if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED || world->items.at(x + (y * world->width)).water || world->items.at(x + (y * world->width)).foreground == 6952 || world->items.at(x + (y * world->width)).foreground == 6954 || world->items.at(x + (y * world->width)).foreground == 5638 || world->items.at(x + (y * world->width)).foreground == 6946 || world->items.at(x + (y * world->width)).foreground == 6948 || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::VENDING || world->items.at(x + (y * world->width)).foreground == 1420 || world->items.at(x + (y * world->width)).foreground == 6214 || world->items.at(x + (y * world->width)).foreground == 1006 || world->items.at(x + (y * world->width)).foreground == 656 || world->items.at(x + (y * world->width)).foreground == 1420 || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::DONATION || world->items.at(x + (y * world->width)).foreground == 3528 || world->items.at(x + (y * world->width)).foreground == 0 && world->items.at(x + (y * world->width)).background == 6864 || world->items.at(x + (y * world->width)).foreground == 0 && world->items.at(x + (y * world->width)).background == 0 || world->items.at(x + (y * world->width)).foreground == 6 || world->items.at(x + (y * world->width)).foreground == 8 || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::LOCK || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::DISPLAY) {
				if (world->items.at(x + (y * world->width)).background != 6864) Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wCan't burn that!", 0);
				return;
			}
			world->items.at(x + (y * world->width)).fire = true;
			for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
				if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
				if (isHere(peer, net_peer)) {
					Player::OnParticleEffect(net_peer, 150, x * 32 + 16, y * 32 + 16, 0);
				}
			}
			UpdateBlockState(peer, x, y, true, world);
			SaveBlockState(world, peer, x, y);
			return;
		}
		if (world->items[x + (y * world->width)].foreground == 656 && tile == 18 || world->items[x + (y * world->width)].foreground == 1006 && tile == 18) {
			auto squaresign = x + (y * world->width);
			auto isdbox = std::experimental::filesystem::exists("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
			if (isdbox) {
				ifstream ifff("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
				json j;
				ifff >> j;
				ifff.close();
				int count = j["inmail"];
				if (j["inmail"] > 0) {
					Player::OnTalkBubble(peer, netID, "`wThere are `5" + to_string(count) + " `wletter(s) in the mailbox.", 0);
				}
			}
		}
		if (world->items[x + (y * world->width)].foreground == 656 && tile == 32 || world->items[x + (y * world->width)].foreground == 1006 && tile == 32) {
			auto squaresign = x + (y * world->width);
			auto isdbox = std::experimental::filesystem::exists("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
			if (!isdbox)
			{
				Player::OnTalkBubble(peer, netID, "`4An error occured. Break the mailbox.", 0);
			}
			else
			{
				((PlayerInfo*)(peer->data))->lastPunchX = x;
				((PlayerInfo*)(peer->data))->lastPunchY = y;
				if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isDev(peer))
				{
					GTDialog myLetterBox;
					myLetterBox.addLabelWithIcon("`wMail Box", 656, LABEL_BIG);
					ifstream ifff("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
					json j;
					ifff >> j;
					ifff.close();
					if (j["inmail"] <= 0)
					{
						myLetterBox.addTextBox("`oThe mailbox is currently empty.");
					}
					else
					{
						int donated = j["inmail"];

						myLetterBox.addTextBox("`oYou have `w" + to_string(donated) + " `oletters:");
						myLetterBox.addSpacer(SPACER_SMALL);
						for (int i = 0; i < 20; i++)
						{
							if (j["mails"].at(i)["growid"] != "")
							{
								myLetterBox.addLabelWithIcon("`5\"" + j["mails"].at(i)["text"].get<string>() + "\" - `w" + j["mails"].at(i)["growid"].get<string>() + "", 660, LABEL_SMALL);
								myLetterBox.addSpacer(SPACER_SMALL);
							}
						}
						myLetterBox.addSpacer(SPACER_SMALL);
						myLetterBox.addButton("mailempty_" + to_string(squaresign), "`4Empty mailbox");
					}
					myLetterBox.addTextBox("`oWrite a letter to yourself?");
					myLetterBox.addInputBox("addletterinput_" + to_string(squaresign), "", "", 50);
					myLetterBox.addSpacer(SPACER_SMALL);
					myLetterBox.addButton("addletter", "`2Send Letter");
					myLetterBox.addSpacer(SPACER_SMALL);
					myLetterBox.addQuickExit();
					myLetterBox.endDialog("Close", "", "Cancel");
					Player::OnDialogRequest(peer, myLetterBox.finishDialog());
				}
				else
				{
					GTDialog myLetterBox;
					myLetterBox.addLabelWithIcon("`wMail Box", 656, LABEL_BIG);
					ifstream ifff("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
					json j;
					ifff >> j;
					ifff.close();

					myLetterBox.addTextBox("`$Want to leave a message for the owner?");
					myLetterBox.addSpacer(SPACER_SMALL);
					myLetterBox.addInputBox("addletterinput_" + to_string(squaresign), "", "", 50);
					myLetterBox.addSpacer(SPACER_SMALL);
					myLetterBox.addButton("addletter", "`2Send Letter");

					myLetterBox.addSpacer(SPACER_SMALL);
					myLetterBox.addQuickExit();
					myLetterBox.endDialog("Close", "", "Cancel");
					Player::OnDialogRequest(peer, myLetterBox.finishDialog());
				}
			}
			return;
		}
		if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::DONATION && tile == 32)
		{
			auto squaresign = x + (y * world->width);
			auto isdbox = std::experimental::filesystem::exists("donationboxes/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
			if (!isdbox)
			{
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`4An error occured. Break the donation box.", 0);
			}
			else
			{
				((PlayerInfo*)(peer->data))->lastPunchX = x;
				((PlayerInfo*)(peer->data))->lastPunchY = y;
				((PlayerInfo*)(peer->data))->lastPunchForeground = world->items.at(x + (y * world->width)).foreground;
				((PlayerInfo*)(peer->data))->lastPunchBackground = world->items.at(x + (y * world->width)).background;
				if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isDev(peer))
				{
					GTDialog myDbox;
					myDbox.addLabelWithIcon("`wDonation Box", world->items.at(x + (y * world->width)).foreground, LABEL_BIG);
					ifstream ifff("donationboxes/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
					json j;
					ifff >> j;
					ifff.close();
					if (j["donated"] <= 0)
					{
						myDbox.addTextBox("`$The box is currently empty.");
					}
					else
					{
						int donated = j["donated"];
						int count = 0;
						myDbox.addTextBox("`oYou have `w" + to_string(donated) + " `ogifts waiting:");
						myDbox.addSpacer(SPACER_SMALL);
						for (int i = 0; i < 20; i++)
						{
							if (j["donatedItems"].at(i)["itemid"] != 0)
							{
								count = j["donatedItems"].at(i)["itemcount"];
								myDbox.addLabelWithIcon("`o" + itemDefs.at(j["donatedItems"].at(i)["itemid"]).name + " (`w" + to_string(count) + "`o) from `w" + j["donatedItems"].at(i)["sentBy"].get<string>() + "`#- \"" + j["donatedItems"].at(i)["note"].get<string>() + "\"", j["donatedItems"].at(i)["itemid"], LABEL_SMALL);
								myDbox.addSpacer(SPACER_SMALL);
							}
						}
						myDbox.addSpacer(SPACER_SMALL);
						myDbox.addButton("retrieveGifts_" + to_string(squaresign), "`4Retrieve Gifts");
					}
					myDbox.addSpacer(SPACER_SMALL);
					myDbox.addPicker("addDonationItem_" + to_string(squaresign), "`wGive Gift `o(Min rarity: `52`o)", "Select an item");
					myDbox.addSpacer(SPACER_SMALL);
					myDbox.addQuickExit();
					myDbox.endDialog("Close", "", "Cancel");
					Player::OnDialogRequest(peer, myDbox.finishDialog());
				}
				else
				{
					GTDialog myDbox;
					myDbox.addLabelWithIcon("`wDonation Box", world->items.at(x + (y * world->width)).foreground, LABEL_BIG);
					ifstream ifff("donationboxes/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + std::to_string(squaresign) + ".json");
					json j;
					ifff >> j;
					ifff.close();

					int donated = j["donated"];

					myDbox.addTextBox("`$You see `w" + to_string(donated) + "`$ gifts in the box!");
					myDbox.addTextBox("`$Want to leave a gift for the owner?");
					myDbox.addSpacer(SPACER_SMALL);

					myDbox.addPicker("addDonationItem_" + to_string(squaresign), "`wGive Gift `o(Min rarity: `52`o)", "Select an item");

					myDbox.addSpacer(SPACER_SMALL);
					myDbox.addQuickExit();
					myDbox.endDialog("Close", "", "Cancel");
					Player::OnDialogRequest(peer, myDbox.finishDialog());
				}
			}
			return;
		}
		if (world->items[x + (y * world->width)].foreground == 758) sendRoulete(peer);

		if (world->items.at(x + (y * world->width)).foreground == 2946 && tile != 18 && tile != 32 && tile > 0) {
			if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1) {

				world->items.at(x + (y * world->width)).intdata = tile;
				SendThrowEffect(peer, tile, netID, -1, 150, 0, x * 32 + 16, y * 32 + 16);
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;


			}

		}
		int fg = world->items.at(x + (y * world->width)).foreground;
		int bg = world->items.at(x + (y * world->width)).background;

		if (world->items.at(x + (y * world->width)).foreground == 3528 && tile == 32) {
			if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || adminLevel(peer) > 1 || world->owner == "") {
				string ItemName = "\nadd_textbox|`oThe canvas is blank.|left|"; string text = "\nadd_text_input|arttest|Signed: |" + getItemDef(world->items.at(x + (y * world->width)).intdata).name + "|35|";
				if (world->items.at(x + (y * world->width)).intdata != 0) {
					ItemName = "\nadd_textbox|`oThis is a lovely still-life of " + getItemDef(world->items.at(x + (y * world->width)).intdata).name + "|left|";
				}
				if (world->items.at(x + (y * world->width)).sign != "") {
					text = "\nadd_text_input|arttest|Signed: |" + world->items.at(x + (y * world->width)).sign + "|35|";
				}
				Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wArt Canvas|left|3528|\nadd_spacer|small|" + ItemName + "|\nadd_item_picker|art_pick|`wErase Painting|Select an item to paint|\nadd_smalltext|`5(Painting costs 2 Paint Bucket of each color)|left|" + text + "|\nend_dialog|art_update|Cancel|Update|");
				((PlayerInfo*)(peer->data))->wrenchedBlockLocation = x + (y * world->width);
			}
		}



		PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));




		if (tile == 18) {
			if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::TOGGLE_FOREGROUND || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SWITCH_BLOCK || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::CHEST || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::RANDOM_BLOCK) {
				if (world->owner == "" || isWorldOwner(peer, world) || pinfo->adminLevel > 1 || world->items[x + (y * world->width)].opened) {
					updateState = true;
				}
				else
				{
					//Player::OnTalkBubble(peer, netID, "This Area Locked by " + world->owner + "", true);
					return;
				}
			}
		}

		if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::TOGGLE_FOREGROUND || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SWITCH_BLOCK || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::CHEST || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::RANDOM_BLOCK) {
			if (tile == 32) {
				if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel >= 2) {
					((PlayerInfo*)(peer->data))->lastPunchX = x;
					((PlayerInfo*)(peer->data))->lastPunchY = y;
					if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SWITCH_BLOCK)
					{
						((PlayerInfo*)(peer->data))->lastPunchX = x;
						((PlayerInfo*)(peer->data))->lastPunchY = y;
						Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(world->items[x + (y * world->width)].foreground) + "|\nadd_checkbox|checkbox_public|Usable by public|" + to_string(world->items[x + (y * world->width)].opened) + "\nend_dialog|toggleshit|Cancel|OK|");
					}
					if (world->owner != "")
					{
						if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::TOGGLE_FOREGROUND || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::RANDOM_BLOCK)
						{
							((PlayerInfo*)(peer->data))->lastPunchX = x;
							((PlayerInfo*)(peer->data))->lastPunchY = y;
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(world->items[x + (y * world->width)].foreground) + "|\nadd_checkbox|checkbox_public|Usable by public|" + to_string(world->items[x + (y * world->width)].opened) + "\nadd_checkbox|checkbox_silenced|Silenced|" + to_string(world->items[x + (y * world->width)].silenced) + "\nend_dialog|toggleshit|Cancel|OK|");
						}
						return;
					}
					else
					{
						if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::TOGGLE_FOREGROUND)
						{
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(world->items[x + (y * world->width)].foreground) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nend_dialog|switcheroo_edits|Cancel|OK|");

						}
						return;
					}
				}
			}
		}

		// fist 
		if (tile == 18) {
			if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || adminLevel(peer) > 1 || world->owner == "") {
				std::ifstream infile("weathers.txt");
				for (std::string line; getline(infile, line);)
				{
					vector<string> ex = explode("|", line);
					if (world->items.at(x + (y * world->width)).foreground == stoi(ex.at(0)))
					{
						ENetPeer* currentPeer;
						if (world->weather != stoi(ex.at(1))) world->weather = stoi(ex.at(1));
						else world->weather = 0;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
								continue;
							if (isHere(peer, currentPeer))
							{
								world->items.at(x + (y * world->width)).activeWeather = true;
								GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
								ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(currentPeer, 0, packet2);
								delete p2.data;
								continue;
							}
						}
					}
				}
			}
		}

		//

		if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED && calcBanDuration(world->items.at(x + (y * world->width)).growtime) == 0 && ((PlayerInfo*)(peer->data))->cloth_hand != 3066 && tile == 18) {
			if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || adminLevel(peer) > 1 || world->owner == "") {
				for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
					if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
					if (isHere(peer, net_peer)) {
						treeModify(net_peer, x, y, ((PlayerInfo*)(peer->data))->netID);
					}
				}
				auto chance = (rand() % 100) + 1;
				int numb = world->items.at(x + (y * world->width)).fruitcount;
				if (chance < 15 && getItemDef(world->items.at(x + (y * world->width)).foreground).rarity != 999) {
					if (getItemDef(world->items.at(x + (y * world->width)).foreground - 1).blockType != BlockTypes::CLOTHING) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "A " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " seed falls out!", 0);
						dropItem(world, peer, -1, x * 32 - (rand() % 8), y * 32 + (rand() % 8), world->items.at(x + (y * world->width)).foreground, 1, 0);
					}
				}
				if (((PlayerInfo*)(peer->data))->cloth_hand == 6840) {
					auto chance1 = (rand() % 100) + 1;
					if (chance1 <= 30) {
						numb += 1;
						Player::OnParticleEffect(peer, 49, data.punchX * 32, data.punchY * 32, 0);
					}
				}
				dropItem(world, peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), world->items.at(x + (y * world->width)).foreground - 1, numb, 0);
				if (pinfo->lqueststep == 15 && pinfo->lquestprogress < 100000) {
					if (getItemDef(world->items.at(x + (y * world->width)).foreground).rarity != 999) {
						int plusItem = ((PlayerInfo*)(peer->data))->lquestprogress + getItemDef(world->items.at(x + (y * world->width)).foreground).rarity;
						if (plusItem > 100000) {
							((PlayerInfo*)(peer->data))->lquestprogress = 100000;
							FlushPlayer(peer);
						}
						else {
							pinfo->lquestprogress = pinfo->lquestprogress += getItemDef(world->items.at(x + (y * world->width)).foreground).rarity;
							FlushPlayer(peer);
						}
					}
				}
				if (pinfo->lqueststep == 15 && pinfo->lquestprogress > 99999) {
					Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`9Legendary Quest step complete! I'm off to see a Wizard!", 0);
					Player::OnConsoleMessage(peer, "`9Legendary Quest step complete! I'm off to see a Wizard!");
				}
				world->items.at(x + (y * world->width)).spliced = false;
				world->items.at(x + (y * world->width)).growtime = 0;
				world->items.at(x + (y * world->width)).fruitcount = 0;
				world->items.at(x + (y * world->width)).foreground = 0;
				return;
			}
			return;
		}
		if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED && tile == 228 || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED && tile == 1778) {
			if (calcBanDuration(world->items[x + (y * world->width)].growtime) == 0) {
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "This tree has already bloomed, don't waste your spray on it!", 0);
				return;
			}
			int NewGrowTime = 0;
			int InternalGrowTime = 0;
			if (tile == 228) {
				NewGrowTime = calcBanDuration(world->items[x + (y * world->width)].growtime) - 3600;
				RemoveItemFromInv(peer, 228, 1, true);
			}
			if (tile == 1778) {
				NewGrowTime = calcBanDuration(world->items[x + (y * world->width)].growtime) - 86400;
				RemoveItemFromInv(peer, 1778, 1, true);
			}
			if (NewGrowTime < 0) NewGrowTime = 0;
			world->items[x + (y * world->width)].growtime = (GetCurrentTimeInternalSeconds() + NewGrowTime);
			int growTimeSeed = getItemDef(world->items[x + (y * world->width)].foreground - 1).rarity * getItemDef(world->items[x + (y * world->width)].foreground - 1).rarity * getItemDef(world->items[x + (y * world->width)].foreground - 1).rarity;
			growTimeSeed += 30 * getItemDef(world->items[x + (y * world->width)].foreground - 1).rarity;
			if (world->items[x + (y * world->width)].foreground - 1 == 954) growTimeSeed = 1800;
			if (world->items[x + (y * world->width)].foreground - 1 == 340) growTimeSeed = 3600;
			if (world->items[x + (y * world->width)].foreground - 1 == 5666) growTimeSeed = 2700;
			if (world->items[x + (y * world->width)].foreground - 1 == 4584) growTimeSeed = 2400;
			if (world->items[x + (y * world->width)].foreground - 1 == 4762) growTimeSeed = 14544;
			if (world->items[x + (y * world->width)].foreground - 1 == 7382) growTimeSeed = 22544;
			if (world->items[x + (y * world->width)].foreground - 1 == 9460) growTimeSeed = 29544;
			if (world->items[x + (y * world->width)].foreground - 1 == 9468) growTimeSeed = 36544;
			if (world->items[x + (y * world->width)].foreground - 1 == 10024) growTimeSeed = 56544;
			if (world->items[x + (y * world->width)].foreground - 1 == 10028) growTimeSeed = 86400;
			InternalGrowTime = growTimeSeed - calcBanDuration(world->items[x + (y * world->width)].growtime);
			UpdateTreeVisuals(peer, world->items[x + (y * world->width)].foreground, x, y, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].fruitcount, InternalGrowTime, true, 0, world);
			if (calcBanDuration(world->items[x + (y * world->width)].growtime) == 0) {
				Player::OnTextOverlay(peer, "" + getItemDef(world->items[x + (y * world->width)].foreground - 1).name + " Tree grew to full size!");
			}
			else if (tile == 228) {
				Player::OnTextOverlay(peer, "" + getItemDef(world->items[x + (y * world->width)].foreground - 1).name + " Tree aged `$1`` hours");
			}
			else if (tile == 1778) {
				Player::OnTextOverlay(peer, "" + getItemDef(world->items[x + (y * world->width)].foreground - 1).name + " Tree aged `$1`` day");
			}
			Player::PlayAudio(peer, "audio/spray.wav", 0);
			return;
		}


		if (tile == 1240) {

			isMonitor = true;
		}
		if (world->items.at(x + (y * world->width)).foreground == 3818 && tile == 32) {
			if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || adminLevel(peer) > 1 || world->owner == "") {
				string dialog = "", ok = world->items.at(x + (y * world->width)).sign;
				if (world->items.at(x + (y * world->width)).sign == "") {
					dialog = "add_label_with_icon|big|`wPortrait|left|3818|\nadd_label|small|`$The canvas is blank.|left|\nadd_player_picker|portrait|`wPaint Someone|`wTap a player|\nadd_smalltext|`5(Painting costs 2 Paint Bucket of each color)|left|\nend_dialog|editcanvas|`wCancel|`wUpdate|";
				}
				else {
					string text = explode("|", ok)[4];
					dialog = "add_label_with_icon|big|`wPortrait|left|3818|\nadd_spacer|small|\nadd_label|small|`oThis is a lovely portrait of a Growtopian.|left|\nadd_button|erasepaint|`oErase Painting|noflags|0|0|\nadd_smalltext|`5(You'll need 4 Paint Bucket - Varnish to erase this)|left|\nadd_text_input|porttitle|`oTitle|" + text + "|33|\nadd_smalltext|`oif you'd like to touch up the painting slightly, you could change the expression:\nadd_checkbox|port1|`oUnconcerned|0\nadd_checkbox|port2|`oHappy|0\nadd_checkbox|port3|`oSad|0\nadd_checkbox|port4|`oTongue Out|0\nadd_checkbox|port5|`oSurprised|0\nadd_checkbox|port6|`oAngry|0\nadd_checkbox|port7|`oTalking|0\nadd_checkbox|port9|`oEcstatic|0\nadd_checkbox|port11|`oWry|0\nadd_checkbox|port12|`oSleeping|0\nadd_checkbox|port14|`oWinking|0\nadd_checkbox|port16|`oTrolling|0\nend_dialog|editemoji|`wCancel|`wUpdate|";
				}
				dialog += "\nembed_data|tilex|" + to_string(x) + "\nembed_data|tiley|" + to_string(y);
				GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), dialog));
				ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet);
				delete p.data;
			}
		}

		if (tile == 32 || tile == 18) {
			if (world->items.at(x + (y * world->width)).foreground == 1790) {

				if (pinfo->ltype == 1 && pinfo->lqueststep == 1) {
					string btntext = "";
					if (pinfo->gems < 1) {
						btntext = "You have none to deliver!";
					}
					else if (pinfo->gems < 100001) {
						btntext = "Deliver " + to_string(pinfo->gems) + " Gems";

					}
					else {
						btntext = "Deliver " + to_string(100000) + " Gems";
					}
					string ste = "set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Fire``|left|1790|\nadd_smalltext|(Step 1/10)|\nadd_spacer|small|\nadd_textbox|`oI challenge you to bring me 100,000 gems!|\nadd_spacer|small|\nadd_smalltext|Current progress " + to_string(((PlayerInfo*)(peer->data))->lquestprogress) + "/100000|\nadd_button|lwizstep1|" + btntext + "|\nadd_button|giveup|Give up this quest|\nend_dialog|lqueststep1|Goodbye!|";
					Player::OnDialogRequest(peer, ste);

				}
				else if (pinfo->ltype == 1 && pinfo->lqueststep == 2) {
					string btn = "";
					if (pinfo->lquestprogress < 1000) {
						btn = "I will go smash more!";
					}
					else {
						btn = "No block can beat me!";
					}
					string k = "set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Fire``|left|1790|\nadd_smalltext|(Step 2/10)|\nadd_spacer|small|\nadd_textbox|`oI want you to break 1000 blocks because why not.|\nadd_spacer|small||\nadd_smalltext|Current progress " + to_string(((PlayerInfo*)(peer->data))->lquestprogress) + "/1000|\nadd_button|lwizstep2|" + btn + "|\nadd_button|giveup|Give up this quest|\nend_dialog|lqueststep1|Goodbye!|";
					Player::OnDialogRequest(peer, k);

				}
				else {

					string lwiz = "set_default_color|`o\nadd_label_with_icon|big|`9The Legendary Wizard``|left|1790|\nadd_textbox|`oGreetings, traveler! I am the Legendary Wizard. Should you wish to embark on a Legendary Quest.|\nadd_textbox|`oChoose on from below.|\nadd_spacer|small|\nadd_button|starthonor|`9Quest For Honor|\nadd_button|startfire|`9Quest For Fire|\nend_dialog|lqueststart|No Thanks|";

					GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), lwiz));
					ENetPacket* packet = enet_packet_create(p.data,
						p.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet);
					delete p.data;
				}

			}

		}

		if (tile == 2914 && ((PlayerInfo*)(peer->data))->cloth_hand == 2912) {

			if (world->items.at(x + (y * world->width)).water) {
				if (((PlayerInfo*)(peer->data))->x != 0) {
					int pY = (int)((PlayerInfo*)(peer->data))->y / 32;
					int pX = (int)((PlayerInfo*)(peer->data))->x / 32;
					((PlayerInfo*)(peer->data))->isFishing = true;
					ENetPeer* currentPeer;

					for (currentPeer = server->peers;
						currentPeer < &server->peers[server->peerCount];
						++currentPeer)
					{
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
							continue;
						if (isHere(peer, currentPeer)) {
							sendPlayerFishing(currentPeer, ((PlayerInfo*)(peer->data))->netID, x, y);
						}
					}
				}
			}
			return;
		}

		if (tile == 1136) {

			string dialog = "set_default_color|`o\nadd_label_with_icon|big|`wMars Blast``|left|1136|\nadd_textbox|`oThis item creates a new world! Enter a unique name for it.|\nadd_text_input|mars_name|New World Name||25|\nend_dialog|mars_dialog|Cancel|`5Create!|";

			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), dialog));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
		}


		if (tile == 32) {

			if (world->name != "ADMIN") {
				if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || adminLevel(peer) > 1 || world->owner == "") {

					if (world->items.at(x + (y * world->width)).foreground == 3694) {


						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_label_with_icon|big|`wWeather Machine - Heatwave``|left|3694|\nadd_spacer|small|\nadd_textbox|`oAdjust the color of your heat wave here, by including 0-255 of Red, Green, and Blue.|\nadd_spacer|small|\nadd_text_input|heatwave_red|Red|" + to_string(world->hw_red) + "|3|\nadd_text_input|heatwave_green|Green|" + to_string(world->hw_green) + "|3|\nadd_text_input|heatwave_blue|Blue|" + to_string(world->hw_blue) + "|3|\nadd_quick_exit|\nend_dialog|heatwave|Cancel|Okay|"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
						pinfo->wrenchedBlockLocation = x + (y * world->width);

					}
					if (world->items.at(x + (y * world->width)).foreground == 3832) {
						string stuff_dialog = "set_default_color|`o\nadd_label_with_icon|big|`wWeather Machine - Stuff``|left|3832|\nadd_spacer|small|\nadd_item_picker|stuff_pick|Item: `2" + getItemDef(world->stuffID).name + "|Select any item to rain down|\nadd_text_input|stuff_gravity|Gravity:|" + to_string(world->stuff_gravity) + "|3|\nadd_checkbox|stuff_spin|Spin Items|" + to_string(world->stuff_spin) + "|\nadd_checkbox|stuff_invert|Invert Sky Colors|" + to_string(world->stuff_invert) + "|\nadd_textbox|`oSelect item and click okay to continue!|\nend_dialog|stuff_weather|Cancel|Okay|";

						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), stuff_dialog));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
						pinfo->wrenchedBlockLocation = x + (y * world->width);
					}
					if (world->items.at(x + (y * world->width)).foreground == 5000) {

						string itemname = getItemDef(world->bgID).name;
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_label_with_icon|big|`wWeather Machine - Background``|left|5000|\nadd_spacer|small|\nadd_textbox|`oYou can scan any Background Block to set it up in your weather machine.|\nadd_item_picker|bg_pick|Item: `2" + itemname + "|Select any Background Block|\nadd_quick_exit|\nend_dialog|bg_weather|Cancel|Okay|"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
						pinfo->wrenchedBlockLocation = x + (y * world->width);

					}

				}
			}
		}



		if (world->items.at(x + (y * world->width)).fire) {
			if (pinfo->cloth_hand == 3066 || tile == 822) {

				if (tile == 822) {
					SendThrowEffect(peer, 822, netID, -1, 150, 0, x * 32 + 16, y * 32 + 16);
					world->items.at(x + (y * world->width)).fire = false;
					UpdateBlockState(peer, x, y, true, world);
					SaveBlockState(world, peer, x, y);
					ENetPeer* currentPeer;

					for (currentPeer = server->peers;
						currentPeer < &server->peers[server->peerCount];
						++currentPeer)
					{
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
							continue;
						if (isHere(peer, currentPeer)) {
							Player::OnParticleEffect(currentPeer, 149, x * 32 + 16, y * 32 + 16, 0);
						}
					}

					pinfo->firesOutput++;

					return;
				}
				else {
					ENetPeer* currentPeer;

					for (currentPeer = server->peers;
						currentPeer < &server->peers[server->peerCount];
						++currentPeer)
					{
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
							continue;
						if (isHere(peer, currentPeer)) {
							Player::OnParticleEffect(currentPeer, 149, x * 32 + 16, y * 32 + 16, 0);
						}
					}
					world->items.at(x + (y * world->width)).fire = false;
					UpdateBlockState(peer, x, y, true, world);
					SaveBlockState(world, peer, x, y);
					pinfo->firesOutput++;
					return;

				}

			}

		}
		if (tile == 3062)
		{
			if (world->items.at(x + (y * world->width)).fire == false && world->items.at(x + (y * world->width)).water == false)
			{
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SEED || world->items.at(x + (y * world->width)).foreground == 0 && world->items.at(x + (y * world->width)).background == 6864 || world->items.at(x + (y * world->width)).water || world->items.at(x + (y * world->width)).foreground == 6952 || world->items.at(x + (y * world->width)).foreground == 6954 || world->items.at(x + (y * world->width)).foreground == 5638 || world->items.at(x + (y * world->width)).foreground == 6946 || world->items.at(x + (y * world->width)).foreground == 6948 || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::VENDING || world->items.at(x + (y * world->width)).foreground == 1420 || world->items.at(x + (y * world->width)).foreground == 6214 || world->items.at(x + (y * world->width)).foreground == 1006 || world->items.at(x + (y * world->width)).foreground == 656 || world->items.at(x + (y * world->width)).foreground == 1420 || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::DONATION || world->items.at(x + (y * world->width)).foreground == 3528 || world->items.at(x + (y * world->width)).foreground == 0 && world->items.at(x + (y * world->width)).background == 0 || world->items.at(x + (y * world->width)).foreground == 6 || world->items.at(x + (y * world->width)).foreground == 8 || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::LOCK || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::DISPLAY) {
					if (world->items.at(x + (y * world->width)).background != 6864) Player::OnTalkBubble(peer, netID, "`wCan't burn that!", 0);
					return;
				}
				if (world->items.at(x + (y * world->width)).foreground != 6 && world->items.at(x + (y * world->width)).foreground != 8 && itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::LOCK)
				{
					if (world->items.at(x + (y * world->width)).foreground == 0 && world->items.at(x + (y * world->width)).background == 0)
					{
						Player::OnTalkBubble(peer, netID, "`wTheres nothing to burn!", 0);
						return;
					}
					world->items.at(x + (y * world->width)).fire = !world->items.at(x + (y * world->width)).fire;
					ENetPeer* net_peer;
					for (net_peer = server->peers;
						net_peer < &server->peers[server->peerCount];
						++net_peer)
					{
						if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, net_peer))
						{
							Player::OnParticleEffect(net_peer, 150, x * 32 + 16, y * 32 + 16, 0);
							Player::OnTalkBubble(net_peer, netID, "`7[```4MWAHAHAHA!! FIRE FIRE FIRE```7]``", 0);
						}
					}
					RemoveItemFromInv(peer, 3062, 1, true);
					UpdateBlockState(peer, x, y, true, world);
					SaveBlockState(world, peer, x, y);
				}
			}
			return;
		}
		if (tile == 822) {
			if (world->items.at(x + (y * world->width)).fire) {
				SendThrowEffect(peer, 822, netID, -1, 150, 0, x * 32 + 16, y * 32 + 16);
				RemoveItemFromInv(peer, 822, 1, true);
				world->items.at(x + (y * world->width)).fire = false;
				UpdateBlockState(peer, x, y, true, world);
				SaveBlockState(world, peer, x, y);
				for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
					if (net_peer->state != ENET_PEER_STATE_CONNECTED) continue;
					if (isHere(peer, net_peer)) {
						Player::OnParticleEffect(net_peer, 149, x * 32, y * 32, 0);
					}
				}
				return;
			}
			if (world->items.at(x + (y * world->width)).foreground != 6 && world->items.at(x + (y * world->width)).foreground != 8 && itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::LOCK) {
				if (isWorldOwner(peer, world) || world->owner == "" || isDev(peer)) {
					if (world->items.at(x + (y * world->width)).water) {
						world->items.at(x + (y * world->width)).water = false;
						SaveBlockState(world, peer, x, y);
						if ((rand() % 99) + 1 < 40) {
							AddItemToInv(world, peer, 822, 1);
						}
						UpdateBlockState(peer, x, y, true, world);
					}
					else {
						world->items.at(x + (y * world->width)).water = true;
						RemoveItemFromInv(peer, 822, 1, true);
						SendThrowEffect(peer, 822, netID, -1, 150, 0, x * 32 + 16, y * 32 + 16);
						UpdateBlockState(peer, x, y, true, world);
						SaveBlockState(world, peer, x, y);
					}
				}
			}
			return;
		}

		if (tile == 5706) {
			if (x == ((PlayerInfo*)(peer->data))->x / 32 && y == ((PlayerInfo*)(peer->data))->y / 32) {
				RemoveItemFromInv(peer, 5706, 1, true);
				int Seed1 = 0;
				int Seed2 = 0;
				int Seed3 = 0;
				int Seed4 = 0;
				int Seed5 = 0;
				int AVGRarity = rand() % 9 + 1;
				while (Seed1 == 0 || Seed2 == 0 || Seed3 == 0 || Seed4 == 0 || Seed5 == 0) {
					for (int i = 0; i < CoreDataItems; i++) {
						if (i >= 1000) {
							Player::OnTalkBubble(peer, netID, "Something went wrong.", 0);
							break;
						}
						if (getItemDef(i).blockType == BlockTypes::SEED && itemDefs.at(i).rarity == AVGRarity || getItemDef(i).blockType == BlockTypes::SEED && itemDefs.at(i).rarity == AVGRarity + 1) {
							if (Seed1 == 0) Seed1 = i;
							else if (Seed2 == 0) Seed2 = i;
							else if (Seed3 == 0) Seed3 = i;
							else if (Seed4 == 0) Seed4 = i;
							else if (Seed5 == 0) Seed5 = i;
							else break;
							if (Seed4 != 0 && Seed5 == 0) AVGRarity = rand() % 9 + 1;
							else AVGRarity = rand() % 5 + 10;
						}
						else if (i == CoreDataItems - 1) {
							break;
						}
					}
				}
				bool success = true;
				AddItemToInv(world, peer, Seed1, 1);
				AddItemToInv(world, peer, Seed2, 1);
				AddItemToInv(world, peer, Seed3, 1);
				AddItemToInv(world, peer, Seed4, 1);
				AddItemToInv(world, peer, Seed5, 1);
			}
			else {
				Player::OnTalkBubble(peer, netID, "Must be used on a person.", 0);
			}
		}




		if (tile == 822) {
			if (world->items.at(x + (y * world->width)).water == false) {
				if (world->items.at(x + (y * world->width)).foreground != 6 && world->items.at(x + (y * world->width)).foreground != 8 && getItemDef(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::LOCK) {
					if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || adminLevel(peer) > 1 || world->owner == "") {

						//SendThrowEffect(peer, 822, netID, -1, 150, 0, x * 32 + 16, y * 32 + 16);
						world->items.at(x + (y * world->width)).water = false;
						UpdateBlockState(peer, x, y, true, world);
						SaveBlockState(world, peer, x, y);
						int numb = (rand() % 99) + 1;
						if (numb < 40) {
							AddItemToInv(world, peer, 822, 1);
						}


						return;
					}

					else {
						if (world->isPineappleGuard) {
							Player::OnTalkBubble(peer, netID, "`wYou cant use consumables here!", true);
							return;
						}
						world->items.at(x + (y * world->width)).water = !world->items.at(x + (y * world->width)).water;
						RemoveItemFromInv(peer, 822, 1, true);
						SendThrowEffect(peer, 822, netID, -1, 150, 0, x * 32 + 16, y * 32 + 16);
						UpdateBlockState(peer, x, y, true, world);
						return;
					}

				}
			}
		}




#pragma region block_multiple_items
		if (pinfo->rawName == world->owner || pinfo->adminLevel > 1 || world->owner == "") {
			if (tile == 3832) {
				int x;
				int y;
				bool found_one = false;
				try {
					for (int i = 0; i < world->width * world->height; i++)
					{
						if (world->items.at(i).foreground == 3832) {

							found_one = true;
						}
					}
				}
				catch (std::exception& e) {
					std::cout << e.what() << std::endl;
				}
				catch (const std::out_of_range& e) {
					std::cout << e.what() << std::endl;
				}
				if (found_one) {
					Player::OnTalkBubble(peer, netID, "You can have have only one Weather Machine - Stuff in your world!", true);
					return;
				}
			}
			if (tile == 3694) {
				int x;
				int y;
				bool found_one = false;
				try {
					for (int i = 0; i < world->width * world->height; i++)
					{
						if (world->items.at(i).foreground == 3694) {

							found_one = true;
						}
					}
				}
				catch (std::exception& e) {
					std::cout << e.what() << std::endl;
				}
				catch (const std::out_of_range& e) {
					std::cout << e.what() << std::endl;
				}

				if (found_one) {
					Player::OnTalkBubble(peer, netID, "You can have have only one Weather Machine - Heatwave in your world!", true);
					return;
				}
			}
			if (tile == 3616) {
				int y;
				bool found_one = false;
				try {
					for (int i = 0; i < world->width * world->height; i++)
					{
						if (world->items.at(i).foreground == 3616) {

							found_one = true;
						}
					}
				}
				catch (std::exception& e) {
					std::cout << e.what() << std::endl;
				}
				catch (const std::out_of_range& e) {
					std::cout << e.what() << std::endl;
				}
				if (found_one) {
					Player::OnTalkBubble(peer, netID, "This world already has a Guardian Pineapple somewhere on it, installing two would be dangerous!", true);
					return;
				}
			}
			if (tile == 5000) {
				int x;
				int y;
				bool found_one = false;
				try {
					for (int i = 0; i < world->width * world->height; i++)
					{
						if (world->items.at(i).foreground == 5000) {

							found_one = true;
						}
					}
				}
				catch (std::exception& e) {
					std::cout << e.what() << std::endl;
				}
				catch (const std::out_of_range& e) {
					std::cout << e.what() << std::endl;
				}
				if (found_one) {
					Player::OnTalkBubble(peer, netID, "You can have have only one Weather Machine - Background in your world!", true);
					return;
				}
			}
		}
#pragma endregion block_multiple_items


		if (tile == 196) {
			if (world->isPineappleGuard) {
				Player::OnTalkBubble(peer, netID, "`wYou cant use consumables here!", false);
				return;
			}
			if (x == pinfo->x / 32 && y == pinfo->y / 32) {

				SendTradeEffect(peer, 196, netID, netID, 150);
				string txt = "A `1blueberry`o slides down your throat! (`$Feelin' Blue`o mod added, `$5 secs`o left)";

				pinfo->skinColor = 4278190335;

				sendClothes(peer);
				PlayAudioSelf(peer, "audio/spray.wav");
				RemoveItemFromInv(peer, 196, 1, true);

				if (pinfo->blueBerry == false) {
					sendConsoleMsg(peer, txt);
					((PlayerInfo*)(peer->data))->lastBerry = 5;
					((PlayerInfo*)(peer->data))->usedBerry = GetCurrentTimeInternalSeconds();
				}

				pinfo->blueBerry = true;




			}

			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
					continue;
				if (isHere(peer, currentPeer)) {
					PlayerInfo* cpinfo = ((PlayerInfo*)(currentPeer->data));
					if (x == cpinfo->x / 32 && y == cpinfo->y / 32) {
						SendTradeEffect(currentPeer, 196, netID, cpinfo->netID, 150);
						SendTradeEffect(peer, 196, netID, cpinfo->netID, 150);
						string txt = "A `1blueberry`o slides down your throat! (`$Feelin' Blue`o mod added, `$5 secs`o left)";

						cpinfo->skinColor = 4278190335;

						sendClothes(currentPeer);
						PlayAudioSelf(currentPeer, "audio/spray.wav");

						RemoveItemFromInv(peer, 196, 1, true);

						if (cpinfo->blueBerry == false) {
							sendConsoleMsg(currentPeer, txt);
							((PlayerInfo*)(currentPeer->data))->lastBerry = 5;
							((PlayerInfo*)(currentPeer->data))->usedBerry = GetCurrentTimeInternalSeconds();
						}

						cpinfo->blueBerry = true;
						break;
					}

				}
			}

		}

		if (tile == 1634) {
			if (world->isPineappleGuard) {
				Player::OnTalkBubble(peer, netID, "`wYou cant use consumables here!", false);
				return;
			}
			if (x == pinfo->x / 32 && y == pinfo->y / 32) {


				SendTradeEffect(peer, 1634, netID, netID, 150);
				string txt = "You are full of caffeine! (`$Caffeinated`o mod added, `$5 secs`o left)";


				PlayAudioSelf(peer, "audio/spray.wav");
				RemoveItemFromInv(peer, 1634, 1, true);
				if (pinfo->Caffeine == false) {
					sendConsoleMsg(peer, txt);
					((PlayerInfo*)(peer->data))->leftCoffee = 5;
					((PlayerInfo*)(peer->data))->usedCoffee = GetCurrentTimeInternalSeconds();
				}
				pinfo->haveCigar = true;
				pinfo->Caffeine = true;
				sendState(peer, 1000, 360);



			}

		}

		if (x<0 || y<0 || x>world->width || y>world->height) return;
		sendNothingHappened(peer, x, y);

		if (tile != 18 && tile != 32 && getItemDef(tile).blockType != BlockTypes::BACKGROUND && world->items.at(x + (y * world->width)).foreground != 0) {
			sendNothingHappened(peer, x, y);
			return;
		}
		if (tile == 3394)
		{
			world->items.at(x + (y * world->width)).sign = ((PlayerInfo*)(peer->data))->country;
			isCountry = true;

		}
		if (getItemDef(tile).blockType == BlockTypes::LOCK && tile != 202 && tile != 204 && tile != 206 && tile != 4994) {
			if (world->name == "DEATHMATCH") {
				Player::OnTalkBubble(peer, netID, "Sorry, but you can't doing this while playing death match game.", true);
				return;
			}
			isLock = true;
		}

		if (!isOwner(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) {

			if (tile == 6 || tile == 6549) {
				Player::PlayAudio(peer, "audio/cant_break_tile.wav", 0);
				Player::OnTalkBubble(peer, netID, "It's too strong to break.", 1);
				return;
			}
			if (world->items.at(x + (y * world->width)).foreground == 6 || world->items.at(x + (y * world->width)).foreground == 6549) {
				Player::PlayAudio(peer, "audio/cant_break_tile.wav", 0);
				Player::OnTalkBubble(peer, netID, "It's too strong to break.", 1);
				return;
			}
		}
		if (!isOwner(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass))
		{
			if (world->items.at(x + (y * world->width)).foreground == 6 || world->items.at(x + (y * world->width)).foreground == 8 || world->items.at(x + (y * world->width)).foreground == 3760) {
				Player::PlayAudio(peer, "audio/cant_break_tile.wav", 0);
				Player::OnTalkBubble(peer, netID, "It's too strong to break.", 1);
				return;
			}

			if (tile == 8 || tile == 3760 || tile == 6864) {
				Player::PlayAudio(peer, "audio/cant_break_tile.wav", 0);
				Player::OnTalkBubble(peer, netID, "It's too strong to place.", 1);
				return;
			}

		}

		if (getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::DOOR || getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::PORTAL) {
			if (tile == 32) {
				if (world->owner == "" || isWorldOwner(peer, world) || isWorldAdmin(peer, world) || world->isPublic == true) {
					((PlayerInfo*)(peer->data))->wrenchedBlockLocation = x + (y * world->width);
					WorldItem item = world->items[x + (y * world->width)];
					string a = item.destWorld + ":" + item.destId;
					int s = 0;
					if (a == ":") a = "";
					bool aa = item.opened;
					if (aa) s = 0;
					else s = 1;
					Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit Door``|left|" + to_string(item.foreground) + "|\|\n\nadd_text_input|label|`oLabel|" + item.sign + "|100|\nadd_text_input|dest|`oDestination|" + a + "|100|\nadd_smalltext|`oEnter a Destination in this format: `2WORLDNAME:ID|left|\nadd_smalltext|`oLeave `2WORLDNAME `oblank (:ID) to go to the door with `2ID `oin the `2Current World`o.|left|\nadd_text_input|doorid|`oID|" + item.currId + "|35|\nadd_smalltext|`oSet a unique `2ID `oto target this door as a Destination from another!|left|\nadd_spacer|small|\nadd_checkbox|opentopublic|`ois Open to Public?|" + std::to_string(s) + "\nend_dialog|editdoor|Cancel|OK|");
				}
			}
		}
		if (tile == 32 && world->items.at(x + (y * world->width)).foreground == 3002) {
			if (world->owner == "" || isWorldOwner(peer, world) || isWorldAdmin(peer, world) || world->isPublic || adminLevel(peer) > 1) {
				string lol = world->items.at(x + (y * world->width)).sign, dialog = "";
				string cbox = "";
				dialog += "add_label_with_icon|big|`wFish Tank Port|left|3002|\nadd_spacer|small|";
				if (lol != "") {
					vector<string> gg = explode(",", lol);
					if (gg.size() != 0) {
						for (auto& z : gg) {
							if (z == "" || z.length() == 0) continue;
							vector<string> xd = explode("|", z);
							cbox += "\nadd_checkbox|remfish_" + xd.at(0) + "_" + xd.at(1) + "_" + xd.at(2) + "|`o" + xd.at(1) + "lb. " + itemDefs[stoi(xd.at(0))].name + "|0";
						}
					}
					dialog += "\nadd_label|small|`oThe fish tank contains:|left|" + cbox + "\nadd_button|remove_fish|`oRemove checked fish|noflags|0|0|";
					if (gg.size() > 5) {}
					else dialog += "\nadd_item_picker|fishid|`wAdd a fish|`wChoose a fish to put in the tank!|";
				}
				else {
					dialog += "\nadd_label|small|`oThe fish tank is empty!|left|\nadd_item_picker|fishid|`wAdd a fish|`wChoose a fish to put in the tank!|";
				}
				dialog += "\nadd_checkbox|sinarfish|`oPerfect fish glow|0";
				dialog += "\nend_dialog|updatefish|`wClose|`wUpdate|";
				dialog += "\nembed_data|tilex|" + to_string(x) + "\nembed_data|tiley|" + to_string(y);
				GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), dialog));
				ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet);
				delete p.data;
			}
		}
		if (getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::DISPLAY_SHELF) {
			if (tile == 32) {
				if (world->owner == "" || isWorldOwner(peer, world) || isWorldAdmin(peer, world) || world->isPublic || adminLevel(peer) > 1) {
					std::string data = world->items.at(x + (y * world->width)).sign, dialog = "add_label_with_icon|big|`wDisplay Shelf|left|3794|\nadd_spacer|small|";
					if (data != "") {
						string btn = ""; auto lst = explode("|", data); int num = 0;
						for (auto& a : lst) {
							num++;
							if (a == "0" || a.length() == 0) btn += "\nadd_item_picker|shelf" + std::to_string(num) + "|`4Display an item|`wSelect any item to display|";
							else btn += "\nadd_item_picker|shelf" + std::to_string(num) + "|`oItem " + std::to_string(num) + " : `2" + itemDefs[atoi(a.c_str())].name + "|`wSelect any item to display|";
						}
						dialog.append(btn);
						dialog.append("\nadd_button|remshelf|`oTake all item|noflags|0|0|");
					}
					else { int k = 0; for (int i = 0; i < 4; i++) { k++; dialog.append("\nadd_item_picker|shelf" + std::to_string(k) + "|`4Display an item|`wSelect any item to display|"); } }
					dialog.append("\nend_dialog|loaak|`wOkay||"); dialog += "\nembed_data|tilex|" + std::to_string(x) + "\nembed_data|tiley|" + std::to_string(y);
					Player::OnDialogRequest(peer, dialog.c_str());
					((PlayerInfo*)(peer->data))->wrenchedBlockLocation = x + (y * world->width);
				}
			}
		}
		if (world != NULL) {
			if (world->name != "ADMIN") {
				if (getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::SIGN || itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::Mannequin)
				{
					if (tile == 32) {

						if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1) {

							string signtext = world->items.at(x + (y * world->width)).sign;

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\n\nadd_spacer|small|\nadd_text_input|signtextas||" + signtext + "|200|\nend_dialog|editsign|Cancel|OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							pinfo->wrenchedBlockLocation = x + (y * world->width);





						}
					}
				}
			}
		}
		if (world->name != "ADMIN") {
			if (world->owner != "") {
				if (isWorldOwner(peer, world) || isWorldAdmin(peer, world) || isDev(peer)) {
					if (getItemDef(fg).blockType == BlockTypes::LOCK && isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && adminLevel(peer) < 2) {
						// This means that you are admin, you cant break wl!
						Player::OnTalkBubble(peer, netID, "`w" + world->ownerDisplayName + "`w's " + "`$" + getItemDef(fg).name + "`w" + ". (`2Access Granted`w)", true);
						Player::OnPlayPositioned(peer, "audio/punch_locked.wav", ((PlayerInfo*)(peer->data))->netID, false, NULL);
						return;
					}
					if (tile == 32) {
						if (getItemDef(fg).blockType == BlockTypes::LOCK && fg != 202 && fg != 204 && fg != 206 && fg != 4994)
						{
							string str = "";
							int ischecked;
							int ischecked1;
							int ischecked2;
							for (auto i = 0; i < world->accessworld.size(); i++) {
								if (world->accessworld.at(i) == "") continue;
								str += "\nadd_checkbox|checkbox_" + world->accessworld.at(i) + "|" + world->accessworld.at(i) + "``|1";
							}


							if (world->isPublic == true) {
								ischecked = 1;
							}
							else {
								ischecked = 0;
							}
							if (world->allowNoclip == true) {
								ischecked1 = 0;
							}
							else {
								ischecked1 = 1;
							}
							if (world->silence == false) {
								ischecked2 = 0;
							}
							else {
								ischecked2 = 1;
							}
							if (world->accessworld.size() == 0) {
								pinfo->wrenchedBlockLocation = x + (y * world->width);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + std::to_string(getItemDef(world->items.at(x + (y * world->width)).foreground).id) + "|\nadd_textbox|`wAccess list:|left|\nadd_spacer|small|\nadd_textbox|Currently, you're the only one with the access.|left|\nadd_spacer|small|\nadd_player_picker|netid|`wAdd|\nadd_checkbox|isWorldPublic|Allow anyone to build|" + std::to_string(ischecked) + "\nadd_checkbox|cantsay|Silent, Peasants!|" + std::to_string(ischecked2) + "\nadd_checkbox|cannoclip|Enable noclip in the world|" + std::to_string(ischecked1) + "|\nadd_checkbox|checkbox_disable_music_render|Make Custom Music Blocks invisible|" + to_string(world->invisible_music) + "|\nadd_text_input|tempo|Music BPM|" + std::to_string(world->bpm) + "|3|\nend_dialog|wlmenu|Cancel|OK|"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}

							else {
								pinfo->wrenchedBlockLocation = x + (y * world->width);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + std::to_string(getItemDef(world->items.at(x + (y * world->width)).foreground).id) + "|\nadd_textbox|`wAccess list:|left|\nadd_spacer|small|" + str + "\add_spacer|small|\nadd_player_picker|netid|`wAdd|\nadd_checkbox|isWorldPublic|Allow anyone to build|" + std::to_string(ischecked) + "\nadd_checkbox|cantsay|Silent, Peasants!|" + std::to_string(ischecked1) + "|\nadd_checkbox|cannoclip|Enable noclip in the world|" + std::to_string(ischecked1) + "|\nadd_checkbox|checkbox_disable_music_render|Make Custom Music Blocks invisible|" + to_string(world->invisible_music) + "|\nadd_text_input|tempo|Music BPM|" + std::to_string(world->bpm) + "|3|\nend_dialog|wlmenu|Cancel|OK|"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
					}
				}
				else if (world->isPublic) {
					if (getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::LOCK)
					{
						if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) < 3) {
							Player::OnTalkBubble(peer, netID, "`w" + world->ownerDisplayName + "`w's " + "`$" + getItemDef(fg).name + "`w" + ". (`wOpen to Public`w)", true);
							Player::OnPlayPositioned(peer, "audio/punch_locked.wav", ((PlayerInfo*)(peer->data))->netID, false, NULL);
							return;
						}
						else {
							if (getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::LOCK)
							{
								Player::OnTalkBubble(peer, netID, "`w" + world->ownerDisplayName + "`w's " + "`$" + getItemDef(fg).name + "`w" + ". (`wOpen to Public`w)", true);
								Player::OnPlayPositioned(peer, "audio/punch_locked.wav", ((PlayerInfo*)(peer->data))->netID, false, NULL);
							}
						}
					}
				}
				else {
					if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) < 2) {
						Player::OnPlayPositioned(peer, "audio/punch_locked.wav", ((PlayerInfo*)(peer->data))->netID, false, NULL);
						if (tile == 32) {
							Player::OnTalkBubble(peer, netID, "This area is owner by " + world->ownerDisplayName + "!", true);
						}
						if (getItemDef(fg).blockType == BlockTypes::LOCK && fg != 202 && fg != 204 && fg != 206 && fg != 4994) {
							Player::OnTalkBubble(peer, netID, "`w" + world->ownerDisplayName + "`w's " + "`$" + getItemDef(fg).name + "`w" + ". (`4No Access`w)", true);
						}
						return;
					}
					else
					{
						if (getItemDef(fg).blockType == BlockTypes::LOCK) {
							Player::OnTalkBubble(peer, netID, "`w" + world->ownerDisplayName + "'s " + getItemDef(fg).name + ". (`2Access Granted`w)", true);
							Player::OnPlayPositioned(peer, "audio/punch_locked.wav", ((PlayerInfo*)(peer->data))->netID, false, NULL);
						}
					}
				}
				if (isLock) {
					Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`0Only one `$World Lock`0 can be placed in a world!", true);
					return;
				}
			}
		}







		if (tile != 0 && tile != 18)
		{
			if (getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::LOCK)
			{

				return;
			}

		}

		if (getItemDef(tile).blockType == BlockTypes::CONSUMABLE) {
			switch (tile)
			{
			case 6336:
				//sendDialog(peer, growpediaText);
				return;
			default: return;
			}
		}


		if (tile == 32) {

			return;
		}


		ItemDefinition def;
		try {
			def = getItemDef(tile);
			if (def.blockType == BlockTypes::CLOTHING) return;
		}
		catch (int e) {
			def.breakHits = 4;
			def.blockType = BlockTypes::UNKNOWN;
#ifdef TOTAL_LOG
			cout << "Ugh, unsupported item " << tile << endl;
#endif
		}



		//	if (tile == 544 || tile == 546 || tile == 4520 || tile == 382 || tile == 3116 || tile == 4520 || tile == 1792 || tile == 5666 || tile == 2994 || tile == 4368) return;
		//	if (tile == 5708 || tile == 5709 || tile == 5780 || tile == 5781 || tile == 5782 || tile == 5783 || tile == 5784 || tile == 5785 || tile == 5710 || tile == 5711 || tile == 5786 || tile == 5787 || tile == 5788 || tile == 5789 || tile == 5790 || tile == 5791 || tile == 6146 || tile == 6147 || tile == 6148 || tile == 6149 || tile == 6150 || tile == 6151 || tile == 6152 || tile == 6153 || tile == 5670 || tile == 5671 || tile == 5798 || tile == 5799 || tile == 5800 || tile == 5801 || tile == 5802 || tile == 5803 || tile == 5668 || tile == 5669 || tile == 5792 || tile == 5793 || tile == 5794 || tile == 5795 || tile == 5796 || tile == 5797 || tile == 544 || tile == 546 || tile == 4520 || tile == 382 || tile == 3116 || tile == 1792 || tile == 5666 || tile == 2994 || tile == 4368) return;
		if (tile == 1902 || tile == 1508 || tile == 428) return;
		if (tile >= CoreDataItems) return;
		if (tile == 18) {
			if (world->items.at(x + (y * world->width)).background == 6864 && world->items.at(x + (y * world->width)).foreground == 0) return;
			if (world->items.at(x + (y * world->width)).background == 0 && world->items.at(x + (y * world->width)).foreground == 0) return;
			ItemDefinition brak;
			if (world->items.at(x + (y * world->width)).foreground != 0) {
				brak = itemDefs.at(world->items.at(x + (y * world->width)).foreground);
			}
			else {
				brak = itemDefs.at(world->items.at(x + (y * world->width)).background);
			}
			if (isPickaxe(peer)) brak.breakHits -= 1;
			//data.netID = -1;
			data.packetType = 0x8;
			data.plantingTree = 6;

			int brokentile = world->items.at(x + (y * world->width)).foreground;
			if (((PlayerInfo*)(peer->data))->cloth_hand == 2952) {
				int kek = world->items.at(x + (y * world->width)).foreground;
				if (world->items.at(x + (y * world->width)).foreground != 0) kek = world->items.at(x + (y * world->width)).foreground;
				else kek = world->items.at(x + (y * world->width)).background;
				for (ENetPeer* net_peer = server->peers; net_peer < &server->peers[server->peerCount]; ++net_peer) {
					if (net_peer->state != ENET_PEER_STATE_CONNECTED || net_peer->data == NULL) continue;
					if (isHere(peer, net_peer)) {
						SendParticleEffect(net_peer, x * 32 + 16, y * 32, kek, 97, 0);
					}
				}
			}
			if ((duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() - world->items.at(x + (y * world->width)).breakTime >= 4000 && ((PlayerInfo*)(peer->data))->cloth_hand != 2952)
			{
				world->items.at(x + (y * world->width)).breakTime = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				world->items.at(x + (y * world->width)).breakLevel = 4; // TODO


			}
			else {
				if (y < world->height && world->items.at(x + (y * world->width)).breakLevel >= brak.breakHits * 4 || ((PlayerInfo*)(peer->data))->cloth_hand == 2952) { // TODO

					data.packetType = 0x3;// 0xC; // 0xF // World::HandlePacketTileChangeRequest
					data.netID = causedBy;
					data.plantingTree = 18;
					world->items[x + (y * world->width)].breakLevel = 0;
					if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {
						if (brokentile != 0)
						{
							if (sendClearArrayData(peer, x, y, fg, bg, brokentile, world) == -1) return;
						}
						else {
							data.plantingTree = 18;
							world->items.at(x + (y * world->width)).background = 0;
							add_objects_when_breaking_block(peer, world, bg, x, y);
							if (getItemDef(fg).rarity != 999 && getItemDef(bg).rarity != 999) {
								if (((PlayerInfo*)(peer->data))->xptime != 0) {
									int to = ((PlayerInfo*)(peer->data))->xpboost;

									time_t now = time(NULL);
									time_t muted = ((PlayerInfo*)(peer->data))->xptime;

									if (now - muted > to) {
										((PlayerInfo*)(peer->data))->xpboost = 0;
										((PlayerInfo*)(peer->data))->xptime = 0;
										Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYour `1XP-BOOST`w have been removed please behave better this time", true);
									}
									else {
										string a = "";
										int left = now - muted;
										int start = to - left;
										int n = start;
										int day = n / (24 * 3600);
										n = n % (24 * 3600);
										int hour = n / 3600;
										n %= 3600;
										int minutes = n / 60;
										n %= 60;
										int seconds = n;
										if (hour != 0) {
											a = "`4" + std::to_string(hour) + " `whours, `4" + std::to_string(minutes) + " `wmins, `4" + std::to_string(seconds) + "`w secs.``";
										}
										else {
											a = "`4" + std::to_string(minutes) + " `wmins, `4" + std::to_string(seconds) + "`w secs.``";
										}
										Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wremaining xp boost: " + a + "", false);
										((PlayerInfo*)(peer->data))->xp = ((PlayerInfo*)(peer->data))->xp + (rand() % 10);
									}
								}
								else ((PlayerInfo*)(peer->data))->xp++;
								if (((PlayerInfo*)(peer->data))->xp >= GetMaxExpForNextLevel(((PlayerInfo*)(peer->data))->level)) {
									((PlayerInfo*)(peer->data))->xp = 0;
									((PlayerInfo*)(peer->data))->level = ((PlayerInfo*)(peer->data))->level + 1;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (isHere(peer, currentPeer)) {
											string name = ((PlayerInfo*)(peer->data))->displayName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `wis now level " + std::to_string(((PlayerInfo*)(peer->data))->level) + "!"));
											string text = "action|play_sfx\nfile|audio/levelup2.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);

											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packet2);
											int effect = 46;
											int x = ((PlayerInfo*)(peer->data))->x;
											int y = ((PlayerInfo*)(peer->data))->y;
											GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

											ENetPacket* packetd = enet_packet_create(psp.data,
												psp.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packetd);

											delete psp.data;
											delete[] data;
											delete p.data;

											GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), name + " `wis now level " + std::to_string(((PlayerInfo*)(peer->data))->level) + "!"));
											ENetPacket* packet3 = enet_packet_create(p3.data,
												p3.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet3);
											delete p3.data;
										}
									}
								}
							}
						}
					}
				}
				else {
					if (y < world->height) {
						world->items.at(x + (y * world->width)).breakTime = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
						world->items.at(x + (y * world->width)).breakLevel += 4; // TODO
					}
				}
			}
		}
		else {
			int xx = data.punchX;
			int yy = data.punchY;
			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
					continue;
				if (isHere(peer, currentPeer)) {
					if (world->name != "DEATHMATCH") {
						if (isGoodForeground(tile)) {
							if (((PlayerInfo*)(currentPeer->data))->x / 32 == xx && ((PlayerInfo*)(currentPeer->data))->y / 32 == yy) return;

						}
					}
				}
			}
			for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
			{
				if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == tile)
				{
					if ((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount > 1)
					{
						((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount--;
					}
					else {
						((PlayerInfo*)(peer->data))->inventory.items.erase(((PlayerInfo*)(peer->data))->inventory.items.begin() + i);
					}
					break;
				}
			}
			if (def.blockType == BlockTypes::BACKGROUND)
			{
				world->items.at(x + (y * world->width)).background = tile;
			}
			else {
				if (world->items.at(x + (y * world->width)).foreground != 0) return;
				world->items.at(x + (y * world->width)).foreground = tile;


				if (isMonitor) {
					//	sendHMonitor(peer, x, y, "homo", true);
					world->items.at(x + (y * world->width)).sign = pinfo->tankIDName;
				}
				if (isLock) {
					if (((PlayerInfo*)(peer->data))->haveGrowId) {
						int netID = ((PlayerInfo*)(peer->data))->netID;
						world->owner = ((PlayerInfo*)(peer->data))->rawName;
						world->ownerDisplayName = ((PlayerInfo*)(peer->data))->displayName;
						world->ownerID = ((PlayerInfo*)(peer->data))->userID;
						world->isPublic = false;
						((PlayerInfo*)(peer->data))->worldsowned.push_back(world->name);

						ENetPeer* currentPeer;

						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
								continue;
							if (isHere(peer, currentPeer)) {
								Player::OnConsoleMessage(currentPeer, "`5[`w" + world->name + " `ohas been `$World Locked `oby `o" + ((PlayerInfo*)(peer->data))->displayName + "`5]``");
								PlayAudioSelf(currentPeer, "audio/use_lock.wav");
							}
						}
						string lol99 = "";
						if (((PlayerInfo*)(peer->data))->adminLevel == 0)
						{
							lol99 += ((PlayerInfo*)(peer->data))->displayName = "`2" + ((PlayerInfo*)(peer->data))->tankIDName;
							((PlayerInfo*)(peer->data))->displayName = "`2" + ((PlayerInfo*)(peer->data))->tankIDName;
						}
						else { lol99 += ((PlayerInfo*)(peer->data))->displayName; }
						Player::OnNameChanged(peer, ((PlayerInfo*)(peer->data))->netID, lol99);
					}
				}
			}
			world->items.at(x + (y * world->width)).breakLevel = 0;
		}







		ENetPeer* currentPeer;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer)) {
				SendPacketRaw(4, packPlayerMoving(&data), 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
			}
		}
		if (updateState) {
			if (itemDefs.at(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::RANDOM_BLOCK) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
					if (isHere(peer, currentPeer)) {
						world->items[x + (y * world->width)].intdata = rand() % 5;
						send_dice(currentPeer, netID, world->items[x + (y * world->width)].intdata, x, y);
					}
				}
			}
			else {
				if (world->items[x + (y * world->width)].activated) {
					sendNothingHappened(peer, x, y);
					world->items[x + (y * world->width)].activated = false;
					UpdateBlockState(peer, x, y, true, world);
					SaveBlockState(world, peer, x, y);
				}
				else {
					sendNothingHappened(peer, x, y);
					world->items[x + (y * world->width)].activated = true;
					UpdateBlockState(peer, x, y, true, world);
					SaveBlockState(world, peer, x, y);
				}
			}
		}
		if (itemDefs.at(tile).properties & Property_MultiFacing) {
			if (((PlayerInfo*)(peer->data))->isRotatedLeft) {
				world->items.at(x + (y * world->width)).flipped = true;
				UpdateBlockState(peer, x, y, true, world);
				SaveBlockState(world, peer, x, y);
			}
		}
		if (isMonitor) {
			sendHMonitor(world, peer, x, y, ((PlayerInfo*)(peer->data))->tankIDName, true);
		}
		if (isTree) {
			int growTimeSeed = getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity;
			growTimeSeed += 30 * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 954) growTimeSeed = 1800;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 340) growTimeSeed = 3600;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 5666) growTimeSeed = 2700;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 4584) growTimeSeed = 2400;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 4762) growTimeSeed = 14544;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 7382) growTimeSeed = 22544;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 9460) growTimeSeed = 29544;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 9468) growTimeSeed = 36544;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 10024) growTimeSeed = 56544;
			if (world->items.at(x + (y * world->width)).foreground - 1 == 10028) growTimeSeed = 86400;
			world->items.at(x + (y * world->width)).growtime = (GetCurrentTimeInternalSeconds() + growTimeSeed);
			if (getItemDef(world->items.at(x + (y * world->width)).foreground).rarity == 999) {
				world->items.at(x + (y * world->width)).fruitcount = (rand() % 1) + 1;
			}
			else {
				world->items.at(x + (y * world->width)).fruitcount = (rand() % 6) + 1;
			}
			if (getItemDef(world->items.at(x + (y * world->width)).foreground - 1).blockType == BlockTypes::CLOTHING) world->items.at(x + (y * world->width)).fruitcount = (rand() % 2) + 1;
			int chanceofbuff = 1;
			if (((PlayerInfo*)(peer->data))->level >= 8) chanceofbuff = 1;
			if (((PlayerInfo*)(peer->data))->level >= 11) chanceofbuff = 2;
			if (((PlayerInfo*)(peer->data))->level >= 8 && rand() % 100 <= chanceofbuff) {
				Player::OnConsoleMessage(peer, "Flawless bonus reduced 1 hour grow time");
				int NewGrowTime = 0;
				int InternalGrowTime = 0;
				NewGrowTime = calcBanDuration(world->items.at(x + (y * world->width)).growtime) - 3600;
				if (NewGrowTime < 0) NewGrowTime = 0;
				world->items.at(x + (y * world->width)).growtime = (GetCurrentTimeInternalSeconds() + NewGrowTime);
				int growTimeSeed = getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity;
				growTimeSeed += 30 * getItemDef(world->items.at(x + (y * world->width)).foreground - 1).rarity;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 954) growTimeSeed = 1800;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 340) growTimeSeed = 3600;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 5666) growTimeSeed = 2700;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 4584) growTimeSeed = 2400;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 4762) growTimeSeed = 14544;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 7382) growTimeSeed = 22544;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 9460) growTimeSeed = 29544;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 9468) growTimeSeed = 36544;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 10024) growTimeSeed = 56544;
				if (world->items.at(x + (y * world->width)).foreground - 1 == 10028) growTimeSeed = 86400;
				InternalGrowTime = growTimeSeed - calcBanDuration(world->items.at(x + (y * world->width)).growtime);
			}
			UpdateTreeVisuals(peer, world->items.at(x + (y * world->width)).foreground, x, y, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).fruitcount, growTimeSeed - calcBanDuration(world->items.at(x + (y * world->width)).growtime), true, 0, world);
		}
		if (isCountry)
		{
			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
					continue;
				if (isHere(peer, currentPeer))
					CountryFlag(world, currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).sign);
			}
		}
		if (VendUpdate) {
			if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
				UpdateVend(peer, x, y, 0, false, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
			}
			else {
				UpdateVend(peer, x, y, world->items.at(x + (y * world->width)).fruitcount, false, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
			}
		}
		if (isLock) {
			ENetPeer* currentPeer;
			for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
				if (isHere(peer, currentPeer)) {
					sendTileData(peer, x, y, 0x10, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, lockTileDatas(0x00, world->ownerID, 0, 0, false, world->bpm));
				}
			}
		}
		if (tile == 3798) {
			if (world->owner == "") {
				Player::OnTextOverlay(peer, "You need to lock this world first before using VIP ENTRANCE!");
				return;
			}
			auto squaresign = x + (y * 100);
			ENetPeer* currentPeer;
			for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
				if (isHere(peer, currentPeer)) {
					sendTileData(currentPeer, x, y, 0x10, world->items[squaresign].foreground, world->items[squaresign].background, EntranceTiles(0x20, world->ownerID));
				}
			}
		}
}
	catch (const std::out_of_range& e) {
		std::cout << "[OUT_OF_RANGE]: Error in void sendtileupdate >>" << e.what() << std::endl;
		std::fstream chas("corrupt.txt", std::ios::in | std::ios::out | std::ios::ate);
		chas << "[Corrupted worlds where (Out Of Range)] >> " << ((PlayerInfo*)(peer->data))->currentWorld << endl;
		chas.close();
		return;
	}
	catch (std::bad_alloc& exception) {
		std::cerr << "bad allocation detected [On SendTileUpdate]: " << exception.what() << endl;
		std::fstream chas("corrupt.txt", std::ios::in | std::ios::out | std::ios::ate);
		chas << "[Corrupted worlds where (Bad Allocation)] >> " << ((PlayerInfo*)(peer->data))->currentWorld << endl;
		chas.close();

	}
	catch (const std::exception& e) {
		std::cout << "[EXCEPTION]: Error in void sendtileupdate >>" << e.what() << std::endl;
		std::fstream chas("corrupt.txt", std::ios::in | std::ios::out | std::ios::ate);
		chas << "[Corrupted worlds where (Exception)] >> " << ((PlayerInfo*)(peer->data))->currentWorld << endl;
		chas.close();
	}
}





static inline void ltrim(string& s)
{
	s.erase(s.begin(), find_if(s.begin(), s.end(), [](int ch) {
		return !isspace(ch);
	}));
}

static inline void rtrim(string& s)
{
	s.erase(find_if(s.rbegin(), s.rend(), [](int ch) {
		return !isspace(ch);
	}).base(), s.end());
}

static inline void trim(string& s)
{
	ltrim(s);
	rtrim(s);
}

static inline string trimString(string s)
{
	trim(s);
	return s;
}

int countSpaces(string& str)
{
	int count = 0;
	int length = str.length();
	for (int i = 0; i < length; i++)
	{
		int c = str.at(i);
		if (isspace(c))
			count++;
	}
	return count;
}

void removeExtraSpaces(string& str)
{
	int n = str.length();
	int i = 0, j = -1;
	bool spaceFound = false;
	while (++j < n && str.at(j) == ' ');

	while (j < n)
	{
		if (str.at(j) != ' ')
		{
			if ((str.at(j) == '.' || str.at(j) == ',' ||
				str.at(j) == '?') && i - 1 >= 0 &&
				str[i - 1] == ' ')
				str[i - 1] = str[j++];
			else
				str[i++] = str[j++];

			spaceFound = false;
		}

		else if (str[j++] == ' ')
		{
			if (!spaceFound)
			{
				str[i++] = ' ';
				spaceFound = true;
			}
		}
	}
	if (i <= 1)
		str.erase(str.begin() + i, str.end());
	else
		str.erase(str.begin() + i, str.end());
}

void sendChatMessage(WorldInfo* world, ENetPeer* peer, int netID, string message)
{
	try {
		if (message == "" || message.length() >= 120) return;
		if (1 > (message.size() - countSpaces(message))) return;
		removeExtraSpaces(message);
		message = trimString(message);
		if (world->silence == true && adminLevel(peer) < 2 && !isWorldOwner(peer, world)) {
			Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`1(Peasants must not to talk)", true);
			return;
		}
		string check_msg = message;
		toUpperCase(check_msg);
		if (check_msg == ":)" || check_msg == ":(" || check_msg == ":*" || check_msg == ":'(" || check_msg == ":D" || check_msg == ":O" || check_msg == ";)" || check_msg == ":O.O" || check_msg == ":p") {
			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
					continue;
				if (isHere(peer, currentPeer)) {
					Player::OnTalkBubble(currentPeer, netID, check_msg, 0);
				}
			}
			return;
		}
		GamePacket p;
		GamePacket p2;
		if (((PlayerInfo*)(peer->data))->adminLevel == 3) {
			p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:__CT:[W]_ `6<`w" + ((PlayerInfo*)(peer->data))->displayName + "`6>`` `5`5" + message + "````"));
			p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), netID), "CP:_PL:0_OID:_player_chat=`5" + message), 0));
		}
		else if (((PlayerInfo*)(peer->data))->adminLevel == 2) {
			p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:__CT:[W]_ `6<`w" + ((PlayerInfo*)(peer->data))->displayName + "`6>`` `^`^" + message + "````"));
			p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), netID), "CP:_PL:0_OID:_player_chat=`^" + message), 0));
		}
		else if (((PlayerInfo*)(peer->data))->adminLevel == 1) {
			p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:__CT:[W]_ `6<`w" + ((PlayerInfo*)(peer->data))->displayName + "`6>`` `^`^" + message + "````"));
			p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), netID), "CP:_PL:0_OID:_player_chat=`^" + message), 0));
		}
		else if (haveSubscription(peer)) {
			p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:__CT:[W]_ `6<`w" + ((PlayerInfo*)(peer->data))->displayName + "`6>`` `c`e" + message + "````"));
			p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), netID), "CP:_PL:0_OID:_player_chat=`e" + message), 0));
		}
		else {
			p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:__CT:[W]_ `6<`w" + ((PlayerInfo*)(peer->data))->displayName + "`6>`` `$`$" + message + "````"));
			p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), netID), "CP:_PL:0_OID:_player_chat=" + message), 0));
		}
		ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
		ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
		for (ENetPeer* currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
				continue;
			if (isHere(peer, currentPeer))
			{
				enet_peer_send(currentPeer, 0, packet);
				enet_peer_send(currentPeer, 0, packet2);
			}
		}
		delete p.data;
		delete p2.data;
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}

void sendWho(WorldInfo* world, ENetPeer* peer)
{
	string online = "";
	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer) && ((PlayerInfo*)(currentPeer->data))->isInvisible == false)
		{
			online += ((PlayerInfo*)(currentPeer->data))->displayName + "`o, `w";
		}
	}
	Player::OnConsoleMessage(peer, "`wWho's in `o" + world->name + "`w: `w" + online);
}


void updateMagplant(ENetPeer* peer, short fg, short bg, int x, int y, int id, int itemcount, bool magnet, bool remote) {
	byte* magplant = new byte[15 + itemcount]; // creating byte, 15 is default length and adding text's length
	int state = 0x0010000; // default blockstate
	int length = id; // textlength
	int extLength = itemcount + 13; // text length +  15;

	// CReate pmov
	PlayerMoving pmov;
	pmov.packetType = 0x5; // why 0x5??!
	pmov.characterState = 0x8; // always 0x8
	pmov.punchX = x; //x 
	pmov.punchY = y; // y
	 //  now we got pmov


	byte* kk = new byte[extLength + 56]; //idk why 56, its always 56 because offset?

	memcpy(kk, packPlayerMoving(&pmov), 56); // add playermoving
	memcpy(kk + 52, &magplant, 4);
	memcpy(magplant, &fg, 2);
	memcpy(magplant + 2, &bg, 2);
	memcpy(magplant + 4, &state, 4);
	magplant[8] = 4;
	memcpy(magplant + 9, &length, 2);
	memcpy(magplant + 11, &remote, length);
	memset(magplant + 11 + length, 0xFF, 4);

	memcpy(kk + 56, &magnet, extLength);

	SendPacketRaw(4, kk, 56 + 15 + itemcount, 0, peer, ENET_PACKET_FLAG_RELIABLE);




}


void sendSign(ENetPeer* peer, short fg, short bg, int x, int y, string text, int type) {
	byte* signs = new byte[15 + text.length()]; // creating byte, 15 is default length and adding text's length
	int state = 0x0010000; // default blockstate
	int length = text.length(); // textlength
	int extLength = text.length() + 15; // text length +  15;

	// CReate pmov
	PlayerMoving pmov;
	pmov.packetType = 0x5; // why 0x5??!
	pmov.characterState = 0x8; // always 0x8
	pmov.punchX = x; //x 
	pmov.punchY = y; // y
	 //  now we got pmov


	byte* kk = new byte[extLength + 56]; //idk why 56, its always 56 because offset?

	memcpy(kk, packPlayerMoving(&pmov), 56); // add playermoving
	memcpy(kk + 52, &signs, 4);
	memcpy(signs, &fg, 2);
	memcpy(signs + 2, &bg, 2);
	memcpy(signs + 4, &state, 4);
	signs[8] = type;
	memcpy(signs + 9, &length, 2);
	memcpy(signs + 11, text.data(), length);
	memset(signs + 11 + length, 0xFF, 4);

	memcpy(kk + 56, signs, extLength);

	SendPacketRaw3(4, kk, 56 + 15 + text.length(), 0, peer, ENET_PACKET_FLAG_RELIABLE);




}

void sendAction(ENetPeer* peer, int netID, string action)
{
	ENetPeer* currentPeer;
	string name = "";
	GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnAction"), action));
	memcpy(p2.data + 8, &netID, 4);
	ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;

		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, packet2);
		}
	}
	delete p2.data;
}

bool HasInventoryFull(ENetPeer* peer)
{
	PlayerInventory* inventory = &((PlayerInfo*)(peer->data))->inventory;
	return inventory->items.size() > (uint32_t)inventory->inventorySize;
}

bool HasInventoryEmpty(ENetPeer* peer)
{
	PlayerInventory* inventory = &((PlayerInfo*)(peer->data))->inventory;
	return inventory->items.size() == 0;
}



void sendState2(ENetPeer* peer, int state) {
	PlayerInfo* info = ((PlayerInfo*)(peer->data));
	int netID = info->netID;
	ENetPeer* currentPeer;
	//int state = getState(info);
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			float water = 125.0f;
			data.packetType = 0x14;
			data.characterState = 0; // animation
			data.x = 1000;
			if (((PlayerInfo*)(peer->data))->cloth_hand == 366) {
				data.y = -400; // - is hbow
			}
			else {
				data.y = 400;
			}
			data.punchX = 0;
			data.punchY = 0;
			data.netID = netID;
			data.plantingTree = state;
			BYTE* raw = packPlayerMoving(&data);
			int var = 0x818100; // placing and breking 0x808040 
			memcpy(raw + 1, &var, 3);
			memcpy(raw + 16, &water, 4);
			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	// TODO
}





//replaced X-to-close with a Ctrl+C exit
void exitHandler(int s) {
	for (int i = 0; i < worlds.size(); i++) {
		string world_name = worlds.at(i).name;
		save_world(world_name, false, false);
	}
	exit(0);

}


void loadConfig() {
	/*inside config.json:
	{
	"port": 17091,
	"cdn": "0098/CDNContent37/cache/"
	}
	*/


	std::ifstream ifs("config.json");
	if (ifs.is_open()) {
		json j;
		ifs >> j;
		ifs.close();
		try {
			configPort = j["port"].get<int>();
			creatorname = j["creator_name"].get<vector<string>>();
			//	configCDN = j["cdn"].get<string>();

			cout << "Config loaded." << endl;
		}
		catch (...) {
			cout << "Invalid config." << endl;
		}
	}
	else {
		cout << "Config not found." << endl;
	}
}
string randomDuctTapeMessage(size_t length) {
	auto randchar = []() -> char
	{
		const char charset[] =
			"f"
			"m";
		const size_t max_index = (sizeof(charset) - 1);
		return charset[rand() % max_index];
	};
	std::string str(length, 0);
	std::generate_n(str.begin(), length, randchar);
	return str;
}
void OnPurchaseFailed(ENetPeer* peer, string reason) {
	string fail = "set_default_color|`o\nadd_label_with_icon|big|`4Purchase Failed``|left|1432|\nadd_spacer|small|\nadd_textbox|`w" + reason + "|\nadd_spacer|small|\nadd_button|backtoitemstore|`wBack|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|failedpurchase|";
	Player::OnDialogRequest(peer, fail);
}
void OnPurchaseSuccess(ENetPeer* peer, string text) {
	string fail = "set_default_color|`o\nadd_label_with_icon|big|`2Purchase Success``|left|112|\nadd_spacer|small|\nadd_textbox|`w" + text + "|\nadd_spacer|small|\nadd_button|backtoitemstore|`wBack|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|failedpurchase|";
	Player::OnDialogRequest(peer, fail);
}
inline void OnPurchaseRequest2(ENetPeer* peer, const int ItemID, const int Price, WorldInfo* world) {
	PlayerInfo* pData = (PlayerInfo*)peer->data;
	auto count = 1;
	auto ccount = 0;

	try {
		for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
			if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
				ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
				break;
			}
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
	int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
	int is_viso_worldlock = Price;
	while (is_viso_worldlock >= 100) {
		is_viso_worldlock -= 100;
		diamond_lock++;
	}
	world_lock = is_viso_worldlock;
	int turi_world_lock = atoi(GetItemCount(peer, 242).c_str());
	int turi_diamond_lock = atoi(GetItemCount(peer, 1796).c_str());
	while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
		turi_diamond_lock++;
		turi_world_lock -= 100;
	} if (diamond_lock > turi_diamond_lock) {
		Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
		return;
	} while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
		turi_diamond_lock--;
		turi_world_lock += 100;
	} if (world_lock > turi_world_lock) {
		Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
		return;
	}
	turi_world_lock -= world_lock;
	turi_diamond_lock -= diamond_lock;
	RemoveItemFromInv(peer, 242, atoi(GetItemCount(peer, 242).c_str()), true);
	RemoveItemFromInv(peer, 1796, atoi(GetItemCount(peer, 1796).c_str()), true);
	AddItemToInv(world, peer, 242, turi_world_lock);
	AddItemToInv(world, peer, 1796, turi_diamond_lock);
	AddItemToInv(world, peer, ItemID, count);
	Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
	Player::OnConsoleMessage(peer, "CP:_ `4[NOTIFICATION]: `$You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `9Wls`$.\n\n`4[NOTIFICATION]: `5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name);
}
void OnPurchaseRequest(ENetPeer* peer, int id, string price) {
	string sk = "set_default_color|\nadd_label_with_icon|big|`wPurchase " + getItemDef(id).name + "``|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `w" + getItemDef(id).name + "``|left|\nadd_spacer|small|\nadd_label|small|`2This item contains: `w" + getItemDef(id).name + "``|left|\nadd_spacer|small|\nadd_button|buyitem_" + to_string(id) + "|`9Purchase for - `9" + price + "Wls!|0|0|\nend_dialog|buyitem|``Close||\n\nadd_quick_exit|\n";
	Player::OnDialogRequest(peer, sk);
}
void playerRespawn(WorldInfo* world, ENetPeer* peer, bool isDeadByTile) {

	int netID = ((PlayerInfo*)(peer->data))->netID;
	if (isDeadByTile == false) {
		Player::OnKilled(peer, ((PlayerInfo*)(peer->data))->netID);
	}
	GamePacket p2x = packetEnd(appendInt(appendString(createPacket(), "OnSetFreezeState"), 0));
	memcpy(p2x.data + 8, &netID, 4);
	int respawnTimeout = 2000;
	int deathFlag = 0x19;
	memcpy(p2x.data + 24, &respawnTimeout, 4);
	memcpy(p2x.data + 56, &deathFlag, 4);
	ENetPacket* packet2x = enet_packet_create(p2x.data,
		p2x.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2x);
	delete p2x.data;
	Player::OnSetFreezeState(peer, 2, netID);



	int x = 3040;
	int y = 736;
	if (((PlayerInfo*)(peer->data))->respawnPos == -1)
	{
		try {
			for (int i = 0; i < world->width * world->height; i++)
			{
				if (world->items.at(i).foreground == 6) {
					x = (i % world->width) * 32 + 8;
					y = (i / world->width) * 32;
				}
			}
		}
		catch (std::exception& e) {
			std::cout << e.what() << std::endl;
		}
		catch (const std::out_of_range& e) {
			std::cout << e.what() << std::endl;
		}

	}
	else
	{
		x = (((PlayerInfo*)(peer->data))->respawnPos % world->width) * 32 + 8;
		y = (((PlayerInfo*)(peer->data))->respawnPos / world->width) * 32;
	}
	GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x, y));
	memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	respawnTimeout = 2000;
	memcpy(p2.data + 24, &respawnTimeout, 4);
	memcpy(p2.data + 56, &deathFlag, 4);
	ENetPacket* packet2 = enet_packet_create(p2.data,
		p2.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2);
	delete p2.data;
	GamePacket p2a = packetEnd(appendString(appendString(createPacket(), "OnPlayPositioned"), "audio/teleport.wav"));
	memcpy(p2a.data + 8, &netID, 4);
	respawnTimeout = 2000;
	memcpy(p2a.data + 24, &respawnTimeout, 4);
	memcpy(p2a.data + 56, &deathFlag, 4);
	ENetPacket* packet2a = enet_packet_create(p2a.data,
		p2a.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2a);
	delete p2a.data;
	if (player1 != "" && player2 != "" && reinterpret_cast<PlayerInfo*>(peer->data)->currentWorld == "DEATHMATCH")
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
			if (isHere(peer, currentPeer)) {
				if (peer != currentPeer) {
					((PlayerInfo*)(currentPeer->data))->gems += 500;
					((PlayerInfo*)(currentPeer->data))->playing = false;
					Player::OnConsoleMessage(currentPeer, "CP:0_PL:C_OID:_CT:[MSG]_ `c>> from (`2@SYSTEM`c) in [`4HIDDEN!`c] > You won 500 Gems!``");
					Player::PlayAudio(currentPeer, "audio/pay_time.wav", 0);
					for (auto currentPeers = server->peers; currentPeers < &server->peers[server->peerCount]; ++currentPeers) {
						if (currentPeers->state != ENET_PEER_STATE_CONNECTED) continue;
						if (!reinterpret_cast<PlayerInfo*>(currentPeers->data)->radio) continue;
						if (isHere(peer, currentPeer)) {
							Player::OnConsoleMessage(currentPeers, "`4***`` `5GrowtopiaTS```1-```5(party) Deathmatch EVENT(party) Winner - " + ((PlayerInfo*)(currentPeer->data))->tankIDName + " (Type /join)");
						}
					}
					sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
					((PlayerInfo*)(currentPeer->data))->currentWorld = "EXIT";
					sendWorldOffers(currentPeer);
					Player::OnTextOverlay(currentPeer, "You won 500 Gems!");
				}
			}
		}
		((PlayerInfo*)(peer->data))->playing = false;
		started = false;
		player1 = "";
		player2 = "";
		sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
		((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
		sendWorldOffers(peer);
		Player::OnTextOverlay(peer, "You lose!");
	}
}
void load_player(ENetPeer* peer, string username) {
	try {
		std::ifstream read_player("players/" + username + ".json");
		if (!read_player.is_open()) {
			return;
		}

		json j;
		read_player >> j;
		read_player.close();
		((PlayerInfo*)(peer->data))->rawName = j["username"].get<string>();
		((PlayerInfo*)(peer->data))->gems = j["gems"].get<int>();
		((PlayerInfo*)(peer->data))->displayName = j["displayName"].get<string>();
		((PlayerInfo*)(peer->data))->backupName = j["displayName"].get<string>();
		((PlayerInfo*)(peer->data))->adminLevel = j["adminLevel"].get<int>();
		((PlayerInfo*)(peer->data))->userID = j["userID"].get<int>();
		((PlayerInfo*)(peer->data))->xp = j["xp"].get<int>();
		((PlayerInfo*)(peer->data))->level = j["level"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_hair = j["hair"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_shirt = j["shirt"].get<int>();
		((PlayerInfo*)(peer->data))->skinColor = j["skin"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_hand = j["hand"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_mask = j["mask"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_back = j["wing"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_necklace = j["neck"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_face = j["face"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_ances = j["ances"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_pants = j["pants"].get<int>();
		((PlayerInfo*)(peer->data))->cloth_feet = j["feet"].get<int>();
		((PlayerInfo*)(peer->data))->bandate = j["bannedat"].get<int>();
		((PlayerInfo*)(peer->data))->ban = j["ban"].get<int>();
		((PlayerInfo*)(peer->data))->bantime = j["bantime"].get<int>();
		((PlayerInfo*)(peer->data))->lqueststep = j["lstep"].get<int>();
		((PlayerInfo*)(peer->data))->lquestprogress = j["lprogress"].get<int>();
		((PlayerInfo*)(peer->data))->ltype = j["ltype"].get<int>();
		((PlayerInfo*)(peer->data))->inventory.inventorySize = j["size"].get<int>();
		((PlayerInfo*)(peer->data))->xpboost = j["xpboost"].get<int>();
		((PlayerInfo*)(peer->data))->xptime = j["xptime"].get<int>();
		((PlayerInfo*)(peer->data))->isDuctaped = j["mute"].get<bool>();
		((PlayerInfo*)(peer->data))->isCursed = j["curse"].get<bool>();
		((PlayerInfo*)(peer->data))->joinguild = j["joinguild"].get<bool>();
		((PlayerInfo*)(peer->data))->guild = j["guild"].get<string>();
		((PlayerInfo*)(peer->data))->billboardid = j["billboardid"].get<int>();
		((PlayerInfo*)(peer->data))->billboardid = j["billboardtab"].get<int>();
		((PlayerInfo*)(peer->data))->billboardprice = j["billboardprice"].get<int>();
		((PlayerInfo*)(peer->data))->billboardperwhat = j["billboardperwhat"].get<int>();
		((PlayerInfo*)(peer->data))->ItemsOption = j["cape"].get<string>();
		((PlayerInfo*)(peer->data))->transform = j["transform"].get<int>();
		((PlayerInfo*)(peer->data))->friendinfo = j["friends"].get<vector<string>>();
		((PlayerInfo*)(peer->data))->showloc = j["showloc"].get<bool>();
		((PlayerInfo*)(peer->data))->lName = j["enableLName"].get<bool>();
		((PlayerInfo*)(peer->data))->blueName = j["enableBName"].get<bool>();
		((PlayerInfo*)(peer->data))->pure_state = j["pure"].get<int>();
		((PlayerInfo*)(peer->data))->worldsowned = j["worldsowned"].get<vector<string>>();
		((PlayerInfo*)(peer->data))->pin = j["pin"].get<string>();

		string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild);
		if (guildname != "") {
			try {
				std::ifstream ifff("guilds/" + guildname + ".json");
				if (ifff.fail()) {
					ifff.close();
					cout << "Failed loading guilds/" + guildname + ".json! From " + ((PlayerInfo*)(peer->data))->displayName + "." << endl;
					((PlayerInfo*)(peer->data))->guild = "";
				}
				json j;
				ifff >> j;
				ifff.close();
				int gfbg, gffg;
				string gstatement, gleader;
				vector<string> gmembers;
				gfbg = j["backgroundflag"];
				gffg = j["foregroundflag"];
				gstatement = j["GuildStatement"].get<string>();
				gleader = j["Leader"].get<string>();
				for (int i = 0; i < j["Member"].size(); i++) {
					gmembers.push_back(j["Member"][i]);
				}
				((PlayerInfo*)(peer->data))->guildBg = gfbg;
				((PlayerInfo*)(peer->data))->guildFg = gffg;
				((PlayerInfo*)(peer->data))->guildStatement = gstatement;
				((PlayerInfo*)(peer->data))->guildLeader = gleader;
				((PlayerInfo*)(peer->data))->guildMembers = gmembers;
			}
			catch (std::exception& e) {
				std::cout << e.what() << std::endl;
			}
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
int PlayerDB::playerLogin(ENetPeer* peer, string username, string password) {
	try {
		string pass3 = password;
		toLowerCase(username);
		toLowerCase(password);
		if (username.length() > 16) return -1;
		if (password.length() > 20) return -1;
		if (username == "" || password == "") return -1;


		std::ifstream read_player("players/" + username + ".json");
		if (!read_player.is_open()) {
			return -1;
		}
		json j;
		read_player >> j;
		read_player.close();
		string r_password = j["password"];
		int adminLevel2 = j["adminLevel"];
		toLowerCase(r_password);
		if (password == r_password) {
			bool exist = experimental::filesystem::exists("punishment/bans/" + username + ".txt");

			if (exist)
			{
				ifstream fd("punishment/bans/" + username + ".txt");
				long long n = 0;
				string bannedBy;
				string bannedReason;
				if (fd.fail()) {
					enet_peer_disconnect_later(peer, 0);
				}
				else
				{
					fd >> n;
					fd >> bannedBy;
					fd.ignore();
					getline(fd, bannedReason);
					fd.close();
				}
				int bantimeleft = calcBanDuration(n);
				if (bantimeleft > 1) {
					Player::OnConsoleMessage(peer, "`4Ban reason: `w" + bannedReason);
					Player::OnConsoleMessage(peer, "`4Issued by:`w " + bannedBy);
					Player::OnConsoleMessage(peer, "`4Ban duration:`o " + OutputBanTime(calcBanDuration(n)));
					enet_peer_disconnect_later(peer, 0);
				}
			}
			if (j["ban"] == 1) {
				string who = username;

				string value = "`4Sorry, this account, device or location has been temporarily banned. `oIf you didn't do anything wrong, it could be because you're playing from the same place or on the same device as someone who did. Visit at `5" + discord + " `oif you have any questions. This is temporary ban caused by `w" + username + "`o and will be removed in `w729 days`o.";

				BlockLoginNoUrl(peer, value);

			}
			bool found = false;
			for (int i = 0; i < admins.size(); i++) {
				if (admins[i].username == username) {
					found = true;
				}
			}
			if (!found) {//not in vector
				if (adminLevel2 != 0) {
					Admin admin;
					admin.username = PlayerDB::getProperName(username);
					admin.password = static_cast<PlayerInfo*>(peer->data)->tankIDPass;
					admin.level = adminLevel2;
					admins.push_back(admin);
				}
			}
			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
					continue;
				if (currentPeer == peer)
					continue;
				if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(username))
				{
					{
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Someone else logged into this account!"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(currentPeer, 0, packet);
						delete p.data;
					}
					{
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Someone else was logged into this account! He was kicked out now."));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						//enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					((PlayerInfo*)(currentPeer->data))->disconnect_ = true;
					FlushPlayer(currentPeer);
					enet_peer_disconnect_later(currentPeer, 0);
				}
			}
			((PlayerInfo*)(peer->data))->hasLogon = true;
			int lol = (int)j["invisize"];
			int lol1 = (int)j["size"];

			PlayerInventory inv;
			inv.inventorySize = lol1;
			json items = j["inventory"];
			for (int i = 0; i < lol; i++) {
				InventoryItem it;
				try {
					it.itemID = items[i]["id"].get<int>();
					it.itemCount = items[i]["count"].get<int>();
				}
				catch (nlohmann::json::exception ex) {
					continue;
				}
				inv.items.push_back(it);
			}
			((PlayerInfo*)(peer->data))->inventory = inv;

			if (std::experimental::filesystem::exists("playtime/" + ((PlayerInfo*)(peer->data))->rawName + ".txt")) {
				string current_playtime = "";
				ifstream playtimeglobal_read("playtime/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
				playtimeglobal_read >> current_playtime;
				playtimeglobal_read.close();
				((PlayerInfo*)(peer->data))->play_time = atoi(current_playtime.c_str());
			}

			return 1;
		}
		else {
			return -1;
		}
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
		std::fstream chas("corrupt.txt", std::ios::in | std::ios::out | std::ios::ate);
		chas << username << endl;
		chas.close();
		Player::OnConsoleMessage(peer, "`4Oops! `oSomething is wrong!");
		return -300;
	}
}



void SendConsoleMsgAll(ENetPeer* peer, string message) {
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), message));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
			continue;
		if (isHere(peer, currentPeer))
		{
			enet_peer_send(currentPeer, 0, packet);
		}
	}
	delete p.data;
}
bool has_only_digits(const string s) {
	return s.find_first_not_of("0123456789") == string::npos;
}
bool has_only_digits_wnegative(const string s) {
	return s.find_first_not_of("-0123456789") == string::npos;
}
bool is_number(const string act) {
	bool contains_non_int2 = !std::regex_match(act, std::regex("^[0-9]+$"));
	if (contains_non_int2) {
		cout << "false" << endl;
		return false;
	}
	else {
		cout << "true" << endl;
		return true;
	}
}

inline void restore_prices() {
	try {
		char oldname[] = "price_data.txt";
		char newname[] = "price_data1.txt";
		char oldname1[] = "price_data1.txt";
		char newname1[] = "price_data2.txt";
		char oldname2[] = "price_data2.txt";
		char newname2[] = "price_data3.txt";
		auto kaina = 0;
		string append = "";
		int drop_k = 0;
		int rise_k = 0;
		srand(time(nullptr)); /*reset the seed*/
		for (int i = 0; i <= CoreDataItems; i++) {
			kaina = -1;
			if (itemDefs.at(i).blockType == BlockTypes::SIGN && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::DEADLY && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::GATEWAY && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::DOOR && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::PAIN_BLOCK && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::PLATFORM && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::BACKGROUND && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::FOREGROUND && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::SFX_FOREGROUND && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::ANIM_FOREGROUND && itemDefs.at(i).rarity != 999 || itemDefs.at(i).blockType == BlockTypes::TOGGLE_FOREGROUND && itemDefs.at(i).rarity != 999) {
				/*per world lock*/
				int past_price = 0;
				ifstream infile("price_data.txt");
				for (string line; getline(infile, line);) {
					if (line.length() > 3 && line[0] != '/' && line[1] != '/') {
						auto ex = explode("|", line);
						if (ex[0] == to_string(i)) {
							past_price = atoi(ex[1].c_str());
							break;
						}
					}
				}
				infile.close();
				vector<float>rise{ 1.01,1.02,1.03,1.04,1.05,1.06,1.07,1.08,1.09 };
				vector<float>fall{ 0.91,0.92,0.93,0.94,0.95,0.96,0.97,0.98,0.99 };
				bool r_rise = (rand() % 2) != 0;
				if (r_rise) { /*rise*/
					float rise_num = rise.at(rand() % rise.size());
					past_price *= rise_num;
					rise_k++;
				}
				else { /*fall*/
					float fall_num = fall.at(rand() % fall.size());
					past_price *= fall_num;
					drop_k++;
				}
				kaina = past_price;
				if (kaina > 250 && i != 9498 && i != 5154 && i != 5140 && i != 5138 && i != 5136 && i != 7382 && i != 4762) kaina = 250;
				if (kaina < 1) kaina = 1;
				if (i == 7188) kaina = 100;
			}
			else {
				int past_price = 0;
				ifstream infile("price_data.txt");
				for (string line; getline(infile, line);) {
					if (line.length() > 3 && line[0] != '/' && line[1] != '/') {
						auto ex = explode("|", line);
						if (ex[0] == to_string(i)) {
							past_price = atoi(ex[1].c_str());
							break;
						}
					}
				}
				infile.close();
				vector<float>rise{ 1.01,1.02,1.03,1.04,1.05,1.06,1.07,1.08,1.09 };
				vector<float>fall{ 0.91,0.92,0.93,0.94,0.95,0.96,0.97,0.98,0.99 };
				bool r_rise = (rand() % 2) != 0;
				if (r_rise) { /*rise*/
					float rise_num = rise.at(rand() % rise.size());
					past_price *= rise_num;
					rise_k++;
				}
				else { /*fall*/
					float fall_num = fall.at(rand() % fall.size());
					past_price *= fall_num;
					drop_k++;
				}
				kaina = past_price;
				if (kaina > 25000) kaina = 25000;
				if (kaina < 1) kaina = 1;
				if (i == 7188) kaina = 100;
			}
			append += to_string(i) + "|" + to_string(kaina) + "|0\n";
		}
		remove("price_data3.txt");
		if (rename(oldname2, newname2) != 0) {
			cout << "Filesystem Exception #3 Failed to rename file" << endl;
		}
		remove("price_data2.txt");
		if (rename(oldname1, newname1) != 0) {
			cout << "Filesystem Exception #2 Failed to rename file" << endl;
		}
		remove("price_data1.txt");
		if (rename(oldname, newname) != 0) {
			cout << "Filesystem Exception #1 Failed to rename file" << endl;
		}
		remove("price_data.txt");
		ofstream breaklogs("price_data.txt", ios::app);
		breaklogs << append;
		breaklogs.close();
		if (drop_k > rise_k) {
			cout << "`oGrowtech shows that item prices averagely started to `4drop`o!" << endl;
		}
		else
			cout << "`oGrowtech shows that item prices averagely started to `2rise`o!" << endl;
		cout << "Item prices were refreshed" << endl;
	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
	}
	catch (const std::out_of_range& e) {
		std::cout << e.what() << std::endl;
	}
}
#ifdef _WIN32
int _tmain(int argc, _TCHAR* argv[])
#else
int main()
#endif

{
	srand(time(nullptr));

	cout << "Growheaven private server, made by Finland#1337" << endl;
	cout << "Loading config!" << endl;
	cout << "Loading dialogs!" << endl;
	loadnews();
	loadConfig();
	std::ifstream t("uids.txt");
	std::string str((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());
	userIDcount = atoi(str.c_str());
	std::ifstream st("ipban.txt");
	std::string strs((std::istreambuf_iterator<char>(st)), std::istreambuf_iterator<char>());
	ipban = strs;
	cout << "Total UserID's " << userIDcount << endl;
	enet_initialize();
	signal(SIGINT, exitHandler);

	//world = generateWorld();c
	cout << "Loading default worlds" << endl;
	worldDB.get("TEST");

	ENetAddress address;
	/* Bind the server to the default localhost.     */
	/* A specific host address can be specified by   */
	enet_address_set_host(&address, "0.0.0.0");
	//address.host = ENET_HOST_ANY;
	/* Bind the server to port 1234. */
	address.port = configPort;
	server = enet_host_create(&address /* the address to bind the server host to */,
		1024      /* allow up to 32 clients and/or outgoing connections */,
		10      /* allow up to 2 channels to be used, 0 and 1 */,
		0      /* assume any amount of incoming bandwidth */,
		0      /* assume any amount of outgoing bandwidth */);
	if (server == NULL)
	{
		fprintf(stderr, " An error occurred while trying to create an ENet server host.\n");
		while (1);
		exit(EXIT_FAILURE);
	}
	server->checksum = enet_crc32;
	enet_host_compress_with_range_coder(server);

	buildItemsDatabase();
	//restore_prices();
	//threads.push_back(std::thread(autoSaveWorlds));

	ENetEvent event;
	/* Wait up to 1000 milliseconds for an event. */
	while (true)
	{
		while (enet_host_service(server, &event, 1000) > 0)
		{
			ENetPeer* peer = event.peer;
			switch (event.type) {
			case ENET_EVENT_TYPE_CONNECT: {
				event.peer->data = new PlayerInfo;
				/* Get the string ip from peer */
				char clientConnection[16];
				enet_address_get_host_ip(&peer->address, clientConnection, 16);
				((PlayerInfo*)(peer->data))->charIP = clientConnection;
				if (ipban.find(((PlayerInfo*)(peer->data))->charIP + ",") != std::string::npos) {
					Player::OnConsoleMessage(peer, "`rThis ip being banned.``");
					enet_peer_disconnect_later(peer, 0);
				}
				else sendData(peer, 1, 0, 0);
				continue;
			}
			case ENET_EVENT_TYPE_RECEIVE:
			{
				if (((PlayerInfo*)(peer->data))->isUpdating)
				{
					cout << "packet drop" << endl;
					continue;
				}
				if (!peer) continue;

				if (event.peer->data == nullptr) continue;

				if (((PlayerInfo*)(peer->data))->ignorePackets) continue;

				if (event.packet->dataLength < 5 || event.packet->dataLength > 1000) {
					break;
				}
				if (((PlayerInfo*)(peer->data))->kipaskiek_turi_kainoti >= 3) {
					Player::OnConsoleMessage(peer, "`4Please wait you will be disconnected..!");
					enet_peer_disconnect_later(peer, 0);
					break;
				}
				if (((PlayerInfo*)(peer->data))->lastPPS + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
					((PlayerInfo*)(peer->data))->pps = 0;
					((PlayerInfo*)(peer->data))->lastPPS = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				}
				else {
					((PlayerInfo*)(peer->data))->pps++;
					if (((PlayerInfo*)(peer->data))->pps >= 90) {
						Player::OnConsoleMessage(peer, "Your client sending too many packet, Disconnecting...");
						enet_peer_disconnect_later(peer, 0);
					}
				}
				int messageType = GetMessageTypeFromPacket(event.packet);

				WorldInfo* world = worldDB.get_pointer(((PlayerInfo*)(peer->data))->currentWorld);
				if (world == NULL) continue;
				switch (messageType) {
				case 2:
				{
					//if (logs)	cout << "" << GetTextPointerFromPacket(event.packet) << endl;

					string cch = GetTextPointerFromPacket(event.packet);

					if (cch.find("action|getDRAnimations") == 0 || cch == "" || cch == " " || cch == "   " || cch == "    " || cch == "      " || cch == "            " || cch.size() > 10000) break;
					if (((PlayerInfo*)(peer->data))->lastPackets + 40 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
					{
						((PlayerInfo*)(peer->data))->lastPackets = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					}
					else {
						if (serverIsFrozen == false) ((PlayerInfo*)(peer->data))->warn++;
						if (((PlayerInfo*)(peer->data))->warn >= 5)
						{
							Player::OnConsoleMessage(peer, "Your client sending too many packet, Disconnecting...");
							enet_peer_disconnect_later(peer, 0);
							break;
						}
					}

					if (((PlayerInfo*)(peer->data))->warncheck2 >= 6) {
						if (((PlayerInfo*)(peer->data))->haveGrowId) {
							Player::OnConsoleMessage(peer, "`4You've been detected for cheating.");
							enet_peer_disconnect_later(peer, 0);
						}
						break;
					}

					if (cch.find("action|wrench") == 0) {
						if (((PlayerInfo*)(peer->data))->haveGrowId == false || world->name == "EXIT") continue;
						int id = atoi(explode("\n", explode("|", cch).at(3)).at(0).c_str());
						if (id < 0) {
							Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "This player has left", true);
							continue; //not found
						}

						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
								continue;

							if (isHere(peer, currentPeer)) {
								PlayerInfo* cp = ((PlayerInfo*)(currentPeer->data));
								PlayerInfo* p = ((PlayerInfo*)(peer->data));
								if (((PlayerInfo*)(currentPeer->data))->netID == id) {

									int lastuid = ((PlayerInfo*)(currentPeer->data))->userID;
									((PlayerInfo*)(peer->data))->lastUserID = lastuid;
									((PlayerInfo*)(peer->data))->lastuser = ((PlayerInfo*)(currentPeer->data))->rawName;

									if (p->rawName == cp->rawName) {
										string Invited = "", Rank = "", JoinGuild = "", wew = "", GNote = "", buffs = "", itemoptions = "";
										int xxx = p->x / 32;
										int yyy = p->y / 32;
										if (p->isinvited == true) Invited = "\nadd_button|joinguild|`2Join Guild " + cp->guildlast + "!|\nadd_spacer|small|";
										if (p->rawName == p->guildLeader) Rank = "Leader";
										else Rank = "Member";
										if (p->joinguild == true) {
											JoinGuild = "\nadd_dual_layer_icon_label|right|`9Guild:`2 " + p->guild + "|right|" + std::to_string(p->guildBg) + "|" + std::to_string(p->guildFg) + "|1|2|\nadd_textbox|`9Rank: `2" + Rank + "|\nadd_spacer|small|\n";
											GNote = "\nadd_button|GuildNotebook|`$Guild Notebook Of " + p->guild + "|0|0|";
										}
										//if (p->cloth_back == 10424) itemoptions += "\nadd_button|riftoptions|`$Rift Cape|noflags|0|0|";
										int shoes = ((PlayerInfo*)(peer->data))->cloth_feet;
										if (isPickaxe(peer)) buffs += "|\nadd_label_with_icon|small|`wEnchanced Digging``|left|" + to_string(((PlayerInfo*)(peer->data))->cloth_hand) + "|";
										if (shoes == 8834 || shoes == 496 || shoes == 592 || shoes == 1012 || shoes == 1018 || shoes == 1176 || shoes == 1178 || shoes == 1278 || shoes == 1274 || shoes == 1320 || shoes == 1496 || shoes == 1582 || shoes == 1740 || shoes == 1758 || shoes == 1940 || shoes == 1978 || shoes == 1822 || shoes == 2048 || shoes == 2064 || shoes == 2214 || shoes == 2230 || shoes == 2384 || shoes == 2394 || shoes == 2574 || shoes == 2864 || shoes == 2974 || shoes == 2984 || shoes == 3068 || shoes == 3074 || shoes == 3118 || shoes == 3650 || shoes == 3250 || shoes == 3652 || shoes == 3654 || shoes == 3656 || shoes == 3658 || shoes == 3660 || shoes == 3662 || shoes == 3664 || shoes == 3666 || shoes == 3696 || shoes == 3788 || shoes == 4112 || shoes == 4114 || shoes == 4116 || shoes == 4118 || shoes == 4152 || shoes == 4262 || shoes == 4168 || shoes == 4536 || shoes == 4662 || shoes == 4714 || shoes == 4948 || shoes == 4990 || shoes == 5012 || shoes == 5018 || shoes == 5210) buffs += "\nadd_label_with_icon|small|`wSpeedy|left|496|";
										if (p->cloth_ances == 5082 || p->cloth_ances == 5162 || p->cloth_ances == 5164 || p->cloth_ances == 5166 || p->cloth_ances == 5168 || p->cloth_ances == 5170) buffs += "\nadd_label_with_icon|small|`w" + getItemDef(p->cloth_ances).name + "|left|" + std::to_string(p->cloth_ances) + "|";
										if (p->cloth_ances == 7166 || p->cloth_ances == 7168 || p->cloth_ances == 7170 || p->cloth_ances == 7172 || p->cloth_ances == 7174 || p->cloth_ances == 9212) buffs += "\nadd_label_with_icon|small|`w" + getItemDef(p->cloth_ances).name + "|left|" + std::to_string(p->cloth_ances) + "|";
										if (p->isDuctaped) buffs += "|\nadd_label_with_icon|small|`wDuct tape covered your mouth!``|left|408|";
										if (p->isCursed) buffs += "\nadd_label_with_icon|small|`wI can't go anywhere. (Cursed)``|left|3106|";
										if (p->cloth_hand == 1804) buffs += "\nadd_label_with_icon|small|`wFistful Of Thunder|left|1804|";
										if (p->cloth_face == 1204) buffs += "\nadd_label_with_icon|small|`wFocused Eyes|left|1204|";
										if (p->cloth_hand == 1874) buffs += "\nadd_label_with_icon|small|`wRing Of Force|left|1874|";
										if (p->blueBerry) buffs += "\nadd_label_with_icon|small|A `1blueberry`o slides down your throat! `$(`o5`$ seconds left`$)``|left|196|";
										if (p->Caffeine) buffs += "\nadd_label_with_icon|small|You are full of caffeine! `$(`o5`$ seconds left`$)``|left|1634|";
										if (p->cloth_back == 8552) buffs += "\nadd_label_with_icon|small|`wDouble Jump and Slowfall: Angel Of Mercy!|left|8552|";
										if (p->cloth_hand == 2952) buffs += "\nadd_label_with_icon|small|`wDig, Dug.|left|2952|";
										if (p->cloth_feet == 250) buffs += "\nadd_label_with_icon|small|`wFireproof|left|250|";
										if (p->cloth_face == 138) buffs += "\nadd_label_with_icon|small|`wEye Beam|left|138|";
										if (p->cloth_mask == 1216) buffs += "\nadd_label_with_icon|small|`wCultist Hood|left|1216|";
										if (p->cloth_hand == 6840) buffs += "|\nadd_label_with_icon|small|`wHarvester!``|left|" + to_string(((PlayerInfo*)(peer->data))->cloth_hand) + "|";
										if (p->cloth_hand == 2204) buffs += "\nadd_label_with_icon|small|`wGeiger Counting|left|2204|";
										if (p->cloth_hand == 2592) buffs += "\nadd_label_with_icon|small|`wLegendary Swordmaster|left|2592|";
										if (p->cloth_back == 10424) buffs += "|\nadd_label_with_icon|small|`wDouble jump: Rift Cape!``|left|10424|";
										if (p->cloth_back == 10418 || p->cloth_back == 10420) buffs += "|\nadd_label_with_icon|small|`wFlying and Double jump``|left|" + to_string(((PlayerInfo*)(peer->data))->cloth_back) + "|";
										else if (p->canDoubleJump && p->cloth_back != 10424 && p->cloth_back != 8552) buffs += "|\nadd_label_with_icon|small|`wDouble jump``|left|156|";
										if (p->canWalkInBlocks) buffs += "|\nadd_label_with_icon|small|`wI can walk in blocks. (Ghost)``|left|3106|";
										if (p->isInvisible) buffs += "|\nadd_label_with_icon|small|`wNinja, invisible to all!``|left|290|";
										if (p->cloth_hand == 10952 || p->cloth_hand == 10954 || p->cloth_hand == 10956 || p->cloth_hand == 10958 || p->cloth_hand == 10960) wew += "\nadd_custom_button|transform_alien|image:interface/large/gui_wrench_space_animals_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|||";
										if (p->cloth_face == 11506) wew += "\nadd_custom_button|dragonpass|image:interface/large/gui_wrench_mask_dragon_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|||";
										if (p->cloth_necklace == 11560 || p->cloth_necklace == 11554 || p->cloth_necklace == 11556 || p->cloth_necklace == 11558) {
											wew += "\nadd_custom_button|Ezio|image:interface/large/gui_wrench_u_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";

										}


										if (wew != "") wew += "\nadd_custom_break|\nadd_spacer|small|\nset_custom_spacing|x:0;y:0|";
										string me = "set_default_color|`o\nadd_player_info|`w" + p->displayName + "|" + to_string(p->level) + "|" + to_string(p->xp) + "|" + std::to_string(GetMaxExpForNextLevel(((PlayerInfo*)(peer->data))->level)) + "|" + Invited + JoinGuild + "\nadd_spacer|small|" + wew + itemoptions + "\nadd_button|aapbutton|`5Account Security``|\nadd_button|billboardchange|`$Edit Billboard``|\nadd_textbox|`wActive effects:|" + buffs + "\nadd_spacer|small|\nadd_textbox|You have `w" + to_string(((PlayerInfo*)(peer->data))->inventory.inventorySize) + "`o backpack slots.|\nadd_textbox|Current world: `w" + p->currentWorld + " `o(`w" + std::to_string(xxx) + "`o, `w" + std::to_string(yyy) + "`o) (`w" + std::to_string(getPlayersCountInWorld(p->currentWorld)) + "`o person)````|\nadd_textbox|`oYou are not yet a `2Supporter `oor `5Super Supporter`o.````|\nadd_spacer|small|\nadd_button|growmojis|`$Growmojis``|0|0|\nadd_textbox|`oTotal time played is `w" + to_string(((PlayerInfo*)(peer->data))->play_time) + "`` `ominutes.``|left|\nadd_spacer|small|\nadd_button|con|`wContinue|\nadd_quick_exit|\nend_dialog|me|";
										Player::OnDialogRequest(peer, me);

									}
									else if (p->rawName != cp->rawName) {
										if (world->name == "DEATHMATCH") {
											Player::OnTextOverlay(peer, "Sorry, but you can't doing this while playing death match game.");
											break;
										}
										string Rank = "", R1 = "", R2 = "", R3 = "";
										if (cp->rawName == cp->guildLeader) Rank = "Leader";
										else Rank = "Member";
										if (cp->guild != "") R1 = "\nadd_spacer|small|\nadd_dual_layer_icon_label|right|`9Guild:`2 " + cp->guild + "|right|" + std::to_string(cp->guildBg) + "|" + std::to_string(cp->guildFg) + "|1|2|\nadd_textbox|`9Rank: `2" + Rank + "|";
										if (p->joinguild == true && cp->guild == "") R3 = "\nadd_button|inviteguildbutton|`2Invite To Guild|0|0|";
										if (cp->joinguild == true && cp->guild != "") R3 = "";

										string Role = "";
										if (cp->adminLevel == 3) Role = "`6@Developer";
										if (cp->adminLevel == 2) Role = "`6@Administrator";
										if (cp->adminLevel == 1) Role = "`#@Moderator";
										if (cp->adminLevel == 0) Role = "`wPlayer";

										if (adminLevel(peer) < 1)
										{
											if (cp->guild != "") {
												if (isWorldOwner(peer, world) || p->adminLevel > 0 || isWorldAdmin(peer, world)) {
													string dd = "set_default_color|`o\nadd_label_with_icon|big|`w" + cp->displayName + " `w(`2" + to_string(cp->level) + "`w)|left|18|" + R1 + "\nadd_spacer|small|\nadd_textbox|`oRole: " + Role + "|\nadd_textbox|`oGems: " + std::to_string(cp->gems) + "|left|\nadd_spacer|small|\nadd_button|trade|`wTrade|\nadd_button|pull|`5Pull|\nadd_button|kick|`4Kick|\nadd_button|worldban|`4World Ban|\nadd_button|addfriendrnbutton|`wAdd as friend|" + R2 + R3 + "\nadd_button|reportplayer|`wReport Player|\nadd_spacer|small|\nadd_button|con|`wContinue|\nadd_quick_exit|\nend_dialog|dkdkdk|";
													Player::OnDialogRequest(peer, dd);

												}
												else {

													string dd = "set_default_color|`o\nadd_label_with_icon|big|`w" + cp->displayName + " `w(`2" + to_string(cp->level) + "`w)|left|18|" + R1 + "\nadd_spacer|small|\nadd_textbox|`oRole: " + Role + "|\nadd_textbox|`oGems: " + std::to_string(cp->gems) + "|left|\nadd_spacer|small|\nadd_button|trade|`wTrade|\nadd_button|addfriendrnbutton|`wAdd as friend|" + R2 + R3 + "\nadd_button|reportplayer|`wReport Player|\nadd_spacer|small|\nadd_button|con|`wContinue|\nadd_quick_exit|\nend_dialog|dkdkdk|";
													Player::OnDialogRequest(peer, dd);
												}
											}
											else {
												if (isWorldOwner(peer, world) || p->adminLevel > 0 || isWorldAdmin(peer, world)) {
													string dd = "set_default_color|`o\nadd_label_with_icon|big|`w" + cp->displayName + " `w(`2" + to_string(cp->level) + "`w)|left|18|" + R1 + "\nadd_spacer|small|\nadd_textbox|`oRole: " + Role + "|\nadd_textbox|`oGems: " + std::to_string(cp->gems) + "|left|\nadd_spacer|small|\nadd_button|trade|`wTrade|\nadd_button|pull|`5Pull|\nadd_button|kick|`4Kick|\nadd_button|worldban|`4World Ban|\nadd_button|addfriendrnbutton|`wAdd as friend|" + R2 + R3 + "\nadd_button|reportplayer|`wReport Player|\nadd_spacer|small|\nadd_button|con|`wContinue|\nadd_quick_exit|\nend_dialog|dkdkdk|";
													Player::OnDialogRequest(peer, dd);

												}
												else {
													string dd = "set_default_color|`o\nadd_label_with_icon|big|`w" + cp->displayName + " `w(`2" + to_string(cp->level) + "`w)|left|18|" + R1 + "\nadd_spacer|small|\nadd_textbox|`oRole: " + Role + "|\nadd_textbox|`oGems: " + std::to_string(cp->gems) + "|left|\nadd_spacer|small|\nadd_button|trade|`wTrade|\nadd_button|addfriendrnbutton|`wAdd as friend|" + R2 + R3 + "\nadd_button|reportplayer|`wReport Player|\nadd_spacer|small|\nadd_button|con|`wContinue|\nadd_quick_exit|\nend_dialog|dkdkdk|";
													Player::OnDialogRequest(peer, dd);
												}

											}
										}
										else {

											string leke = "set_default_color|`o\nadd_label_with_icon|big|`w" + cp->displayName + " `w(`2" + std::to_string(cp->level) + "`w)|left|18|" + R1 + "\nadd_spacer|small|\nadd_textbox|`oRole: " + Role + "|\nadd_textbox|`oGems: " + std::to_string(cp->gems) + "|left|\nadd_spacer|small|\nadd_button|trade|`wTrade|\nadd_button|addfriendrnbutton|`wAdd as friend|" + R2 + R3 + "\nadd_button|reportplayer|`wReport Player|\nadd_button|pull|`5Pull|\nadd_button|kick|`4Kick|\nadd_button|worldban|`4World Ban|\nadd_button|punishview|`1Punish/View|\nadd_spacer|small|\nadd_button|con|`wContinue|\nadd_quick_exit|\nend_dialog|dkdkdk|";
											Player::OnDialogRequest(peer, leke);
										}


									}

								}

							}

						}
					}

					if (cch.find("action|AccountSecurity") == 0) {
						if (((PlayerInfo*)(peer->data))->haveGrowId == false || world->name == "EXIT") continue;
						Security_Pin(peer);
					}

					if (cch.find("action|friends") == 0) {
						if (((PlayerInfo*)(peer->data))->haveGrowId == false || world->name == "EXIT") continue;
						if (((PlayerInfo*)(peer->data))->joinguild == true) {
							Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|`wShow Friends``|0|0|\nadd_button|CommunityHub|`wCommunity Hub|0|0|\nadd_button|ShowApprentices|`wShow Apprentices|0|0|\nadd_button|showguild|`wShow Guild Members``|0|0|\nadd_button|guildrewards|Guild Rewards``|0|0|\nadd_spacer|small|\nadd_button|backfriend2|`wBack|0|0|\nadd_quick_exit|");
						}
						else {
							Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|`wShow Friends``|0|0|\nadd_button|CommunityHub|`wCommunity Hub|0|0|\nadd_button|ShowApprentices|`wShow Apprentices|0|0|\nadd_button|createguildinfo|`wCreate Guild``|0|0|\nadd_spacer|small|\nadd_button|backfriend2|`wBack|0|0|\nadd_quick_exit|");
						}
					}

					if (cch.find("action|respawn") == 0)
					{
						if (((PlayerInfo*)(peer->data))->haveGrowId == false || world->name == "EXIT") continue;

						if (cch.find("action|respawn_spike") == 0) {
							playerRespawn(world, peer, true);
						}
						else
						{
							playerRespawn(world, peer, false);
						}
					}
					if (cch.find("action|setSkin") == 0) {
						if (((PlayerInfo*)(peer->data))->haveGrowId == false || world->name == "EXIT") continue;
						string id_ = explode("\n", explode("|", cch).at(2)).at(0);
						if (not isdigit(id_[0])) break;
						char* endptr = NULL;
						unsigned int skin_ = strtoll(id_.c_str(), &endptr, 10);
						if (skin_ != 1348237567 and skin_ != 1685231359 and skin_ != 2022356223 and skin_ != 2190853119 and skin_ != 2527912447 and skin_ != 2864971775 and skin_ != 3033464831 and skin_ != 3370516479) break;
						((PlayerInfo*)(peer->data))->skinColor = skin_;
						sendClothes(peer);
					}

					if (cch.find("action|store") == 0 || cch == "action|buy\nitem|main\n")
					{
						if (((PlayerInfo*)(peer->data))->haveGrowId == false || world->name == "EXIT") continue;
						doCancelTrade(peer);
						/*string d = "set_default_color|`o\nadd_label|big|`wGrowtopiaTS Store``|\ntext_scaling_string|iiiiiiiiiiiiiiiiiiiiiiiiiii||\nadd_spacer|small|\nadd_textbox|`wWhat are you looking for? Maybe some shiny clothes?|\nadd_spacer|small|\nadd_label_with_icon|small|`oYou Currently Have " + to_string(((PlayerInfo*)(peer->data))->gems) + " `9Gems|left|112|\nadd_textbox|`2Items available to purchase:|\nadd_button_with_icon|buy_5480||staticBlueFrame|5480|400000|\nadd_button_with_icon|buy_1874||staticBlueFrame|1874|200000|\nadd_button_with_icon|buy_2952||staticBlueFrame|2952|100000|\nadd_button_with_icon|buy_8552||staticBlueFrame|8552|200000|\nadd_button_with_icon|buy_8286||staticBlueFrame|8286|80000|\nadd_button_with_icon|buy_1460||staticBlueFrame|1460|60000|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|buy_1970||staticBlueFrame|1970|60000|\nadd_button_with_icon|buy_1674||staticBlueFrame|1674|60000|\nadd_button_with_icon|buy_1204||staticBlueFrame|1204|30000|\nadd_button_with_icon|buy_1790||staticBlueFrame|1790|1000000|\nadd_button_with_icon|buy_9428||staticBlueFrame|9428|100000|\nadd_button_with_icon|buy_5188||staticBlueFrame|5188|95000|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button_with_icon|buy_5638||staticBlueFrame|5638|500000|\nadd_button_with_icon|buy_10424||staticBlueFrame|10424|200000|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|bassets|`wPurchase `1in-game assets|floor|\nadd_button|bxp|`wPurchase `1XP-BOOST|four|\nadd_spacer|small|\nadd_smalltext|`oClick the item you want to purchase!|\nadd_spacer|small|\nadd_button|close|`wClose|\nadd_quick_exit|\nend_dialog|storedialog||\n";
						Player::OnDialogRequest(peer, d);*/

						string items_here = "";

						/*items_here += "set_description_text|Welcome to the `2GrowtopiaTS Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `520000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
						items_here += "\nenable_tabs|1";
						items_here += "\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";
						items_here += "\nadd_image_button|image_button|interface/large/gui_shop_grow_pass.rttex|bannerlayout|OPENDIALOG|battlepasspopup|";
						items_here += "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|2|";
						items_here += "\nadd_button|gems_glory|Road To Glory|interface/large/store_buttons/store_buttons30.rttex|https://discord.gg/ShEGxYwuVF|0|0|0|||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|1|0|`2You Get:`` Road To Glory and 100k Gems Instantly.<CR>`5Description:`` Earn Gem rewards when you level up. Every 10 levels you will get additional Gem rewards up to Level 50! Claim all rewards instantly if you are over level 50!! 1.6M Gems in total!! |1||||||0|0|";
						items_here += "\nadd_button|gems_bundle06|Gem Abundance|interface/large/store_buttons/store_buttons37.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=8DYMZNDDSQ2BU&custom=48468333-227C3E7556B53E1709FF6612A6C8AAE3|2|1|0|||interface/large/gui_store_button_overlays1.rttex|1|1||-1|-1|`2You Get:`` 1,850,000 Gems, 10 Growtokens and 5 Megaphones<CR><CR>`2Voucher Dayz Bonus!`` `1Plus`` `225 Grow Vouchers!``<CR><CR>`5Description:`` Get an abundance of gems to add to your wealth!|1||||||0|0|";
						items_here += "\nadd_button|gems_bundle05|Gem Bounty|interface/large/store_buttons/store_buttons34.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=9UGSFAQBW25JN&custom=48468333-788459637FB94AFEE8C29D4EBEABC9D1|0|6|0|||interface/large/gui_store_button_overlays2.rttex|1|5||-1|-1|`2You Get:`` 1,100,000 Gems, 6 Growtokens and 3 Megaphones<CR><CR>`2Voucher Dayz Bonus!`` `1Plus`` `215 Grow Vouchers!``<CR><CR>`5Description:`` Get a plethora of gems to add to your wealth!|1||||||0|0|";
						items_here += "\nadd_button|gems_rain|It's Rainin' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=4LKDNBCBJ6VU2&custom=48468333-39FED8C9539C201AE7F5C2898087D4EA|1|5|0|||interface/large/gui_store_button_overlays3.rttex|1|5||-1|-1|`2You Get:`` 350,000 Gems, 2 Growtokens and 1 Megaphone.<CR><CR>`2Voucher Dayz Bonus!`` `1Plus`` `24 Grow Vouchers!``<CR><CR>`5Description:`` All the gems you could ever want and more plus 2 Growtokens and a Megaphone to tell the whole world about it.|1||||||0|0|";
						items_here += "\nadd_button|gems_fountain|Gem Fountain|interface/large/store_buttons/store_buttons2.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=K4TTXUZCXNTEL&custom=48468333-B2D3A1F84BEDB57BD1A2B746C0CE20EA|0|2|0|||interface/large/gui_store_button_overlays3.rttex|0|5||-1|-1|`2You Get:`` 155,000 Gems and 1 Growtoken.<CR><CR>`2Voucher Dayz Bonus!`` `1Plus`` `21 Grow Voucher!``<CR><CR>`5Description:`` Get a pile of gems to shop to your hearts desire and 1 Growtoken.|1||||||0|0|";
						items_here += "\nadd_button|gems_chest|Chest o' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=RV5RH3PVCPUR8&custom=48468333-7F84D8C31BA715DFE13B9DC1DBEC1A6E|0|5|0||||-1|-1||-1|-1|`2You Get:`` 55,000 Gems.<CR><CR>`5Description:`` Get a chest containing gems.|1||||||0|0|";
						items_here += "\nadd_button|gems_bag|Bag o' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=E9GPTE453VRJU&custom=48468333-90D2847FFC08DDE14A916BB687149109|1|0|0||||-1|-1||-1|-1|`2You Get:`` 24,000 Gems.<CR><CR>`5Description:`` Get a small bag of gems.|1||||||0|0|";
						items_here += "\nadd_button|grow_shop|`oGrowtopia Shop``|interface/large/store_buttons/store_buttons36.rttex|https://growtopiagame.com/shop|1|1|0|0|Open Shop||-1|-1|interface/large/gui_shop_buybanner.rttex|0|1|If you can purchase Gem Packs through your telecom provider, then open the Growtopia Shop website here.<CR><CR>Please note, this service is only available in the following countries: `9Brazil``, `9Cambodia``, `9Estonia``, `9Indonesia``, `9Latvia``, `9Lithuania``, `9Malaysia``, `9Philippines``, `9Qatar``, `9Romania``, `9Saudi Arabia``, `9Singapore``, `9Thailand``, `9Turkey``, and `9United Arab Emirates``|1||||||0|0|";
						items_here += "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|3|";
						items_here += "\nadd_button|365d|`o1-Year Subscription Token``|interface/large/store_buttons/store_buttons28.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=D97REZNZPDHQE&custom=48468333-20599520D965CDF860128CCBDD102838|0|0|0||||-1|-1||-1|-1|`2You Get:`` 1x 1-Year Subscription Token and 25 Growtokens.<CR><CR>`5Description:`` One full year of special treatment AND 25 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 4000 gems every day and a chance of doubling any XP earned, growtime reduction onall seeds planted and Exclusive Skins!|1||||||0|0|";
						items_here += "\nadd_button|rt_grope_battlepass_bundle01|Royal Grow Pass|interface/large/store_buttons/store_buttons37.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=DGW6WW6RY9FFN&custom=48468333-931DCD19F55FDFFCE8028482B7F829FF|4|2|0||||-1|-1||-1|-1|`2You Get:`` 1 Royal Grow Pass Token.<CR><CR>`5Description:`` Play to earn points and level up your Grow Pass to earn rewards. Consume toearn exclusive `5Royal`` rewards as you level up your Grow Pass as well as unlocking all daily bonuses and exclusive `5Royal Perks`` for the entire month. Uponconsuming you will instantly receive `2300 Free`` points towards your pass progress. Note: The token is `#UNTRADEABLE``.|1||||||0|0|";*/
						items_here += "set_description_text|Welcome to the `2GrowtopiaTS Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `520000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
						items_here += "\nenable_tabs|1";
						items_here += "\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|";
						items_here += "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";
						items_here += "\nadd_button|rt_grope_cosmetic_bundle03|`oRift Wings``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Rift Wings.<CR><CR>`5Description:`` Rip a hole in the fabric of reality with these amazing Waings! To avoid refund fraud, this item has been made untradeable until 1st May, 2022.|1|5|200000|0|||-1|-1||-1|-1||1||||||0|0|";
						items_here += "\nadd_button|winterfest_calendar_2021|`oWinterfest Calendar - 2021``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Winterfest Calendar - 2021.<CR><CR>`5Description:`` A wonderful Winterfest Calendar for 2021, jam-packed with joy and gifts to celebrate the holidays. Contains `#Rare`` Nutcracker and Snowfrost items! Buying this item will give you access to exclusive Winterfest Club Items as they become available in store.|0|0|65000|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|||||67% remaining||0|0|";
						items_here += "\nadd_button|alien_scanner_progress|`oAlien Scanner! ``|interface/large/store_buttons/store_buttons37.rttex|OPENDIALOG&showalienscannerprogress|4|4|0|0|||-1|-1||-1|-1||1|||||        96%        ||0|0|";
						items_here += "\nadd_button|anzu_pack1|`oAdvertisers Pack``|interface/large/store_buttons/store_buttons36.rttex|`2You Get:`` 1 Ad Control Block and a selection of Ad blocks. <CR><CR>`5Description:`` With this pack you can build custom Ad billboards in yourworld. There are 3 sizes you can choose from, 4x3, 3x2 and 7x1. You need to arrange these in a grid to activate the Ad. Remember to check your Gem earnings each day using the Ad Control Block.|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|";
						items_here += "\nadd_button|anzu_control|`oAd Control Block``|interface/large/store_buttons/store_buttons36.rttex|`2You Get:`` 1 Ad Control Block! <CR><CR>`5Description:`` Withthis Ad Control Block you can turn off the background Ads and Ad Airplanes in aSunny Weather Machine. You can also use this block to check your Ad Gem earnings for the world in which it is placed.|1|0|10|0|||-1|-1||-1|-1||1||||||0|0|";
						items_here += "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|2|";
						items_here += "\nadd_button|gems_glory|Road To Glory|interface/large/store_buttons/store_buttons30.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=C6SJJ5DGNJZCL&custom=48468333-6A27C750096AA9621953348444AB051F|0|0|0|||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|1|0|`2You Get:`` Road To Glory and 100k Gems Instantly.<CR>`5Description:`` Earn Gem rewards when you level up. Every 10 levels you will get additional Gem rewards up to Level 50! Claim all rewards instantly if you are over level 50!! 1.6M Gems in total!! |1||||||0|0|";
						items_here += "\nadd_button|gems_bundle06|Gem Abundance|interface/large/store_buttons/store_buttons37.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=8DYMZNDDSQ2BU&custom=48468333-227C3E7556B53E1709FF6612A6C8AAE3|2|1|0||||-1|-1||-1|-1|`2You Get:`` 1,850,000 Gems, 10 Growtokens and 5 Megaphones.<CR><CR>`5Description:`` Get an abundance of gems to add to your wealth.|1||||||0|0|";
						items_here += "\nadd_button|gems_bundle05|Gem Bounty|interface/large/store_buttons/store_buttons34.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=9UGSFAQBW25JN&custom=48468333-788459637FB94AFEE8C29D4EBEABC9D1|0|6|0||||-1|-1||-1|-1|`2You Get:`` 1,100,000 Gems, 6 Growtokens and 3 Megaphones.<CR><CR>`5Description:`` Get a plethora of gems to add to your wealth.|1||||||0|0|";
						items_here += "\nadd_button|gems_rain|It's Rainin' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=4LKDNBCBJ6VU2&custom=48468333-39FED8C9539C201AE7F5C2898087D4EA|1|5|0||||-1|-1||-1|-1|`2You Get:`` 350,000 Gems, 2 Growtokens and 1 Megaphone.<CR><CR>`5Description:`` All the gems you could ever want and more plus 2 Growtokens and a Megaphoneto tell the whole world about it.|1||||||0|0|";
						items_here += "\nadd_button|gems_fountain|Gem Fountain|interface/large/store_buttons/store_buttons2.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=K4TTXUZCXNTEL&custom=48468333-B2D3A1F84BEDB57BD1A2B746C0CE20EA|0|2|0||||-1|-1||-1|-1|`2You Get:`` 155,000 Gems and 1 Growtoken.<CR><CR>`5Description:`` Get a pile of gems to shop to your hearts desire and 1 Growtoken.|1||||||0|0|";
						items_here += "\nadd_button|gems_chest|Chest o' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=RV5RH3PVCPUR8&custom=48468333-7F84D8C31BA715DFE13B9DC1DBEC1A6E|0|5|0||||-1|-1||-1|-1|`2You Get:`` 55,000 Gems.<CR><CR>`5Description:`` Get a chest containing gems.|1||||||0|0|";
						items_here += "\nadd_button|gems_bag|Bag o' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=E9GPTE453VRJU&custom=48468333-90D2847FFC08DDE14A916BB687149109|1|0|0||||-1|-1||-1|-1|`2You Get:`` 24,000 Gems.<CR><CR>`5Description:`` Get a small bag of gems.|1||||||0|0|";
						items_here += "\nadd_button|grow_shop|`oGrowtopia Shop``|interface/large/store_buttons/store_buttons36.rttex|https://growtopiagame.com/shop|1|1|0|0|Open Shop||-1|-1|interface/large/gui_shop_buybanner.rttex|0|1|If you can purchase Gem Packs through your telecom provider, then open the Growtopia Shop website here.<CR><CR>Please note, this service is only available in the following countries: `9Brazil``, `9Cambodia``, `9Estonia``, `9Indonesia``, `9Latvia``, `9Lithuania``, `9Malaysia``, `9Philippines``, `9Qatar``, `9Romania``, `9Saudi Arabia``, `9Singapore``, `9Thailand``, `9Turkey``, and `9United Arab Emirates``|1||||||0|0|";
						items_here += "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|3|";
						items_here += "\nadd_button|365d|`o1-Year Subscription Token``|interface/large/store_buttons/store_buttons28.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=D97REZNZPDHQE&custom=48468333-20599520D965CDF860128CCBDD102838|0|0|0||||-1|-1||-1|-1|`2You Get:`` 1x 1-Year Subscription Token and 25 Growtokens.<CR><CR>`5Description:`` One full year of special treatment AND 25 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 4000 gems every day and a chance of doubling any XP earned, growtime reduction onall seeds planted and Exclusive Skins!|1||||||0|0|";
						items_here += "\nadd_button|rt_grope_battlepass_bundle01|Royal Grow Pass|interface/large/store_buttons/store_buttons37.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=DGW6WW6RY9FFN&custom=48468333-931DCD19F55FDFFCE8028482B7F829FF|4|2|0||||-1|-1||-1|-1|`2You Get:`` 1 Royal Grow Pass Token.<CR><CR>`5Description:`` Play to earn points and level up your Grow Pass to earn rewards. Consume toearn exclusive `5Royal`` rewards as you level up your Grow Pass as well as unlocking all daily bonuses and exclusive `5Royal Perks`` for the entire month. Uponconsuming you will instantly receive `2300 Free`` points towards your pass progress. Note: The token is `#UNTRADEABLE``.|1||||||0|0|";

						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), items_here));
						ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					if (cch.find("action|buy") == 0) {
						string items = explode("\n", explode("|", cch).at(2)).at(0);
						if (items == "rt_grope_cosmetic_bundle03") {
							auto Price = 200000;
							auto ItemID = 11478;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "anzu_control") {
							auto Price = 10;
							auto ItemID = 10876;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}

						if (items == "winterfest_calendar_2021") {
							auto Price = 65000;
							auto ItemID = 11472;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						/*item 1*/
						if (items == "upgrade_backpack") {
							auto Price = GetPriceForInventory(((PlayerInfo*)(peer->data))->inventory.inventorySize);
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (((PlayerInfo*)(peer->data))->inventory.inventorySize >= 250) break;
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								short nextSpace = 0;
								if (((PlayerInfo*)(peer->data))->inventory.inventorySize + 10 > 250) {
									nextSpace = 250;
								}
								else {
									nextSpace = ((PlayerInfo*)(peer->data))->inventory.inventorySize + 10;
								}
								((PlayerInfo*)(peer->data))->inventory.inventorySize += 10;
								sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
								sendClothes(peer);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `0Upgrade Backpack`` (`w10 Slots``) `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``Backpack Upgrade"));
								ENetPacket* packets = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packets);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `0Upgrade Backpack`` (`w10 Slots``)``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "rare_clothes") {
							auto Price = 500;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								vector<int> rand_items{ 250, 1716, 82, 78, 94, 662, 754, 146, 356, 72, 46, 124, 1720, 92, 1122, 212, 84, 1722, 1844, 2718, 70, 4966, 288, 232, 788, 148, 96, 3932, 448, 98, 134, 50, 74, 1504, 494, 266, 852, 132, 2954, 3934, 3060, 3056, 1800, 88, 2960, 1022, 2578, 3164, 86, 302, 1332, 304, 1116, 6788, 894, 492, 1690, 316, 1850, 1718, 1838, 1032, 1860, 1026, 3048, 352, 724, 1590, 798, 488, 1342, 794, 268, 1502, 8884, 1858, 594, 3466, 1314, 1688, 1312, 3590, 446, 1856, 1854, 1516, 1316, 2700, 4968, 4964, 6796, 1862, 310, 290, 296, 6674, 1864, 4954, 1476, 896, 1848, 496, 136, 158, 2958, 2576, 1954, 152, 1126, 796, 1524, 2928, 80, 2934, 150, 1120, 1142, 1478, 154, 9356, 452, 258, 2882, 156, 1140, 3530, 312, 1124, 890, 1330, 3052, 294, 1650, 1652, 348, 1736, 576, 5016, 1708, 292, 1146, 1028, 1762, 600 };
								int ItemID = rand_items[rand() % rand_items.size()];
								int icount = 1;
								int ItemID2 = rand_items[rand() % rand_items.size()];
								int icount2 = 1;
								int ItemID3 = rand_items[rand() % rand_items.size()];
								int icount3 = 1;
								if (ItemID == ItemID2) {
									ItemID2 = 0;
									icount++;
								}
								if (ItemID == ItemID3) {
									ItemID3 = 0;
									icount++;
								}
								if (ItemID2 == ItemID3) {
									ItemID3 = 0;
									icount2++;
								}
								if (CheckItemMaxed(peer, ItemID, 1) || CheckItemMaxed(peer, ItemID2, 1) || CheckItemMaxed(peer, ItemID3, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 3 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, icount);
								if (ItemID2 != 0) AddItemToInv(world, peer, ItemID2, icount2);
								if (ItemID3 != 0) AddItemToInv(world, peer, ItemID3, icount3);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								string result = "`5Received: ``";
								if (icount == 1) {
									result += itemDefs.at(ItemID).name;
								}
								else {
									result += to_string(icount) + " " + itemDefs.at(ItemID).name;
								}
								if (ItemID2 != 0) {
									result += "`$,`` ";
									if (icount2 == 1) {
										result += itemDefs.at(ItemID2).name;
									}
									else {
										result += to_string(icount2) + " " + itemDefs.at(ItemID2).name;
									}
								}
								if (ItemID3 != 0) {
									result += "`$,`` ";
									if (icount3 == 1) {
										result += itemDefs.at(ItemID3).name;
									}
									else {
										result += to_string(icount3) + " " + itemDefs.at(ItemID3).name;
									}
								}
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oRare Clothes Pack`` `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n" + result));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oRare Clothes Pack``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "transmutation_device") {
							auto Price = 25000;
							auto ItemID = 9170;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "contact_lenses") {
							auto Price = 15000;
							int itemID = 6760;
							int itemID2 = 6762;
							int itemID3 = 6764;
							int itemID4 = 6766;
							int itemID5 = 6768;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, itemID, 1) || CheckItemMaxed(peer, itemID2, 1) || CheckItemMaxed(peer, itemID3, 1) || CheckItemMaxed(peer, itemID4, 1) || CheckItemMaxed(peer, itemID5, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 3 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, itemID, 1);
								AddItemToInv(world, peer, itemID2, 1);
								AddItemToInv(world, peer, itemID3, 1);
								AddItemToInv(world, peer, itemID4, 1);
								AddItemToInv(world, peer, itemID5, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oContact Lens Pack `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oContact Lens Pack``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "eye_drops") {
							auto Price = 30000;
							int itemID = 5458;
							int itemID2 = 5460;
							int itemID3 = 5462;
							int itemID4 = 5464;
							int itemID5 = 5466;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, itemID, 1) || CheckItemMaxed(peer, itemID2, 1) || CheckItemMaxed(peer, itemID3, 1) || CheckItemMaxed(peer, itemID4, 1) || CheckItemMaxed(peer, itemID5, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 3 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, itemID, 1);
								AddItemToInv(world, peer, itemID2, 1);
								AddItemToInv(world, peer, itemID3, 1);
								AddItemToInv(world, peer, itemID4, 1);
								AddItemToInv(world, peer, itemID5, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oEye Drops Pack `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oEye Drops Pack``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "nyan_hat") {
							auto Price = 25000;
							auto ItemID = 574;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "tiny_horsie") {
							auto Price = 25000;
							auto ItemID = 592;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "star_ship") {
							auto Price = 25000;
							auto ItemID = 760;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "dragon_hand") {
							auto Price = 50000;
							auto ItemID = 900;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "corvette") {
							auto Price = 25000;
							auto ItemID = 766;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "stick_horse") {
							auto Price = 25000;
							auto ItemID = 1012;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "ambulance") {
							auto Price = 25000;
							auto ItemID = 1272;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "raptor") {
							auto Price = 25000;
							auto ItemID = 1320;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "owl") {
							auto Price = 30000;
							auto ItemID = 1540;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "unicorn") {
							auto Price = 50000;
							auto ItemID = 1648;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "starboard") {
							auto Price = 30000;
							auto ItemID = 1740;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "motorcycle") {
							auto Price = 50000;
							auto ItemID = 1950;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "monkey_on_back") {
							auto Price = 50000;
							auto ItemID = 2900;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "carrot_sword") {
							auto Price = 15000;
							auto ItemID = 2908;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "fire_truck") {
							auto Price = 50000;
							auto ItemID = 3068;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "pet_slime") {
							auto Price = 100000;
							auto ItemID = 3166;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "dabstep_shoes") {
							auto Price = 30000;
							auto ItemID = 6780;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						/*end*/
						if (items == "locks") {
							string items_here = "";

							items_here += "set_description_text|`2Locks And Stuff!``  Select the item you'd like more info on, or BACK to go back.";
							items_here += "\nenable_tabs|1";
							items_here += "\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||1|1|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|";;
							items_here += "\nadd_button|upgrade_backpack|`0Upgrade Backpack`` (`w10 Slots``)|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 10 Additional Backpack Slots.<CR><CR>`5Description:`` Sewing an extra pocket onto your backpack will allow you to store `$10`` additional item types.  How else are you going to fit all those toilets and doors?|0|1|" + std::to_string(GetPriceForInventory(((PlayerInfo*)(peer->data))->inventory.inventorySize)) + "|0|||-1|-1||-1|-1||1||||||0|0|add_button|clothes|`oClothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Wearble Items.<CR><CR>`5Description:`` Why not look the part? Some may even have special powers...|0|0|50|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|rare_clothes|`oRare Clothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Chosen Wearbale Items.<CR><CR>`5Description:`` Enjoy the garb of kings! Some may even have special powers...|0|1|500|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|transmutation_device|`oTransmutabooth``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Transmutabooth.<CR><CR>`5Description:`` Behold! A wondrous technological achievement from the innovative minds at GrowTech, the Transmutabooth allows you to merge clothing items, transferring the visual appearance of one onto another in the same slot! If you've ever wanted your Cyclopean Visor to look like Shades (while keeping its mod), now you can!|0|7|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|contact_lenses|`oContact Lens Pack``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 20 Random Contact Lens Colors.<CR><CR>`5Description:`` Need a colorful new look? This pack includes 20 random Contact Lens colors (and may include Contact Lens Cleaning Solution, to return to your natural eye color)!|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|eye_drops|`oEye Drop Pack``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 `#Rare Bathroom Mirror`` and 10 random Eye Drop Colors.<CR><CR>`5Description:`` Need a fresh new look?  This pack includes a 10 random Eye Drop Colors (may include Eye Cleaning Solution, to leave your eyes sparklyclean)!|0|6|30000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|nyan_hat|`oTurtle Hat``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Turtle Hat.<CR><CR>`5Description:`` It's the greatest hat ever. It bloops out bubbles as you run! `4Not available any other way!``|0|2|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|tiny_horsie|`oTiny Horsie``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Tiny Horsie.<CR><CR>`5Description:`` Tired of wearing shoes? Wear a Tiny Horsie instead! Or possibly a large dachshund, we're not sure. Regardless, it lets you run around faster than normal, plus you're on a horse!`4Not available any other way!``|0|5|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|star_ship|`oPleiadian Star Ship``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Pleiadian Star Ship.<CR><CR>`5Description:`` Float on, my brother. It's all groovy. This star ship can't fly, but you can still zoom around in it, leaving a trail of energy rings and moving at enhanced speed.Sponsored by Pleiadian. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|dragon_hand|`oDragon Hand``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Dragon Hand.<CR><CR>`5Description:`` Call forth the dragons of legend!  With the Dragon Hand, you will command your own pet dragon. Instead of punching blocks or players, you can order your dragon to incinerate them! In addition to just being awesome, this also does increased damage, and pushes other players farther. `4Not available any other way!``|0|1|50000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|corvette|`oLittle Red Corvette``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Little Red Corvette.<CR><CR>`5Description:`` Cruise around the neighborhood in style with this sweet convertible. It moves at enhanced speed and leaves other Growtopians in your dust. `4Not available any otherway!``|0|1|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|stick_horse|`oStick Horse``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Stick Horse.<CR><CR>`5Description:`` Nobody looks cooler than a person bouncing along on a stick with a fake horse head attached. NOBODY. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|ambulance|`oAmbulance``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Ambulance.<CR><CR>`5Description:`` Rush to the scene of anaccident while lawyers chase you in this speedy rescue vehicle. `4Not availableany other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|raptor|`oRiding Raptor``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Riding Raptor.<CR><CR>`5Description:`` Long thought to beextinct, it turns out that these dinosaurs are actually alive and easily tamed.And riding one lets you run around faster than normal! `4Not available any other way!``|0|7|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|owl|`oMid-Pacific Owl``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Mid-Pacific Owl.<CR><CR>`5Description:`` This owl is a bit lazy - if you stop moving around, he'll land on your head and fall asleep. Dedicated to the students of the Mid-Pacific Institute. `4Not available any other way!``|0|1|30000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|unicorn|`oUnicorn Garland``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Unicorn Garland.<CR><CR>`5Description:`` Prance aboutin the fields with your very own pet unicorn! It shoots `1R`2A`3I`4N`5B`6O`7W`8S``. `4Not available any other way!``|0|4|50000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|starboard|`oStarBoard``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 StarBoard.<CR><CR>`5Description:`` Hoverboards are here at last! Zoom around Growtopia on this brand new model, which is powered by fusion energy (that means stars spit out of the bottom). Moves faster than walking. Sponsored by Miwsky, Chudy, and Dawid. `4Not available any other way!``|0|1|30000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|motorcycle|`oGrowley Motorcycle``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Growley Motorcycle.<CR><CR>`5Description:`` Thecoolest motorcycles available are Growley Dennisons. Get a sporty blue one today! It even moves faster than walking, which is pretty good for a motorcycle. `4Not available any other way!``|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|monkey_on_back|`oMonkey On Your Back``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Monkey On Your Back.<CR><CR>`5Description:`` Most people work really hard to get rid of these, but hey, if you want one, it's available! `4But not available any other way!`` Sponsored by SweGamerHD's subscribers, Kizashi, and Inforced. `#Note: This is a neck item, not a back item. He's grabbing your neck!``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|carrot_sword|`oCarrot Sword``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Carrot Sword.<CR><CR>`5Description:`` Razor sharp, yet oddly tasty. This can carve bunny symbols into your foes! `4Not available any other way!`` Sponsored by MrMehMeh.|0|3|15000|0|||-1|-1||-1|-1||1||||||0|0|add_button|red_bicycle|`oRed Bicycle``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Red Bicycle.<CR><CR>`5Description:`` It's the environmentally friendly way to get around! Ride this bicycle at high speed hither and zither throughout Growtopia. `4Not available any other way!``|0|5|30000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|fire_truck|`oFire Truck``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fire Truck.<CR><CR>`5Description:`` Race to the scene of the fire in this speedy vehicle! `4Not available any other way!``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|pet_slime|`oPet Slime``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Pet Slime.<CR><CR>`5Description:`` What could be better than a blob of greasy slime that follows you around? How about a blob of greasy slime that follows you around and spits corrosive acid, melting blocks more quickly than a normal punch? `4Not available any other way!``|0|4|100000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|dabstep_shoes|`oDabstep Low Top Sneakers``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Dabstep Low Top Sneakers.<CR><CR>`5Description:`` Light up every footfall and move to a better beat with these dabulous shoes! When you're wearing these, the world is your dance floor! `4Not available any other way!``|0|2|30000|0|||-1|-1||-1|-1||1||||||0|0|";

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), items_here));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}

						/*item 2*/
						if (items == "world_lock") {
							auto Price = 2000;
							auto ItemID = 242;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "world_lock_10_pack") {
							auto Price = 20000;
							auto ItemID = 242;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 10);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o10 " + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o10 " + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "small_lock") {
							auto Price = 50;
							auto ItemID = 202;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "big_lock") {
							auto Price = 200;
							auto ItemID = 204;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "huge_lock") {
							auto Price = 500;
							auto ItemID = 206;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "door_pack") {
							auto Price = 15;
							auto ItemID = 20;
							auto ItemID2 = 12;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || CheckItemMaxed(peer, ItemID2, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 2 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								AddItemToInv(world, peer, ItemID2, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oDoor Pack `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oDoor Pack``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "door_mover") {
							auto Price = 5000;
							auto ItemID = 1404;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "vending_machine") {
							auto Price = 8000;
							auto ItemID = 2978;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "digi_vend") {
							auto Price = 12000;
							auto ItemID = 9268;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "checkout_counter") {
							auto Price = 50000;
							auto ItemID = 9270;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "change_addr") {
							auto Price = 20000;
							auto ItemID = 2580;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "signal_jammer") {
							auto Price = 2000;
							auto ItemID = 226;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "punch_jammer") {
							auto Price = 15000;
							auto ItemID = 1276;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "zombie_jammer") {
							auto Price = 15000;
							auto ItemID = 1278;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "starship_blast") {
							auto Price = 10000;
							auto ItemID = 6666;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "surg_blast") {
							auto Price = 10000;
							auto ItemID = 8556;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "bountiful_blast") {
							auto Price = 5000;
							auto ItemID = 8738;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "thermo_blast") {
							auto Price = 15000;
							auto ItemID = 1402;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "antigravity_generator") {
							auto Price = 450000;
							auto ItemID = 4992;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "building_blocks_machine") {
							auto Price = 8000;
							auto ItemID = 8196;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "builders_lock") {
							auto Price = 50000;
							auto ItemID = 4994;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "weather_sunny") {
							auto Price = 1000;
							auto ItemID = 932;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "weather_night") {
							auto Price = 10000;
							auto ItemID = 934;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "weather_arid") {
							auto Price = 10000;
							auto ItemID = 946;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "weather_rainy") {
							auto Price = 10000;
							auto ItemID = 984;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "weather_warp") {
							auto Price = 10000;
							auto ItemID = 1750;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "mars_blast") {
							auto Price = 15000;
							auto ItemID = 1136;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "undersea_blast") {
							auto Price = 15000;
							auto ItemID = 1532;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "cave_blast") {
							auto Price = 750000;
							auto ItemID = 3562;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "weather_stuff") {
							auto Price = 50000;
							auto ItemID = 3832;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "weather_jungle") {
							auto Price = 20000;
							auto ItemID = 4776;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "weather_backgd") {
							auto Price = 150000;
							auto ItemID = 5000;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "digital_rain_weather") {
							auto Price = 30000;
							auto ItemID = 6854;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "treasure_blast") {
							auto Price = 15000;
							auto ItemID = 7588;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "infinity_weather_machine") {
							auto Price = 50000;
							auto ItemID = 10058;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}

						/*end*/

						if (items == "itempack") {
							string items_here = "";

							items_here += "set_description_text|`2Item Packs!``  Select the item you'd like more info on, or BACK to go back.";
							items_here += "\nenable_tabs|1";
							items_here += "\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||1|3|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|";;

							items_here += "\nadd_button|world_lock|`oWorld Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 World Lock.<CR><CR>`5Description:`` Become the undisputedruler of your domain with one of these babies.  It works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.``  `wRecycles for 200 Gems.``|0|7|2000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|world_lock_10_pack|`oWorld Lock Pack``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 10 World Locks.<CR><CR>`5Description:`` 10-pack of World Locks. Become the undisputed ruler of up to TEN kingdoms with thesebabies. Each works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.`` `wEach recycles for 200 Gems.``|0|3|20000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|small_lock|`oSmall Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Lock.<CR><CR>`5Description:`` Protect up to `$10`` tiles.  Can add friends to the lock so others can edit that area as well. `5It'sa perma-item, is never lost when destroyed.``|1|3|50|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|big_lock|`oBig Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Big Lock.<CR><CR>`5Description:`` Protect up to `$48`` tiles. Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|1|1|200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|huge_lock|`oHuge Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Huge Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's aperma-item, is never lost when destroyed.``|0|4|500|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|door_pack|`oDoor And Sign Hello Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Door and 1 Sign.<CR><CR>`5Description:`` Ownyour very own door and sign! This pack comes with one of each. Leave cryptic messages and create a door that can open to, well, anywhere.|0|3|15|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|door_mover|`oDoor Mover``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Door Mover.<CR><CR>`5Description:`` Unsatisfied with your world's layout?  This one-use device can be used to move the White Door to anynew location in your world, provided there are 2 empty spaces for it to fit in.Disappears when used. `2Only usable on a world you have World Locked.``|0|6|5000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|vending_machine|`oVending Machine``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Vending Machine.<CR><CR>`5Description:`` Tired of interacting with human beings? Try a Vending Machine! You can put a stack of items inside it, set a price in World Locks, and people can buy from the machine while you sit back and rake in the profits! `5It's a perma-item, is never lost when destroyed, and it is not available any other way.``|0|6|8000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|digi_vend|`oDigiVend Machine``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 DigiVend Machine.<CR><CR>`5Description:`` Get withthe times and go digital! This wired vending machine can connect its contents to Vending Hubs AND the multiversal economy, providing a unified shopping experience along with price checks to help you sell your goods! All that, and still no human-related hassle! Use your wrench on this to stock it with an item and set aprice in World Locks. Other players will be able to buy from it! Only works in World-Locked worlds.|0|2|12000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|checkout_counter|`oVending Hub - Checkout Counter``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 Vending Hub.<CR><CR>`5Description:`` Your one-stop shop! This vending hub will collect and display (and let shoppers buy) the contents of ALL DigiVends in its row or column (wrench it to set which the direction)! Wow! Now that's a shopping experience we can all enjoy! Note: Only works in World-Locked worlds.|0|3|50000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|change_addr|`oChange of Address``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Change of Address.<CR><CR>`5Description:`` Don't like the name of your world? You can use up one of these to trade your world'sname with the name of any other world that you own. You must have a `2World Lock`` in both worlds. Go lock up that empty world with the new name you want and swap away!|0|6|20000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|signal_jammer|`oSignal Jammer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Signal Jammer.<CR><CR>`5Description:`` Get off the grid! Install a `$Signal Jammer``! A single punch will cause it to whir to life,tireless hiding your world and its population from pesky snoopers - only those who know the world name will be able to enter. `5It's a perma-item, is never lost when destroyed.``|1|6|2000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|punch_jammer|`oPunch Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Punch Jammer.<CR><CR>`5Description:`` Tired of getting bashed around? Set up a Punch Jammer in your world, and people won't be able to punch each other! Can be turned on and off as needed. `5It's a perma-item, isnever lost when destroyed.``|0|4|15000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|zombie_jammer|`oZombie Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Zombie Jammer.<CR><CR>`5Description:`` Got a parkour or race that you don't want slowed down? Turn this on and nobody can be infected by zombie bites in your world. It does not prevent direct infection by the g-Virus itself though. `5It's a perma-item, is never lost when destroyed.``|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|starship_blast|`oImperial Starship Blast``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Imperial Starship Blast.<CR><CR>`5Description:`` Command your very own Starship and explore the cosmos! This blast contains one of 3 possible Imperial ship types - which will you get? Note: Each Starship comes with a full tank of gas, an Imperial Helm - Mk. I, Imperial Reactor - Mk. I and an Imperial Viewscreen - Mk. I, so you'll be all set for your adventure among the stars! Note: A Starship also comes with an assortment of space-ageblocks!|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|surg_blast|`oSurgWorld Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 SurgWorld Blast and 1 Caduceaxe.<CR><CR>`5Description:`` Your gateway to a world of medical wonders! SurgWorld is a place of care and healing, with all kinds of interesting blocks, top tips on how to treat people with surgery, and an increased chance of getting maladies while you work! Also comes with 1 Caduceaxe to extract Vaccine Drops from blocks. `6Warning:`` May break when extracting vaccine.|0|2|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|bountiful_blast|`oBountiful Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Bountiful Blast.<CR><CR>`5Description:`` Enter a world of fertile soil, cheerful sunshine and lush green hills, and bountifulnew trees! This blast is your ticket to a different kind of farming!|0|3|5000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|thermo_blast|`oThermonuclear Blast``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Thermonuclear Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door. Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|antigravity_generator|`oAntigravity Generator``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Antigravity Generator.<CR><CR>`5Description:`` Disables gravity in your world when activated! Well, it reduces gravity, and lets everybody jump as much as they want! `5It's a perma-item - neverlost when destroyed! `4Not available any other way!````|0|3|450000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|building_blocks_machine|`oBuilding Blocks Machine``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Building Blocks Machine.<CR><CR>`5Description:`` Eager to add some new building materials to your construction stockpile? Tired of collecting them from random worlds and weirdos? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `5RARE Creepy Baby Block and Digital Dirt`` amongst a heap of other new blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch!|0|3|8000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|builders_lock|`oBuilder's Lock``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Builders Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles. Wrench the lock to limit it - it can either only allow building, or only allow breaking! `5It's a perma-item, is never lost when destroyed.``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|weather_sunny|`oWeather Machine - Sunny``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Sunny.<CR><CR>`5Description:`` You probably don't need this one... but if you ever have a desire to turn a sunset or desert world back to normal, grab a Sunny Weather Machine to restore the default Growtopia sky! `5It's a perma-item, is never lost when destroyed.``|0|5|1000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|weather_night|`oWeather Machine - Night``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Night.<CR><CR>`5Description:`` You might not call it weather, but we do! This will turn the backgroundof your world into a lovely night scene with stars and moon. `5It's a perma-item, is never lost when destroyed.``|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|weather_arid|`oWeather Machine - Arid``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Arid.<CR><CR>`5Description:`` Want your world to look like a cartoon desert? This will turn the background of your world into a desert scene with all the trimmings. `5It's a perma-item, is never lost when destroyed.``|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|weather_rainy|`oWeather Machine - Rainy City``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Weather Machine - Rainy City.<CR><CR>`5Description:`` This will turn the background of your world into a dark, rainy city scene complete with sound effects. `5It's a perma-item, is never lost when destroyed.``|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|weather_warp|`oWeather Machine - Warp Speed``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Weather Machine - Warp Speed.<CR><CR>`5Description:`` This Weather Machine will launch your world through space at relativistic speeds, which will cause you to age more slowly, as well as see stars flying by rapidly in the background. `5It's a perma-item, is never lost when destroyed.``|0|3|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|mars_blast|`oMars Blast``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Mars Blast.<CR><CR>`5Description:`` Blast off to Mars!  This powerful rocket ship will launch you to a new world set up like the surfaceof Mars, with a special martian sky background, and unique terrain not found elsewhere in the solar system. Mars even has lower gravity than Growtopia normallydoes! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to Mars, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|undersea_blast|`oUndersea Blast``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Undersea Blast.<CR><CR>`5Description:`` Explore the ocean!  This advanced device will terraform a new world set up like the bottom of the ocean, with a special ocean background, and special blocks like Seaweed, Coral, Jellyfish, Sharks, and maybe a special surprise... Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to an ocean, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|cave_blast|`oCave Blast``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Cave Blast.<CR><CR>`5Description:`` This explosive device will punch a hole in the ground, giving you a dark cavern to explore. There are even rumors of treasure and the entrance to ancient mines, hidden deep in thecaves... but make sure you bring a World Lock. The blasted world is not locked when it's created, so lock it before somebody shows up! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to a cave, that would be dangerous.|0|2|30000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|weather_stuff|`oWeather Machine - Stuff``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Weather Machine - Stuff.<CR><CR>`5Description:`` This is the most fun weather imaginable - Choose any item from your inventory, adjust some settings, and watch it rain down from the sky! Or up, if you prefer reversing the gravity. `5It's a perma-item, is never lost when destroyed.``|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|weather_jungle|`oWeather Machine - Jungle``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Weather Machine - Jungle.<CR><CR>`5Description:`` This weather machine will turn the background of your world into a steamy jungle. `5It's a perma-item, is never lost when destroyed.``|0|5|20000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|weather_backgd|`oWeather Machine - Background``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Weather Machine - Background.<CR><CR>`5Description:`` This amazing device can scan any Background Block, and willmake your entire world look like it's been filled with that block. Also handy for hiding music notes! `5It's a perma-item, is never lost when destroyed.``|0|1|150000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|digital_rain_weather|`oWeather Machine - Digital Rain``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Weather Machine - DigitalRain.<CR><CR>`5Description:`` Take the grow pill, and we'll show you how deep the rabbit hole goes! Splash the scrolling code of creation across the skies of your worlds. They say you learn to understand it after a while... Note: You can only have one of these per world. `5It's a perma-item, is never lost when destroyed.``|0|6|30000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|treasure_blast|`oTreasure Blast``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Treasure Blast.<CR><CR>`5Description:`` Enter aworld of snow-capped peaks and long-forgotten mysteries! Riddles and secrets - and a ton of treasure - await those who brave this blast's blocks! Remember, when you use this, it'll create a new world by typing in a new name! No sense in searching for clues to great treasures in well-trod worlds, is there?|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|infinity_weather_machine|`oInfinity Weather Machine``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Infinity Weather Machine.<CR><CR>`5Description:`` Imagine being able to predict the weather?! Well, with the Infinity Weather Machine you can! Add multiple Weather Machines to this machine and have them play on a loop, like a weather mix tape, kind of!|0|3|50000|0|||-1|-1||-1|-1||1||||||0|0|";

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), items_here));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						/*items 3*/
						if (items == "5seed") {
							auto Price = 100;
							auto ItemID = 5706;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "ssp_10_pack") {
							auto Price = 1000;
							auto ItemID = 5706;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 10) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 10);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "grow_spray") {
							auto Price = 400;
							auto ItemID = 228;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "rare_seed") {
							if (((PlayerInfo*)(peer->data))->gems >= 1000) {
								int Seed1 = 0;
								int Seed2 = 0;
								int Seed3 = 0;
								int Seed4 = 0;
								int Seed5 = 0;
								int AVGRarity = rand() % 10 + 10;
								while (Seed1 == 0 || Seed2 == 0 || Seed3 == 0 || Seed4 == 0 || Seed5 == 0) {
									for (int i = 0; i < CoreDataItems; i++) {
										if (i >= 1000) {
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Something went wrong.", 0);
											break;
										}
										if (getItemDef(i).blockType == BlockTypes::SEED && itemDefs.at(i).rarity == AVGRarity || getItemDef(i).blockType == BlockTypes::SEED && itemDefs.at(i).rarity == AVGRarity + 1) {
											if (Seed1 == 0) Seed1 = i;
											else if (Seed2 == 0) Seed2 = i;
											else if (Seed3 == 0) Seed3 = i;
											else if (Seed4 == 0) Seed4 = i;
											else if (Seed5 == 0) Seed5 = i;
											else break;
											AVGRarity = rand() % 10 + 10;
										}
										else if (i == CoreDataItems - 1) {
											break;
										}
									}
								}
								if (CheckItemMaxed(peer, Seed1, 1) || CheckItemMaxed(peer, Seed2, 1) || CheckItemMaxed(peer, Seed3, 1) || CheckItemMaxed(peer, Seed4, 75) || CheckItemMaxed(peer, Seed5, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 5 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 1000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								bool success = true;
								AddItemToInv(world, peer, Seed1, 1);
								AddItemToInv(world, peer, Seed2, 1);
								AddItemToInv(world, peer, Seed3, 1);
								AddItemToInv(world, peer, Seed4, 1);
								AddItemToInv(world, peer, Seed5, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oRare Seed Pack `wfor `$" + to_string(1000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received:`` " + itemDefs.at(Seed1).name + "`$,`` " + itemDefs.at(Seed2).name + "`$,`` " + itemDefs.at(Seed3).name + "`$,`` " + itemDefs.at(Seed4).name + "`$,`` " + itemDefs.at(Seed5).name + "\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oRare Seed Pack``!  You're `$" + to_string(1000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "deluxe_grow_spray") {
							auto Price = 900;
							auto ItemID = 1778;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "basic_splice") {
							auto Price = 200;
							vector<int> rand_items{ 13, 17, 21, 57, 101, 381, 1189, 2793, 3567 };
							int ItemID = 11;
							int icount = 10;
							int ItemID2 = rand_items[rand() % rand_items.size()];
							int ItemID3 = rand_items[rand() % rand_items.size()];
							int ItemID4 = rand_items[rand() % rand_items.size()];
							int ItemID5 = rand_items[rand() % rand_items.size()];
							int ItemID6 = rand_items[rand() % rand_items.size()];
							int ItemID7 = rand_items[rand() % rand_items.size()];
							int ItemID8 = rand_items[rand() % rand_items.size()];
							int ItemID9 = rand_items[rand() % rand_items.size()];
							int ItemID10 = rand_items[rand() % rand_items.size()];
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 10) || CheckItemMaxed(peer, ItemID2, 1) || CheckItemMaxed(peer, ItemID3, 1) || CheckItemMaxed(peer, ItemID4, 1) || CheckItemMaxed(peer, ItemID5, 1) || CheckItemMaxed(peer, ItemID6, 1) || CheckItemMaxed(peer, ItemID7, 1) || CheckItemMaxed(peer, ItemID8, 1) || CheckItemMaxed(peer, ItemID9, 1) || CheckItemMaxed(peer, ItemID10, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 10);
								AddItemToInv(world, peer, ItemID2, 1);
								AddItemToInv(world, peer, ItemID3, 1);
								AddItemToInv(world, peer, ItemID4, 1);
								AddItemToInv(world, peer, ItemID5, 1);
								AddItemToInv(world, peer, ItemID6, 1);
								AddItemToInv(world, peer, ItemID7, 1);
								AddItemToInv(world, peer, ItemID8, 1);
								AddItemToInv(world, peer, ItemID8, 1);
								AddItemToInv(world, peer, ItemID10, 1);
								string result = "`5Received: ``";
								result += "`$" + getItemDef(ItemID).name;
								result += "`$, " + getItemDef(ItemID2).name;
								result += "`$, " + getItemDef(ItemID3).name;
								result += "`$, " + getItemDef(ItemID4).name;
								result += "`$, " + getItemDef(ItemID5).name;
								result += "`$, " + getItemDef(ItemID6).name;
								result += "`$, " + getItemDef(ItemID7).name;
								result += "`$, " + getItemDef(ItemID8).name;
								result += "`$, " + getItemDef(ItemID9).name;
								result += "`$, " + getItemDef(ItemID10).name;
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oBasic Splicing Kit `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n" + result));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oBasic Splicing Kit``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "surgical_kit" || items == "star_supplies") {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "Sorry, but this button is disable for a while."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (items == "fishin_pack") {
							if (((PlayerInfo*)(peer->data))->gems >= 10000) {
								if (CheckItemMaxed(peer, 3044, 1) || CheckItemMaxed(peer, 2914, 5) || CheckItemMaxed(peer, 5522, 1) || CheckItemMaxed(peer, 5524, 1) || CheckItemMaxed(peer, 2912, 1) || CheckItemMaxed(peer, 3004, 10) || CheckItemMaxed(peer, 3002, 1) || CheckItemMaxed(peer, 822, 5) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 8 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 10000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 3044, 1);
								AddItemToInv(world, peer, 2914, 6);
								AddItemToInv(world, peer, 5522, 1);
								AddItemToInv(world, peer, 5524, 1);
								AddItemToInv(world, peer, 2912, 1);
								AddItemToInv(world, peer, 3004, 10);
								AddItemToInv(world, peer, 3002, 1);
								AddItemToInv(world, peer, 822, 5);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFishin' Pack `wfor `$" + to_string(10000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received:`` Tackle Box`$,`` 5 Wiggly Worms`$,`` Hand Drill`$,`` Nuclear Detonator`$,`` Fishing Rod`$,`` 10 Fish Tanks`$,`` Fish Tank Port`$,`` 5 Water Buckets\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFishin' Pack``!  You're `$" + to_string(10000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "geiger") {
							auto Price = 25000;
							auto ItemID = 2204;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``" + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "boo_pack") {
							auto Price = 10000;
							auto ItemID = 3710;
							auto ItemID2 = 3716;
							auto ItemID3 = 3720;
							if (((PlayerInfo*)(peer->data))->gems >= Price) {
								if (CheckItemMaxed(peer, ItemID, 1) || CheckItemMaxed(peer, ItemID2, 1) || CheckItemMaxed(peer, ItemID3, 10) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= Price;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, ItemID, 1);
								AddItemToInv(world, peer, ItemID2, 1);
								AddItemToInv(world, peer, ItemID3, 10);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oB.O.O. Training Pack `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: `5" + itemDefs.at(ItemID).name + "`$, `5" + itemDefs.at(ItemID2).name + "`$, `5" + itemDefs.at(ItemID3).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oB.O.O.Training Pack``!  You're `$" + to_string(Price - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						/*end*/

						if (items == "bigitems") {
							string items_here = "";

							items_here += "set_description_text|`2Awesome Items!``  Select the item you'd like more info on, or BACK to go back.";
							items_here += "\nenable_tabs|1";
							items_here += "\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||1|4|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_button|5seed|`oSmall Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Seed Pack.<CR><CR>`5Description:`` Contains one Small Seed Pack. Open it for `$5`` randomly chosen seeds, including 1 rare seed! Who knows what you'll get?!|1|4|100|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|ssp_10_pack|`oSmall Seed Pack Collection``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 10 Small Seed Packs.<CR><CR>`5Description:`` Open each one for `$5`` randomly chosen seeds apiece, including 1 rare seedper pack! Who knows what you'll get?!|0|4|1000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|rare_seed|`oRare Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Randomly Chosen Rare Seeds.<CR><CR>`5Description:`` Expect some wondrous crops with these!|1|7|1000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|grow_spray|`o5-pack of Grow Spray Fertilizer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Grow Spray Fertilizers.<CR><CR>`5Description:`` Why wait?!  Treat yourself to a `$5-pack`` of amazing `wGrow Spray Fertilizer`` by GrowTech Corp.  Each bottle instantly ages a tree by `$1 hour``.|0|6|200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|deluxe_grow_spray|`oDeluxe Grow Spray``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Deluxe Grow Spray.<CR><CR>`5Description:`` GrowTech's new `$Deluxe`` `wGrow Spray`` instantly ages a tree by `$24 hours``per bottle! That's somewhere around 25 times as much as regular Grow Spray!|0|2|900|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|bountiful_seed_pack|`oBountiful Seed Pack``|interface/large/store_buttons/store_buttons28.rttex|`2You Get:`` 1 Bountiful Seed Pack.<CR><CR>`5Description:`` Contains `$5`` randomly chosen bountiful seeds, including 1 rare seed! Who knows what you'll get?!|0|4|1000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|basic_splice|`oBasic Splicing Kit``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 10 Rock Seeds and 10 Random Seeds of Rarity 2.<CR><CR>`5Description:`` The basic seeds every farmer needs.|0|3|200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|surgical_kit|`oSurgical Kit``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 `#Rare Heart Monitor``, 1 Hospital Bed, 1 Train-E Bot, 5 of each of the 13 different Surical Tools and 10 Med-a-Checks.<CR><CR>`5Description:`` Get all the tools you need to become Chief of Surgery at Growtopia General Hospital! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) onit, Med-a-Checks to identify patients with maladies, The Train-E bot to practice on, and 5 each of the thirteen different Surgical Tools you'll need to do thatsurgery!|0|2|12000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|star_supplies|`oGalactic Goodies``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 60 Star Tools and 25 Star Fuel.<CR><CR>`5Description:`` Get all the Star Tools you need to boldly go where no Growtopian has gone! Use these to help you command a starship and seek victory in the Galactic Nexus! You'll get 5 each of the 12 Star Tools you'll need to complete missions and some bonus Star Fuel to help power a Starship!|0|0|15000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|fishin_pack|`oFishin' Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fishing Rod, 5 Wiggly Worms, 1 Hand Drill, 1 NuclearDetonator,  1 `#Rare Tackle Box``, 10 Fish Tanks and 1 `#Rare Fish Tank Port`` .<CR><CR>`5Description:`` Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, anda `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|geiger|`oGeiger Counter``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Geiger Counter.<CR><CR>`5Description:`` With this fantabulous device, you can detect radiation around you. It bleeps red, then yellow, then green as you get closer to the source. Who knows what you might find? `4Notavailable any other way!``|0|1|25000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|zombie_pack|`oZombie Defense Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 `#Rare Sawed-Off Shotgun``, 1 Combat Vest, 1 Zombie Stompin' Boots, 3 Traffic Barricades, 1 Military Radio, 1 Antidote, 3 Toxic Waste Barrels, 3 Biohazard Signs, 3 Tombstones and 1 `#Rare Deadly G-Virus``!.<CR><CR>`5Description:`` The zombie invasion has come! Protect yourself with allthe esential zombie fighting gear and best of all, you get an Antidote to cure yourself! Also includes the deadly g-Virus itself to infect your friends with!|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|boo_pack|`oB.O.O. Training Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Spectral Goggles``, 1 Neutron Gun, 1 Neutron Pack and 10 Ghost Jars <CR><CR>`5Description:`` It looks like Growtopia is under siege by ghosts! Well, the `9Battlers Of the Otherworldly`` are hiring! You'll have to earn your uniform, but this pack includes all the tools you need toactually capture ghosts! Including `#Rare`` Spectral Goggles (all the better tosee them with!)and a Neutron Pack to corral the ghosts, of course 10 Ghost Jarsto catch them in.|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|";

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), items_here));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						/*item 4*/
						if (items == "vegas_pack") {
							if (((PlayerInfo*)(peer->data))->gems >= 20000) {
								if (CheckItemMaxed(peer, 740, 10) || CheckItemMaxed(peer, 744, 1) || CheckItemMaxed(peer, 1582, 1) || CheckItemMaxed(peer, 752, 4) || CheckItemMaxed(peer, 456, 1) || CheckItemMaxed(peer, 754, 1) || CheckItemMaxed(peer, 756, 1) || CheckItemMaxed(peer, 758, 1) || CheckItemMaxed(peer, 794, 1) || CheckItemMaxed(peer, 796, 1) || CheckItemMaxed(peer, 798, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 11 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 20000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 740, 10);
								AddItemToInv(world, peer, 744, 1);
								AddItemToInv(world, peer, 1582, 1);
								AddItemToInv(world, peer, 752, 4);
								AddItemToInv(world, peer, 456, 1);
								AddItemToInv(world, peer, 754, 1);
								AddItemToInv(world, peer, 756, 1);
								AddItemToInv(world, peer, 748, 1);
								AddItemToInv(world, peer, 794, 1);
								AddItemToInv(world, peer, 746, 1);
								AddItemToInv(world, peer, 748, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oVegas Pack `wfor `$" + to_string(20000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``10 Neon Lights`$,`` Card Block Seed`$,`` Pink Cadillac`$,`` 4 Flipping Coin`$,`` Dice Block`$,`` Gambler's Visor`$,`` Slot Machine`$,`` Roulette Wheel`$,`` Showgirl Headdress`$,`` Showgirl Top`$,`` Showgirl Leggings\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oVegas Pack``!  You're `$" + to_string(20000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "farm_pack") {
							if (((PlayerInfo*)(peer->data))->gems >= 15000) {
								if (CheckItemMaxed(peer, 872, 1) || CheckItemMaxed(peer, 866, 1) || CheckItemMaxed(peer, 102, 100) || CheckItemMaxed(peer, 340, 40) || CheckItemMaxed(peer, 5666, 40) || CheckItemMaxed(peer, 954, 60) || CheckItemMaxed(peer, 4584, 75) || CheckItemMaxed(peer, 898, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 8 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 15000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 102, 100);
								AddItemToInv(world, peer, 340, 40);
								AddItemToInv(world, peer, 5666, 40);
								AddItemToInv(world, peer, 954, 60);
								AddItemToInv(world, peer, 4584, 75);
								AddItemToInv(world, peer, 898, 1);
								AddItemToInv(world, peer, 872, 1);
								AddItemToInv(world, peer, 866, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFarm Pack `wfor `$" + to_string(15000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received:`` 100 Wooden Platforms`$,`` 40 Chandeliers`$,`` 40 Laser Grids`$,`` 60 Sugar Canes`$,`` 75 Pepper Trees`$,`` Dear John Tractor\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFarm Pack``!  You're `$" + to_string(15000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "science_pack") {
							if (((PlayerInfo*)(peer->data))->gems >= 5000) {
								if (CheckItemMaxed(peer, 916, 5) || CheckItemMaxed(peer, 914, 10) || CheckItemMaxed(peer, 924, 5) || CheckItemMaxed(peer, 920, 5) || CheckItemMaxed(peer, 918, 5) || CheckItemMaxed(peer, 930, 1) || CheckItemMaxed(peer, 928, 1) || CheckItemMaxed(peer, 912, 1) || CheckItemMaxed(peer, 772, 1) || CheckItemMaxed(peer, 770, 1) || CheckItemMaxed(peer, 904, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 11 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 5000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 930, 1);
								AddItemToInv(world, peer, 328, 1);
								AddItemToInv(world, peer, 912, 1);
								AddItemToInv(world, peer, 772, 1);
								AddItemToInv(world, peer, 770, 1);
								AddItemToInv(world, peer, 904, 1);
								AddItemToInv(world, peer, 916, 5);
								AddItemToInv(world, peer, 914, 10);
								AddItemToInv(world, peer, 924, 5);
								AddItemToInv(world, peer, 920, 5);
								AddItemToInv(world, peer, 918, 5);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oMad Science Kit `wfor `$" + to_string(5000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received:`` Death Ray`&,`` Science Station`$,`` Laboratory`$,`` LabCoat`$,`` Combover Hair`$,`` Goggles`$,`` 5 Chemical R`$,`` 10 Chemical G`$,`` 5 Chemical Y`$,`` 5 Chemical B`$,`` 5 Chemical P\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oMad Science Kit``!  You're `$" + to_string(5000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "city_pack") {
							if (((PlayerInfo*)(peer->data))->gems >= 8000) {
								if (CheckItemMaxed(peer, 1008, 1) || CheckItemMaxed(peer, 986, 3) || CheckItemMaxed(peer, 992, 3) || CheckItemMaxed(peer, 990, 10) || CheckItemMaxed(peer, 996, 10) || CheckItemMaxed(peer, 998, 10) || CheckItemMaxed(peer, 988, 3) || CheckItemMaxed(peer, 1004, 10) || CheckItemMaxed(peer, 1006, 1) || CheckItemMaxed(peer, 1002, 1) || CheckItemMaxed(peer, 994, 10) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 11 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 8000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 1008, 1);
								AddItemToInv(world, peer, 986, 3);
								AddItemToInv(world, peer, 992, 3);
								AddItemToInv(world, peer, 990, 10);
								AddItemToInv(world, peer, 996, 10);
								AddItemToInv(world, peer, 998, 10);
								AddItemToInv(world, peer, 988, 3);
								AddItemToInv(world, peer, 1004, 10);
								AddItemToInv(world, peer, 1006, 1);
								AddItemToInv(world, peer, 1002, 1);
								AddItemToInv(world, peer, 994, 10);

								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oCity Pack `wfor `$" + to_string(8000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received:`` ATM Machine`&,`` 3 Street Signs`$,`` 3 Streetlamps`$,`` 10 Gothic Building tiles`$,`` 10 Tenement Building tiles`$,`` 10 Fire Escapes`$,`` 3 Gargoyles`$,`` 10 Hedges`$,`` 1 Blue Mailbox`$,`` 1 Fire Hydrant`$,`` 10 Sidewalks\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oCity Pack``!  You're `$" + to_string(8000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "west_pack") {
							if (((PlayerInfo*)(peer->data))->gems >= 8000) {
								if (CheckItemMaxed(peer, 1044, 1) || CheckItemMaxed(peer, 1046, 10) || CheckItemMaxed(peer, 1048, 1) || CheckItemMaxed(peer, 1020, 1) || CheckItemMaxed(peer, 1022, 1) || CheckItemMaxed(peer, 1030, 1) || CheckItemMaxed(peer, 1024, 1) || CheckItemMaxed(peer, 1026, 1) || CheckItemMaxed(peer, 1028, 1) || CheckItemMaxed(peer, 1036, 1) || CheckItemMaxed(peer, 1034, 1) || CheckItemMaxed(peer, 1032, 1) || CheckItemMaxed(peer, 1038, 10) || CheckItemMaxed(peer, 1040, 1) || CheckItemMaxed(peer, 1042, 5) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 15 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 8000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 1022, 1);
								AddItemToInv(world, peer, 1038, 1);
								AddItemToInv(world, peer, 1024, 1);
								AddItemToInv(world, peer, 1026, 1);
								AddItemToInv(world, peer, 1028, 1);
								AddItemToInv(world, peer, 1036, 1);
								AddItemToInv(world, peer, 1034, 3);
								AddItemToInv(world, peer, 1032, 1);
								AddItemToInv(world, peer, 1038, 10);
								AddItemToInv(world, peer, 1040, 1);
								AddItemToInv(world, peer, 1042, 5);
								AddItemToInv(world, peer, 1044, 1);
								AddItemToInv(world, peer, 1046, 10);
								AddItemToInv(world, peer, 1048, 1);
								AddItemToInv(world, peer, 1020, 1);

								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oWild West Pack `wfor `$" + to_string(8000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received:`` Cowboy Hat`&,`` Cowboy Boots`$,`` War Paint`$,`` Face Bandana`$,`` Sheriff Vest`$,`` Layer Cake Dress`$,`` Corset`$,`` Kansas Curls`$,`` 10 Western Building`$,`` Saloon Doors`$,`` 5 Western Banners`$,`` Buffalo`$,`` 10 Rustic Fences`$,`` Campfire`$,`` Parasol\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oWild West Pack``!  You're `$" + to_string(8000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "firefighter") {
							if (((PlayerInfo*)(peer->data))->gems >= 10000) {
								if (CheckItemMaxed(peer, 3048, 1) || CheckItemMaxed(peer, 3056, 1) || CheckItemMaxed(peer, 3060, 1) || CheckItemMaxed(peer, 3052, 1) || CheckItemMaxed(peer, 3066, 1) || CheckItemMaxed(peer, 3072, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 6 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 10000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 3048, 1);
								AddItemToInv(world, peer, 3056, 1);
								AddItemToInv(world, peer, 3060, 1);
								AddItemToInv(world, peer, 3052, 1);
								AddItemToInv(world, peer, 3066, 1);
								AddItemToInv(world, peer, 3072, 1);

								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFirefighter Pack `wfor `$" + to_string(10000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received:`` Firefighter Helmet - Yellow`$,`` Firefighter Pants - Yellow`$,`` Firefighter Jacket - Yellow`$,`` Firefighter Boots`$,`` Fire Hose`$,`` Firehouse\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFirefighter Pack``!  You're `$" + to_string(10000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "paintbrush") {
							if (((PlayerInfo*)(peer->data))->gems >= 30000) {
								if (CheckItemMaxed(peer, 3494, 1) || CheckItemMaxed(peer, 3478, 5) || CheckItemMaxed(peer, 3480, 5) || CheckItemMaxed(peer, 3482, 5) || CheckItemMaxed(peer, 3484, 5) || CheckItemMaxed(peer, 3486, 5) || CheckItemMaxed(peer, 3488, 5) || CheckItemMaxed(peer, 3490, 5) || CheckItemMaxed(peer, 3492, 5) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 9 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 30000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 3494, 1);
								AddItemToInv(world, peer, 3478, 5);
								AddItemToInv(world, peer, 3480, 5);
								AddItemToInv(world, peer, 3482, 5);
								AddItemToInv(world, peer, 3484, 5);
								AddItemToInv(world, peer, 3486, 5);
								AddItemToInv(world, peer, 3488, 5);
								AddItemToInv(world, peer, 3490, 5);
								AddItemToInv(world, peer, 3492, 5);

								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oPainter's Pack `wfor `$" + to_string(30000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received: ``Paintbrush`$,`` 5 Paint Bucket - Yellow`$,`` 5 Paint Bucket - Green`$,`` 5 Paint Bucket - Blue`$,`` 5 Paint Bucket - Varnish`$,`` 5 Paint Bucket - Red`$,`` 5 Paint Bucket - Charcoal`$,`` 5 Paint Bucket - Purple`$,`` 5 Paint Bucket - Aqua\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oPainter's Pack``!  You're `$" + to_string(30000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "paleo_kit") {
							if (((PlayerInfo*)(peer->data))->gems >= 20000) {
								if (CheckItemMaxed(peer, 4132, 5) || CheckItemMaxed(peer, 3932, 1) || CheckItemMaxed(peer, 3934, 1) || CheckItemMaxed(peer, 3938, 1) || CheckItemMaxed(peer, 4128, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 5 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								((PlayerInfo*)(peer->data))->gems -= 20000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								AddItemToInv(world, peer, 4132, 5);
								AddItemToInv(world, peer, 3932, 1);
								AddItemToInv(world, peer, 3934, 1);
								AddItemToInv(world, peer, 3938, 1);
								AddItemToInv(world, peer, 4128, 1);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oPaleontologist's Kit `wfor `$" + to_string(20000) + " `wGems.\nYou have `$" + to_string(((PlayerInfo*)(peer->data))->gems) + " `wGems left.\n\n`5Received:`` Fossil Prep Station`$,`` 5 Fossil Brushes`$,`` Rock Hammer`$,`` Rock Chisel`$,`` Blue Hardhat\n"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oPaleontologist's Kit``!  You're `$" + to_string(20000 - ((PlayerInfo*)(peer->data))->gems) + "`` Gems short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						/*end*/

						if (items == "weather") {
							string items_here = "";

							items_here += "set_description_text|`2Weather Machines!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|1|5|0|0||||-1|-1|||0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|\nadd_button|vegas_pack|`oVegas Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 Neon Lights, 1 Card Block Seed, 1 `#Rare Pink Cadillac`` 4 Flipping Coins, 1 Dice Block, 1 Gamblers Visor, 1 Slot Machine, 1 Roulette Wheel and 1 Showgirl Hat, 1 Showgirl top and 1 Showgirl Leggins.<CR><CR>`5Description:`` What happens in Growtopia stays in Growtopia!|0|5|20000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|farm_pack|`oFarm Pack``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Chicken, 1 Cow, 100 Wooden Platform, 40 Chandelier, 40 Laser Grid, 60 Sugar Cane, 75 Pepper Tree, 1 `#Rare`` `2Dear John Tractor``.<CR><CR>`5Description:`` Put the `2Grow`` in Growtopia with this pack, including a Cow you can milk, a Chicken that lays eggs and a farmer's outfit. Best of all? You get a `#Rare`` `2Dear John Tractor`` you can ride that will mow down trees!|0|0|15000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|science_pack|`oMad Science Kit``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Science Station, 1 Laboratory, 1 LabCoat, 1 Combover Hair, 1 Goggles, 5 Chemical R, 10 Chemical G, 5 Chemical Y, 5 Chemical B, 5 Chemical P and 1 `#Rare`` `2Death Ray``.<CR><CR>`5Description:`` It's SCIENCE! Defy the natural order with a Science Station that produces chemicals, a Laboratory in which to mix them and a full outfit to do so safely! You'll also get a starter pack of assorted chemicals. Mix them up! Special bonus: A `#Rare`` `2Death Ray`` to make your science truly mad!|0|3|5000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|city_pack|`oCity Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 10 Sidewalks, 3 Street Signs, 3 Streetlamps, 10 Gothic Building tiles, 10 Tenement Building tiles, 10 Fire Escapes, 3 Gargoyles, 10 Hedges, 1 Blue Mailbox, 1 Fire Hydrant and A `#Rare`` `2ATM Machine``.<CR><CR>`5Description:`` Life in the big city is rough but a `#Rare`` `2ATM Machine`` that dishes out gems once a day is very nice!|0|0|8000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|west_pack|`oWild West Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Cowboy Hat, 1 Cowboy Boots, 1 War Paint, 1 Face Bandana, 1 Sheriff Vest, 1 Layer Cake Dress, 1 Corset, 1 Kansas Curls, 10 Western Building 1 Saloon Doors, 5 Western Banners, 1 Buffalo, 10 Rustic Fences, 1 Campfire and 1 Parasol.<CR><CR>`5Description:`` Yippee-kai-yay! This pack includes everything you need to have wild time in the wild west! The Campfire plays cowboy music, and the `#Parasol`` lets you drift down slowly. Special bonus: A `#Rare`` `2Six Shooter`` to blast criminals with!|0|2|8000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|firefighter|`oFirefighter Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Yellow Helmet, 1 Yellow Jacket, 1 Yellow Pants, 1 Firemans Boots, 1 Fire Hose, and 1 `#Rare Firehouse``.<CR><CR>`5Description:`` Rescue Growtopians from the fire! Includes a full Yellow Firefighter Outfit, Fire Hose and a `#Rare Firehouse``, which will protect your own world from fires.|0|1|10000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|paintbrush|`oPainter's Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Paintbrush`` and 20 Random Colored Paint Buckets.<CR><CR>`5Description:`` Want to paint your world? This pack includes 20 buckets of random paint colors (may include Varnish, to clean up your messes)! You can paint any block in your world different colors to personalize it.|0|1|30000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|paleo_kit|`oPaleontologist's Kit``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 5 Fossil Brushes, 1 Rock Hammer, 1 Rock Chisel, 1 Blue Hardhat and 1 `#Rare Fossil Prep Station``.<CR><CR>`5Description:`` If you want to dig up fossils, this is the kit for you! Includes everything you need! Use the prepstation to get your fossils ready for display.|0|0|20000|0|||-1|-1||-1|-1||1||||||0|";

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), items_here));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}

						/*item 5*/
						if (items == "challenge_timer") {
							auto Price = 5;
							auto ItemID = 3804;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (std::exception& e) {
								std::cout << e.what() << std::endl;
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "xp_potion") {
							auto Price = 10;
							auto ItemID = 1488;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (std::exception& e) {
								std::cout << e.what() << std::endl;
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "megaphone") {
							auto Price = 10;
							auto ItemID = 2480;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (std::exception& e) {
								std::cout << e.what() << std::endl;
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "i_love_dirt_shirt") {
							auto Price = 4;
							auto ItemID = 11190;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "growmoji_pack") {
							vector<int> itemids{ 5770, 5772, 5774, 5776, 5778 };
							auto Price = 15;
							auto ItemID = itemids[rand() % itemids.size()];
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "mini_mod") {
							auto Price = 20;
							auto ItemID = 4758;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "derpy_star") {
							auto Price = 30;
							auto ItemID = 1628;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "dirt_gun") {
							auto Price = 40;
							auto ItemID = 2876;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "nothingness") {
							auto Price = 50;
							auto ItemID = 1490;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "spike_juice") {
							auto Price = 60;
							auto ItemID = 1662;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "doodad") {
							auto Price = 75;
							auto ItemID = 1492;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "crystal_cape") {
							auto Price = 90;
							auto ItemID = 1738;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "focused_eyes") {
							auto Price = 10000;
							auto ItemID = 1204;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "grip_tape") {
							auto Price = 100;
							auto ItemID = 3248;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "cat_eyes") {
							auto Price = 100;
							auto ItemID = 7106;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "riding_cloud") {
							auto Price = 0x3;
							auto ItemID = 11168;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "grow_boy") {
							auto Price = 100;
							auto ItemID = 10046;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "night_vision") {
							auto Price = 110;
							auto ItemID = 3576;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "muddy_pants") {
							auto Price = 125;
							auto ItemID = 2584;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "piranha") {
							auto Price = 150;
							auto ItemID = 1534;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "tsed") {
							auto Price = 150;
							auto ItemID = 10048;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "puddy_leash") {
							auto Price = 180;
							auto ItemID = 2032;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "anime_action_hair") {
							auto Price = 4;
							auto ItemID = 11154;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "golden_axe") {
							auto Price = 200;
							auto ItemID = 1438;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "puppy_leash") {
							auto Price = 200;
							auto ItemID = 1742;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "diggers_spade") {
							auto Price = 200;
							auto ItemID = 2952;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "meow_ears") {
							auto Price = 200;
							auto ItemID = 698;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "frosty_hair") {
							auto Price = 200;
							auto ItemID = 1444;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "zerkon_helmet") {
							auto Price = 200;
							auto ItemID = 1440;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "seils_magic_orb") {
							auto Price = 200;
							auto ItemID = 820;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "atomic_shadow_scythe") {
							auto Price = 200;
							auto ItemID = 1484;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "poseidon_diggers_trident") {
							auto Price = 200;
							auto ItemID = 7434;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (items == "really_dangerous_pet_llama") {
							auto Price = 200;
							auto ItemID = 10050;
							auto count = 1;
							auto ccount = 0;

							try {
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1486 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
										ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								}
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
							if (HasItemsInInv(peer, 1486, Price) != -1) {
								if (CheckItemMaxed(peer, ItemID, count) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || ((PlayerInfo*)(peer->data))->inventory.items.size() + 1 >= ((PlayerInfo*)(peer->data))->inventory.inventorySize && !CheckItemExists(peer, ItemID)) {
									Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									break;
								}
								RemoveItemFromInv(peer, 1486, Price, true);
								AddItemToInv(world, peer, ItemID, count);
								Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(ccount - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name + ""));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + itemDefs.at(ItemID).name + "``!  You're `$" + to_string(Price - ccount) + "`` Growtokens short."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}

						/*end*/

						if (items == "token") {

							string items_here = "";

							items_here += "set_description_text|`2Spend your Growtokens!`` (You have `50``) You earn Growtokens from Crazy Jim and Sales-Man. Select the item you'd like more info on, or BACK to go back.";
							items_here += "\nenable_tabs|1";
							items_here += "\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||1|2|0|0||||-1|-1|||0|0|";
							items_here += "\nadd_button|challenge_timer|`oChallenge Timer``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Challenge Timer.<CR><CR>`5Description:`` Get more people playing your parkours with this secure prize system. You'll need a `#Challenge Start Flag`` and `#Challenge End Flag`` as well (not included). Stockprizes into the Challenge Timer, set a time limit, and watch as players race from start to end. If they make it in time, they win a prize!|0|5|-5|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|xp_potion|`oExperience Potion``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Experience Potion.<CR><CR>`5Description:`` This `#Untradeable`` delicious fizzy drink will make you smarter! 10,000 XP smarter instantly, to be exact.|0|2|-10|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|megaphone|`oMegaphone``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Megaphone.<CR><CR>`5Description:`` You like broadcasting messages, but you're not so big on spending gems? Buy a Megaphone with Growtokens! Each Megaphone can be used once to send a super broadcast to all players in the game.|0|7|-10|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|i_love_dirt_shirt|`oI love Dirt Shirt``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 I love Dirt Shirt.<CR><CR>`5Description:`` Some people like things to be clean, you're not one of them are you? This item is `#Untradeable``.|4|0|-10|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|growmoji_pack|`oGrowmoji Mystery Box``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 1 Growmoji.<CR><CR>`5Description:`` Express yourself! This mysterious box contains one of five fun growmojis you can use to spice up your chat! Which will you get?|0|1|-15|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|mini_mod|`oMini-Mod``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Mini-Mod.<CR><CR>`5Description:`` Oh no, it's a Mini-Mod! Punch him to activate (you'll want to punch him!). When activated, he won't allowanyone to drop items in your world.|0|0|-20|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|derpy_star|`oDerpy Star Block``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Derpy Star Block.<CR><CR>`5Description:`` DER IM A SUPERSTAR. This is a fairly ordinary block, except for the derpy star on it. Note: it is not permanent, and it doesn't drop seeds. So use it wisely!|0|3|-30|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|dirt_gun|`oBLYoshi's Free Dirt``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 BLYoshi's Free Dirt.<CR><CR>`5Description:`` \"Free\" might be stretching it, but hey, once you buy this deadly rifle, you can spew out all the dirt you want for free! Note: the dirt is launched at high velocity and explodes on impact. Sponsored by BLYoshi.|0|4|-40|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|nothingness|`oWeather Machine - Nothingness``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Weather Machine - Nothingness.<CR><CR>`5Description:`` Tired of all that fancy weather?  This machine will turn yourworld completely black. Yup, that's it. Not a single pixel in the background except pure blackness.|0|3|-50|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|spike_juice|`oSpike Juice``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Spike Juice.<CR><CR>`5Description:`` It's fresh squeezed, with little bits of spikes still in it! Drinking this `#Untradeable`` one-use potion will make you immune to Death Spikes and Lava for 5 seconds.|0|5|-60|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|doodad|`oDoodad``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Doodad.<CR><CR>`5Description:`` I have no idea what this thing does. It's something electronic? Maybe?|0|5|-75|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|crystal_cape|`oCrystal Cape``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Crystal Cape.<CR><CR>`5Description:`` This cape is woven of pure crystal, which makes it pretty uncomfortable. But it also makes itmagical! It lets you double-jump off of an imaginary Crystal Block in mid-air. Sponsored by Edvoid20, HemeTems, and Aboge.|0|5|-90|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|focused_eyes|`oFocused Eyes``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Focused Eyes.<CR><CR>`5Description:`` This `#Untradeable`` item lets you shoot electricity from your eyes! Wear them with pride, andcreepiness.|0|4|-100|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|grip_tape|`oGrip Tape``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Grip Tape.<CR><CR>`5Description:`` This is handy for wrapping around the handle of a weapon or tool. It can improve your grip, as well asprotect you from cold metal handles. If you aren't planning to craft a weapon that requires Grip Tape, this does you no good at all!|0|5|-100|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|cat_eyes|`oCat Eyes``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Cat Eyes.<CR><CR>`5Description:`` Wow, pawesome! These new eyes are the cat's meow, and the purrfect addition to any style.|0|5|-100|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|riding_cloud|`oRiding Cloud``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Riding Cloud.<CR><CR>`5Description:`` Bringing the sky to the ground! This item is `#Untradeable``.|3|1|-100|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|grow_boy|`oGrowBoy``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Growboy.<CR><CR>`5Description:`` Bask in the nostalgic greenscreened goodness of the Growboy! A portable gaming device that packs a punch. Now you're playing with GrowPower! Note: The Growboy is `#UNTRADEABLE``.|0|2|-100|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|night_vision|`oNight Vision Goggles``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Night Vision Goggles.<CR><CR>`5Description:`` Scared of the dark? We have a solution. You can wear these goggles just to look cool, but if you also happen to have a D Battery (`4batteries not included``) on you, you will be able to see through darkness like it's not even there! EachD Battery can power your goggles for 1 minute. `2If you are in a world you own,the goggles will not require batteries!`` Note: you can't turn the goggles off without removing them, so you'll be wasting your battery if you wear them in daylight while carrying D Batteries.|0|3|-110|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|muddy_pants|`oMuddy Pants``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Muddy Pants.<CR><CR>`5Description:`` Well, this is just a pair of muddy pants. But it does come with a super secret bonus surprise that is sure to blow your mind!|0|7|-125|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|piranha|`oCuddly Piranha``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Cuddly Piranha.<CR><CR>`5Description:`` This friendly pet piranha won't stay in its bowl!  It just wants to snuggle with your face!|0|0|-150|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|tsed|`oTactical Stealth Espionage Device``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Tactical Stealth Espionage Device.<CR><CR>`5Description:`` This is Growtech's latest innovation on tactical espionage!Using the latest in scientific breakthroughs this device allows you to seamlessly disguise yourself as... a cardboard box! Note: The Tactical Stealth EspionageDevice is `#UNTRADEABLE``.|0|1|-150|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|puddy_leash|`oPuddy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puddy Leash.<CR><CR>`5Description:`` Puddy is a friendly little kitten who will follow you around forever.|0|7|-180|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|anime_action_hair|`oAnime Action Hair``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Anime Action Hair.<CR><CR>`5Description:`` Lights, camera, ANIME ACTION HAIR! Feel the power from root to tip every time you punch! This item is `#Untradeable``.|4|1|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|golden_axe|`oGolden Pickaxe``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Golden Pickaxe.<CR><CR>`5Description:`` Get your ownsparkly pickaxe! This `#Untradeable`` item is a status symbol! Oh sure, it isn't any more effective than a normal pickaxe, but it sparkles!|0|1|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|puppy_leash|`oPuppy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puppy Leash.<CR><CR>`5Description:`` Get your own petpuppy! This little dog will follow you around forever, never wavering in her loyalty, thus making her `#Untradeable``.|0|4|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|diggers_spade|`oDigger's Spade``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Digger's Spade.<CR><CR>`5Description:`` This mayappear to be a humble shovel, but in fact it is enchanted with the greatest magic in Growtopia. It can smash Dirt or Cave Background in a single hit! Unfortunately, it's worthless at digging through anything else. Note: The spade is `#UNTRADEABLE``.|0|7|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|meow_ears|`oMeow Ears``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Meow Ears.<CR><CR>`5Description:`` Meow's super special ears that everyone can now get! Note: These ears are `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|frosty_hair|`oFrosty Hair``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Frosty Hair.<CR><CR>`5Description:`` Coldplay is cold, but you can be freezing! Note: The frosty hair is `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|zerkon_helmet|`oEvil Space Helmet``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Evil Space Helmet.<CR><CR>`5Description:`` Zerkon commands a starship too small to actually board - pah, time to rule the galaxy properly! Note: The evil space helmet is `#UNTRADEABLE``.|0|6|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|seils_magic_orb|`oSeil's Magic Orbs``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Seil's Magic Orbs.<CR><CR>`5Description:`` Seil is some kind of evil wizard, now you can be too! Note: These magic orbs are`#UNTRADEABLE``.|0|7|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|atomic_shadow_scythe|`oAtomic Shadow Scythe``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Atomic Shadow Scythe.<CR><CR>`5Description:`` AtomicShadow might actually be evil, now you can try it out! Note: The shadow scythe is `#UNTRADEABLE``.|0|5|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|poseidon_diggers_trident|`oPoseidon's Digger's Trident``|interface/large/store_buttons/store_buttons25.rttex|`2You Get:`` 1 Poseidon's Digger's Trident.<CR><CR>`5Description:`` A gift from the gods. This may appear to be a humble trident, but in fact it has the power of Poseidon himself. It can smash `8DeepSand`` or `8Ocean Rock`` in a single hit. Unfortunately, you don't get to wieldthe full might of Poseidon... the trident is worthless at smashing anything else. Note: The trident is `#UNTRADEABLE``.|0|6|-200|0|||-1|-1||-1|-1||1||||||0|0|";
							items_here += "\nadd_button|really_dangerous_pet_llama|`oReally Dangerous Pet Llama``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Really Dangerous Pet Llama.<CR><CR>`5Description:`` This Llama is ready for anything Growtopia throws at it! Armed with a silo of Growtech Missiles, experimental Growtech hardened steel armor and a rather snazzy helmet (Llama's own) this Llama is Dangerous with acapital D! Note: This Really Dangerous Pet Llama is `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1||||||0|0|";

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), items_here));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|trade_started") == 0) { // trading
					}
					if (cch.find("action|trade_cancel") == 0) { // trading
						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
								continue;
							if (isHere(peer, currentPeer)) {
								if (((PlayerInfo*)(peer->data))->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
									SendCancelTrade(currentPeer, "Trade was cancelled by the other player.");
									SendCancelTrade(peer, "");
									break;
								}
							}
						}
					}
					if (cch.find("action|rem_trade\n") == 0) {
						try {
							int id = atoi(explode("\n", explode("|", cch).at(2)).at(0).c_str());
							if (id == -1) continue;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->tradeItems.size(); i++) {
								if (((PlayerInfo*)(peer->data))->tradeItems.at(i).id == id) {
									((PlayerInfo*)(peer->data))->tradeItems.erase(((PlayerInfo*)(peer->data))->tradeItems.begin() + i);
									break;
								}
							}
							for (ENetPeer* currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
									continue;
								if (isHere(peer, currentPeer)) {
									if (((PlayerInfo*)(peer->data))->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
										((PlayerInfo*)(peer->data))->isAcceptingTrade = false;
										((PlayerInfo*)(currentPeer->data))->isAcceptingTrade = false;
										UpdateTradeAcceptedStatus(peer);
										UpdateTradeAcceptedStatus(currentPeer);
										UpdateTradeStatus(peer, ((PlayerInfo*)(peer->data))->isTradingWithUserID, 1);
									}
								}
							}
						}
						catch (...) {
							continue;
						}
					}
					string modTradeText = "action|mod_trade\nitemID|";
					if (cch.find(modTradeText) == 0) {
						try {
							int id = atoi(explode("\n", explode("|", cch).at(2)).at(0).c_str());
							PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
							if (id == 6260 || itemDefs.at(id).properties & Property_Untradable || id == 18 || id == 32 || id == 6336 || id == 1794 || id == 1486 || id == 1794 || id == 5640 || id == 1424) {
								Player::OnTextOverlay(peer, "You'd be sorry if you lost that!");
								Player::PlayAudio(peer, "audio/cant_place_tile.wav", 0);
								break;
							} if (!pinfo->isTrading) {
								Player::PlayAudio(peer, "audio/cant_place_tile.wav", 0);
								break;
							} if (pinfo->tradeItems.size() >= 4) {
								Player::PlayAudio(peer, "audio/cant_place_tile.wav", 0);
								break;
							} if (((PlayerInfo*)(peer->data))->lastTRADE + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
								((PlayerInfo*)(peer->data))->lastTRADE = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								short int Count = 0;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
								{
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == id)
									{
										Count = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										break;
									}
								} if (Count == 1) {
									if (HasItemsInInv(peer, id, Count) == -1) continue;
									for (int i = 0; i < ((PlayerInfo*)(peer->data))->tradeItems.size(); i++) {
										if (((PlayerInfo*)(peer->data))->tradeItems.at(i).id == id) {
											((PlayerInfo*)(peer->data))->tradeItems.erase(((PlayerInfo*)(peer->data))->tradeItems.begin() + i);
											break;
										}
									}
									TradeItem trdItem = { id, Count };
									pinfo->tradeItems.push_back(trdItem);
									UpdateTradeStatus(peer, ((PlayerInfo*)(peer->data))->isTradingWithUserID, 1);
									break;
								}
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`2Trade `w" + getItemDef(id).name + "``|left|" + to_string(id) + "|\nadd_textbox|`2How many to trade?``|\nadd_text_input|count||" + to_string(Count) + "|3|\nend_dialog|trade_add" + to_string(id) + "|Cancel|OK|");
							}
							else {
								Player::OnTextOverlay(peer, "`oSlow down when adding and removing items, jeez!");
							}
						}
						catch (...) {
							continue;
						}
					}
					if (cch.find("action|trade_accept") == 0) {
						try {
							string status = explode("\n", explode("|", cch).at(2)).at(0);
							if (status != "1" and status != "0") break;
							PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
							if (!pinfo->isTrading) continue;
							if (status == "1") pinfo->isAcceptingTrade = true;
							else pinfo->isAcceptingTrade = false;
							UpdateTradeAcceptedStatus(peer);
							ENetPeer* peer2 = NULL;
							PlayerInfo* pinfo2 = NULL;

							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
								if (isHere(peer, currentPeer)) {
									if (pinfo->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(currentPeer->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
										pinfo2 = (PlayerInfo*)(currentPeer->data);
										peer2 = currentPeer;
										if (pinfo->isAcceptingTrade && pinfo2->isAcceptingTrade)
										{
											bool full_inv = false;
											int which_item = 0;
											if (((PlayerInfo*)(peer->data))->inventory.items.size() + pinfo2->tradeItems.size() > 200) {
												Player::OnTextOverlay(peer, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`w needs more backpack room first!");
												Player::OnTextOverlay(currentPeer, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`w needs more backpack room first!");
												pinfo->isAcceptingTrade = false;
												pinfo2->isAcceptingTrade = false;
												UpdateTradeAcceptedStatus(peer);
												UpdateTradeAcceptedStatus(currentPeer);
												break;
											}
											for (auto& f : static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) {
												if (CheckItemMaxed(peer, f.id, f.count) || pinfo->inventory.items.size() + 1 >= pinfo->inventory.inventorySize && CheckItemExists(peer, f.id) && CheckItemMaxed(peer, f.id, f.count) || pinfo->inventory.items.size() + 1 >= pinfo->inventory.inventorySize && !CheckItemExists(peer, f.id)) {
													full_inv = true;
													which_item = f.id;
													break;
												}
											}
											if (full_inv) {
												Player::OnTextOverlay(currentPeer, "`4Oops - " + pinfo->displayName + " `4is carrying too many " + itemDefs.at(which_item).name + " and can't fit that many in their backpack.");
												Player::OnTextOverlay(peer, "`4Oops - " + pinfo->displayName + " `4is carrying too many " + itemDefs.at(which_item).name + " and can't fit that many in their backpack.");
												pinfo->isAcceptingTrade = false;
												pinfo2->isAcceptingTrade = false;
												UpdateTradeAcceptedStatus(peer);
												UpdateTradeAcceptedStatus(currentPeer);
												break;
											}
											for (auto& f : static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) {
												if (CheckItemMaxed(peer, f.id, f.count) || pinfo->inventory.items.size() + 1 >= pinfo->inventory.inventorySize && CheckItemExists(peer, f.id) && CheckItemMaxed(peer, f.id, f.count) || pinfo->inventory.items.size() + 1 >= pinfo->inventory.inventorySize && !CheckItemExists(peer, f.id)) {
													full_inv = true;
													which_item = f.id;
													break;
												}
											}
											if (full_inv) {
												Player::OnTextOverlay(currentPeer, "`4Oops - " + pinfo->displayName + " `4is carrying too many " + itemDefs.at(which_item).name + " and can't fit that many in their backpack.");
												Player::OnTextOverlay(peer, "`4Oops - " + pinfo->displayName + " `4is carrying too many " + itemDefs.at(which_item).name + " and can't fit that many in their backpack.");
												pinfo->isAcceptingTrade = false;
												pinfo2->isAcceptingTrade = false;
												UpdateTradeAcceptedStatus(peer);
												UpdateTradeAcceptedStatus(currentPeer);
												break;
											}
											full_inv = false;
											if (static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + static_cast<PlayerInfo*>(peer->data)->tradeItems.size() >= static_cast<PlayerInfo*>(currentPeer->data)->inventory.inventorySize) {
												Player::OnTextOverlay(peer, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`w needs more backpack room first!");
												Player::OnTextOverlay(currentPeer, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`w needs more backpack room first!");
												pinfo->isAcceptingTrade = false;
												pinfo2->isAcceptingTrade = false;
												UpdateTradeAcceptedStatus(peer);
												UpdateTradeAcceptedStatus(currentPeer);
												break;
											}
											for (auto& f : static_cast<PlayerInfo*>(peer->data)->tradeItems) {
												if (CheckItemMaxed(currentPeer, f.id, f.count) || static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(currentPeer->data)->inventory.inventorySize && CheckItemExists(currentPeer, f.id) && CheckItemMaxed(currentPeer, f.id, f.count) || static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(currentPeer->data)->inventory.inventorySize && !CheckItemExists(currentPeer, f.id)) {
													full_inv = true;
													which_item = f.id;
													break;
												}
											}
											if (full_inv) {
												Player::OnTextOverlay(peer, "`4Oops - " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `4is carrying too many " + itemDefs.at(which_item).name + " and can't fit that many in their backpack.");
												Player::OnTextOverlay(currentPeer, "`4Oops - " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `4is carrying too many " + itemDefs.at(which_item).name + " and can't fit that many in their backpack.");
												pinfo->isAcceptingTrade = false;
												pinfo2->isAcceptingTrade = false;
												UpdateTradeAcceptedStatus(peer);
												UpdateTradeAcceptedStatus(currentPeer);
												break;
											}
											Player::OnForceTradeEnd(peer);
											Player::OnForceTradeEnd(peer2);
											pinfo->isInFinalTradeDialog = true;
											pinfo2->isInFinalTradeDialog = true;
											pinfo->isWaitingForTradeWithUserID = 0;
											pinfo2->isWaitingForTradeWithUserID = 0;
											pinfo->isWaitingForTrade = false;
											pinfo2->isWaitingForTrade = false;
											pinfo2->isAcceptingTrade = false;
											pinfo->isAcceptingTrade = false;
											Player::OnDialogRequest(peer, "add_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small\nadd_textbox|`4You'll give:|\nadd_spacer|small\n" + FormatTradeItemsForDialog(pinfo->tradeItems, 0) + "\nadd_spacer|small\nadd_textbox|`2You'll get:``|\nadd_spacer|small\n" + FormatTradeItemsForDialog(pinfo2->tradeItems, 1) + "\nadd_spacer|small\nadd_button|dothetrade|`oDo The Trade!``|\nend_dialog|tradeconfirm||Cancel|");
											Player::OnDialogRequest(peer2, "add_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small\nadd_textbox|`4You'll give:|\nadd_spacer|small\n" + FormatTradeItemsForDialog(pinfo2->tradeItems, 0) + "\nadd_spacer|small\nadd_textbox|`2You'll get:``|\nadd_spacer|small\n" + FormatTradeItemsForDialog(pinfo->tradeItems, 1) + "\nadd_spacer|small\nadd_button|dothetrade|`oDo The Trade!``|\nend_dialog|tradeconfirm||Cancel|");											break;
										}
									}
								}
							}
						}
						catch (...) {
							continue;
						}
					}


					if (cch.find("action|info") == 0) {
						try {
							int id = atoi(explode("\n", explode("|", cch).at(3)).at(0).c_str());
							if (id == -1 || itemDefs.size() < id || id < 0) break;
							string properties = "\nadd_textbox|";
							ItemDefinition itemDef = itemDefs.at(id);
							if (itemDef.properties & Property_Untradable) properties += "<CR>`1This item cannot be dropped or traded.`` ";
							if (itemDef.properties & Property_Wrenchable) properties += "<CR>`1This item has special properties you can adjust with the Wrench.`` ";
							if (itemDef.properties & Property_NoSeed) properties += "<CR>`1This item never drops any seeds.`` ";
							if (itemDef.properties & Property_Permanent) properties += "<CR>`1This item can't be destroyed - smashing it will return it to your backpack if you have room!`` ";
							if (properties != "\nadd_textbox|") properties += "|left|";
							else properties = "";
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_ele_icon|big|`wAbout " + itemDef.name + "``|left|" + std::to_string(id) + "|3|\nadd_spacer|small|\nadd_textbox|" + itemDef.description + "|left|" + properties + "|\nadd_spacer|small|\nend_dialog|continue||OK|");
						}
						catch (const std::out_of_range& e) {
							std::cout << e.what() << std::endl;
						}
					}
					if (cch.find("action|dialog_return\ndialog_name|editcanvas\ntilex|") != std::string::npos) {
						try {
							int netid = stoi(explode("\n", explode("portrait|", cch).at(1)).at(0));
							int x = stoi(explode("\n", explode("tilex|", cch).at(1)).at(0));
							int y = stoi(explode("\n", explode("tiley|", cch).at(1)).at(0));
							if (x < 0 || y < 0) continue;
							if (world->items.at(x + (y * world->width)).foreground == 3818) {
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
									if (((PlayerInfo*)(currentPeer->data))->netID == netid && isHere(peer, currentPeer)) {
										PlayerInfo* info = ((PlayerInfo*)(currentPeer->data));
										int fg = world->items.at(x + (y * world->width)).foreground, bg = world->items.at(x + (y * world->width)).background;
										Portrait(currentPeer, x, y, fg, bg, info->cloth_mask, info->cloth_hair, info->cloth_face, info->skinColor, 1, info->displayName, 65536 + getBlockState(world, x, y));
										string datas = to_string(info->cloth_hair) + "|" + to_string(info->cloth_mask) + "|" + to_string(info->cloth_face) + "|" + to_string(info->skinColor) + "|" + info->displayName + "|" + to_string(1) + "|";
										world->items.at(x + (y * world->width)).sign = datas;
										ENetPeer* currentPeer2;
										for (currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
											if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer2)) {
												Portrait(currentPeer2, x, y, fg, bg, info->cloth_mask, info->cloth_hair, info->cloth_face, info->skinColor, 1, info->displayName, 65536 + getBlockState(world, x, y));
											}
										}
									}
								}
							}
							else enet_peer_disconnect_later(peer, 0);
						}
						catch (const std::out_of_range& p) {
							std::cerr << p.what() << std::endl;
						}
						catch (const std::exception& p) {
							std::cerr << p.what() << std::endl;
						}
					}
					if (cch.find("action|dialog_return\ndialog_name|editemoji\ntilex|") != std::string::npos) {
						try {
							int x = stoi(explode("\n", explode("tilex|", cch).at(1)).at(0));
							int y = stoi(explode("\n", explode("tiley|", cch).at(1)).at(0));
							if (x < 0 || y < 0) continue;
							int fg = world->items.at(x + (y * world->width)).foreground, bg = world->items.at(x + (y * world->width)).background;
							if (cch.find("buttonClicked|erasepaint") != std::string::npos) {
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
									if (isHere(peer, currentPeer)) Portrait(currentPeer, x, y, fg, bg, 0, 0, 0, 0, 0, "", 65536 + getBlockState(world, x, y));
								}
								world->items.at(x + (y * world->width)).sign = "";
								break;
							}
							string ggwp = world->items.at(x + (y * world->width)).sign;
							const auto dt = explode("|", ggwp);
							int hair = stoi(dt[0]), mask = stoi(dt.at(1)), face = stoi(dt.at(2)), skin = stoi(dt.at(3));
							string title = explode("\n", explode("porttitle|", cch).at(1)).at(0);
							replaceAll(cch, "action|dialog_return\ndialog_name|editemoji\ntilex|" + to_string(x) + "\ntiley|" + to_string(y) + "\n", "");
							auto apa = explode("port", cch);
							for (auto& a : apa) {
								auto s = explode("|", a);
								if (s.size() == 2) {
									string id = s.at(0);
									string op = s.at(1);
									replaceAll(id, "\n", "");
									replaceAll(op, "\n", "");
									if (op == "1") {
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHere(peer, currentPeer)) {
												string idkok = explode("|", world->items.at(x + (y * world->width)).sign).at(4);
												Portrait(currentPeer, x, y, fg, bg, mask, hair, face, skin, stoi(id), title, 65536 + getBlockState(world, x, y));
												replaceAll(world->items.at(x + (y * world->width)).sign, idkok, title);
												replaceAll(world->items.at(x + (y * world->width)).sign, "|" + dt[5] + "|", "|" + id + "|");
											}
										}
									}
								}
							}
						}
						catch (const std::out_of_range& p) {
							std::cerr << p.what() << std::endl;
						}
						catch (const std::exception& p) {
							std::cerr << p.what() << std::endl;
						}
					}
					/*if (cch.find("action|dialog_return\ndialog_name|updaterift") != std::string::npos) {
						try {
							if (cch.find("buttonClicked|restore") != std::string::npos) {
								((PlayerInfo*)(peer->data))->ItemsOption = "cape=147,56,143:collar=147,56,143:cape2=137,30,43:collar2=137,30,43:delay=5";
								PlayerRiftCape(peer);
								break;
							}
							string rc = explode("\n", explode("rc|", cch).at(1)).at(0);
							string gc = explode("\n", explode("rg|", cch).at(1)).at(0);
							string bc = explode("\n", explode("rb|", cch).at(1)).at(0);

							string cr = explode("\n", explode("cr|", cch).at(1)).at(0);
							string cg = explode("\n", explode("cg|", cch).at(1)).at(0);
							string cb = explode("\n", explode("cb|", cch).at(1)).at(0);

							string rc2 = explode("\n", explode("rc2|", cch).at(1)).at(0);
							string gc2 = explode("\n", explode("rg2|", cch).at(1)).at(0);
							string bc2 = explode("\n", explode("rb2|", cch).at(1)).at(0);

							string cr2 = explode("\n", explode("cr2|", cch).at(1)).at(0);
							string cg2 = explode("\n", explode("cg2|", cch).at(1)).at(0);
							string cb2 = explode("\n", explode("cb2|", cch).at(1)).at(0);

							string delay = explode("\n", explode("mmmmkmmkkk|", cch).at(1)).at(0);

							if (has_only_digits(rc) && has_only_digits(gc) && has_only_digits(bc) && has_only_digits(cr) && has_only_digits(cg) && has_only_digits(cb)  && has_only_digits(rc2) && has_only_digits(gc2) && has_only_digits(bc2) && has_only_digits(cr2) && has_only_digits(cg2) && has_only_digits(cb2) && has_only_digits(delay)) {
								((PlayerInfo*)(peer->data))->ItemsOption = "cape=" + rc + "," + gc + "," + bc + ":collar=" + cr + "," + cg + "," + cb + ":cape2=" + rc2 + "," + gc2 + "," + bc2 + ":collar2=" + cr2 + "," + cg2 + "," + cb2 + ":delay=" + delay;
								PlayerRiftCape(peer);
							}
						}
						catch (...) {
							((PlayerInfo*)(peer->data))->ItemsOption = "cape=147,56,143:collar=147,56,143:cape2=137,30,43:collar2=137,30,43:delay=5";
							Player::OnConsoleMessage(peer, "`rOops! `oBug occurred, resetted your rift cape to default by `5SYSTEM");
							continue;
						}
					}*/
					if (cch.find("action|dialog_return\ndialog_name|updatefish") != std::string::npos) {
						int x = stoi(explode("|", explode("tilex|", cch).at(1)).at(0));
						int y = stoi(explode("|", explode("tiley|", cch).at(1)).at(0));
						if (x < 0 || y < 0) continue;
						if (cch.find("fishid|") != std::string::npos) {
							int id = stoi(explode("\n", explode("fishid|", cch).at(1)).at(0));
							if (isValidFish(peer, id)) {
								world->items.at(x + (y * world->width)).sign += to_string(id) + "|60|" + to_string(rand() % 5000) + ",";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
									if (isHere(peer, currentPeer)) {
										UpdatePort(currentPeer, x, y, 3002, 3004, world->items.at(x + (y * world->width)).sign);
									}
								}
							}
						}
						else if (cch.find("buttonClicked|remove_fish") != std::string::npos) {
							auto keren = explode("buttonClicked|remove_fish\n\n", cch).at(1);
							keren = explode("\nsinarfish|", keren)[0];
							auto lol = explode("\n", keren);
							for (auto& gg : lol) {
								auto s = explode("|", gg);
								if (s.at(1) == "1") {
									auto xd = explode("_", s[0]);
									string newfish = replace1(world->items.at(x + (y * world->width)).sign, xd.at(1) + "|" + xd.at(2) + "|" + xd.at(3) + ",", "");
									world->items.at(x + (y * world->width)).sign = newfish;
									Player::OnConsoleMessage(peer, "`oRemoved " + xd.at(2) + "lb. " + itemDefs[stoi(xd.at(1))].name);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (isHere(peer, currentPeer)) {

											UpdatePort(currentPeer, x, y, 3002, 3004, world->items.at(x + (y * world->width)).sign);
										}
									}
								}
							}
						}
					}
					if (cch.find("action|dialog_return") == 0)
					{
						std::stringstream ss(cch);
						std::string to;
						string dropitemcount = "0";
						string title, emoji;
						string playerNetId2 = "";
						string btn = "";
						bool isMarketDialog = false;
						string addItemToDonationBox = "";
						string givedonationboxitemNote = "";
						bool isTrashDialog = false;
						bool isgivedonationboxitemConfirm = false;
						string givedonationboxitemCount = "";
						bool isRegisterDialog = false;
						bool isGuildDialog = false;
						bool isEditDoorDialog = false;
						bool pindialog = false;
						bool pindialog2 = false;
						string pinenter = "";
						bool ChangePass = false;
						bool frnupdt = false;
						bool isHeatWave = false;
						bool isBG = false;
						bool isTradeDialog = false;
						bool isStuff = false;
						bool isToggleItem = false;
						bool bansubmit = false;
						bool bgtoken = false;
						bool sdbsend = false;
						string givedonationboxitemCoord = "";
						string givedonationboxitemItemID = "";
						string givedonationboxitem = "";
						string text1 = "", text2 = "", text3 = "";
						bool isTeleDialog = false;
						string destworld = "", destid = "", label = "", currid = "", opens = "";
						bool isDropDialog = false;
						bool isShelf = false;
						bool FindDialog2 = false;
						bool isFinishTrade = false;
						bool isCanvas = false;
						bool enablecollect = false;
						bool isMarsDialog = false;
						bool isGrowScanDialog = false;
						bool isGrowscan = false;
						bool entrancedialog = false;
						string marsname = "";
						bool  isaddItemToDonationBox = false;
						int itemtodo = 0;
						bool give_donate = false;
						bool store = false;
						string bgitem = "";
						string stuff_gravity = "";
						bool stuff_invert = false;
						bool stuff_spin = false;
						string username = "";
						string stuffITEM = "";
						int r = 0;
						string growtokencount = "";
						int g = 0;
						int b = 0;
						int givedonationboxitemCountInt = 0;
						int givedonationboxitemItemIDInt = 0;
						string noclip = "";
						string disable_music = "";
						int tempo = -1;
						string disable_music_render = "";
						string playerNetId = "";
						string doorworld = "";
						string doorid = "";
						string doordescription = "";
						string rainbows = "";
						string muted = "";
						int counttodo = 0;
						string password = "";
						string passwordverify = "";
						string email = "";
						string message = "";
						bool isConfirmQuest = false;
						string itemFind = "";
						bool isFindDialog = false;
						string pub = "";
						bool isEditState = false;
						string newstate = "";
						string guildName = "";
						string guildStatement = "";
						string guildFlagBg = "";
						string guildFlagFg = "";
						bool signEditor = false;
						bool captcha = false;
						string netid = "";
						bool accessPicker = false;
						string trashitemcount = "";
						bool confirmPurchase = false;
						bool lockkk = false;
						string showbillboard = "";
						string billboardprice = "";
						bool isBillBoard = false;
						bool ismars = false;
						string wlperitem = "";
						string itemperwl = "";
						int billitem = 0;
						bool billpicker = false;
						string canvastext = "";
						bool isMagDialog = false;
						bool PinDialog = false;
						bool isMagUpdateDialog = false;
						string checkbox_public = "";
						string day1 = "", day7 = "", day31 = "", forever = "", reason = "";
						string canvasitem = "";
						int stockitem = 0;
						string vend_set_price = "";
						int setprice = 0;
						string password2 = "";
						string password2verify = "";
						string oldpass = "";
						int buyprice = 0;
						string captchaanswer;
						bool vending_buy = false;
						bool triggersell = false;
						bool vending = false;
						string magplantitem = "";
						bool isThermoDialog = false;
						string thermoname = "";
						string publicremote = "";
						bool isopen = false, sliend = false;
						string per_item = "";
						bool msgfunc = false;
						bool isVipDialog = false, VipAccess = false, RemoveVipAccess = false;
						string vipid = "";
						string newpin = "", verifynewpin = "";
						string vipPub = "";
						/*Xenonite*/
						bool DoubleJumps = false;
						//
						try {
							while (std::getline(ss, to, '\n')) {
								vector<string> infoDat = explode("|", to);
								if (infoDat.size() == 2) {
									if (infoDat.at(0) == "buttonClicked") btn = infoDat.at(1);
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "register")
									{
										isRegisterDialog = true;
									}
									if (infoDat[0] == "dialog_name" && infoDat[1] == "pindia")
										PinDialog = true;
									if (PinDialog) {
										if (infoDat[0] == "newpin") newpin = infoDat[1];
										if (infoDat[0] == "verifynewpin") verifynewpin = infoDat[1];
									}
									if (infoDat[0] == "dialog_name" && infoDat[1] == "pin2") {
										pindialog2 = true;
									}
									if (pindialog2) {
										if (infoDat[0] == "pinenter") pinenter = infoDat[1];
									}
									if (infoDat[0] == "dialog_name" && infoDat[1] == "pin") {
										pindialog = true;
									}
									if (pindialog) {
										if (infoDat[0] == "pinenter") pinenter = infoDat[1];
									}
									if (infoDat[0] == "dialog_name" && infoDat[1] == "pssdia")
										ChangePass = true;
									if (ChangePass) {
										if (infoDat[0] == "oldpass") oldpass = infoDat[1];
										if (infoDat[0] == "newpass") password2 = infoDat[1];
										if (infoDat[0] == "verifypass")	password2verify = infoDat[1];
									}
									if (infoDat.at(0).substr(0, 16) == "addDonationItem_")
										isaddItemToDonationBox = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "updtfrn") {
										frnupdt = true;
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "msgdia") {
										msgfunc = true;
									}
									if (msgfunc) {
										if (infoDat.at(0) == "msgtest") {
											ENetPeer* currentPeer;

											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (!((PlayerInfo*)(currentPeer->data))->radio)
													continue;
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastFrnName) {
													((PlayerInfo*)(currentPeer->data))->lastFrnName = ((PlayerInfo*)(peer->data))->rawName;
													GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`6>> (Sent to `2" + ((PlayerInfo*)(peer->data))->lastFrnName + "`6)"));
													ENetPacket* packet0 = enet_packet_create(p0.data, p0.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet0);
													delete p0.data;
													GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:_CT:[MSG]_>> `c>> from (```c`w" + ((PlayerInfo*)(peer->data))->displayName + "`````c) in [`$`$" + ((PlayerInfo*)(peer->data))->currentWorld + "````] > ```$" + infoDat.at(1) + "``"));
													string text = "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0\n";
													BYTE* data = new BYTE[5 + text.length()];
													BYTE zero = 0;
													int type = 3;
													memcpy(data, &type, 4);
													memcpy(data + 4, text.c_str(), text.length());
													memcpy(data + 4 + text.length(), &zero, 1);
													ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(currentPeer, 0, packet2);
													delete[] data;
													ENetPacket* packet = enet_packet_create(ps.data, ps.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(currentPeer, 0, packet);
													delete ps.data;
													break;
												}
											}
										}
									}
									if (frnupdt) {
										if (infoDat.at(0) == "checkbox_public") {
											if (infoDat.at(1) == "1") {
												((PlayerInfo*)(peer->data))->showloc = false;
												FlushPlayer(peer);
											}
											if (infoDat.at(1) == "0") {
												((PlayerInfo*)(peer->data))->showloc = true;
												FlushPlayer(peer);
											}
											string onlinefrnlist = "";
											int onlinecount = 0;
											int totalcount = ((PlayerInfo*)(peer->data))->friendinfo.size();
											ENetPeer* currentPeer;

											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;

												string name = ((PlayerInfo*)(currentPeer->data))->rawName;
												if (find(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), name) != ((PlayerInfo*)(peer->data))->friendinfo.end()) {
													onlinefrnlist += "\nadd_button|onlinefrns_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + "``|0|0|";
													onlinecount++;

												}

											}
											if (totalcount == 0) {
												GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_label|small|`oYou currently have no friends.  That's just sad.  To make some, click a person's wrench icon, then choose `5Add as friend`o.``|left|4|\n\nadd_spacer|small|\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backfriend|Back|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
												ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
											}
											else if (onlinecount == 0) {
												GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_label|small|`oNone of your friends are currently online.``|left|4|\n\nadd_spacer|small|\nadd_button|showoffline|`oShow offline``|0|0|\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backfriend|Back|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
												ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
											}
											else {
												GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|" + onlinefrnlist + "\n\nadd_spacer|small|\nadd_button|showoffline|`oShow offline``|0|0|\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backfriend|Back|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
												ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
											}
										} continue;
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "sendsdb") {
										sdbsend = true;
									}
									if (sdbsend) {
										if (infoDat[0] == "text1") text1 = infoDat[1];
										if (infoDat[0] == "text2") text2 = infoDat[1];
										if (infoDat[0] == "text3") text3 = infoDat[1];
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "toggleshit") isToggleItem = true;
									if (isToggleItem) {
										if (infoDat[0] == "checkbox_silenced") sliend = atoi(infoDat[1].c_str());
										if (infoDat[0] == "checkbox_public") isopen = atoi(infoDat[1].c_str());

									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "sdbrespond") {
										Send_Cancel_Game(peer);
										sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
										handle_world(peer, worldas_);
									}
									if (isToggleItem) {
										int x = ((PlayerInfo*)(peer->data))->lastPunchX;
										int y = ((PlayerInfo*)(peer->data))->lastPunchY;
										if (x < 0 || y < 0) break;
										if (sliend == false) {
											world->items[x + (y * world->width)].silenced = false;
											UpdateBlockState(peer, x, y, true, world);
										}
										else {
											world->items[x + (y * world->width)].silenced = true;
											UpdateBlockState(peer, x, y, true, world);
										}
										if (isopen == false) {
											world->items[x + (y * world->width)].opened = false;
										}
										else {
											world->items[x + (y * world->width)].opened = true;
										}
										SaveBlockState(world, peer, x, y);
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "purchase_item")
										isMarketDialog = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "store_buy_confirm") {
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										if (pData->laststorebuyprice == 0 || pData->laststorebuyid == 0 || pData->laststorebuycount == 0) break;
										int kaina_wls = pData->laststorebuyprice;
										int item_id = pData->laststorebuyid;
										int kiek_turi_kainoti = pData->laststorebuycount;
										if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
											kiek_turi_kainoti = rand() % 51 + 150;
										}
										int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
										int is_viso_worldlock = kaina_wls;
										while (is_viso_worldlock >= 100) {
											is_viso_worldlock -= 100;
											diamond_lock++;
										}
										world_lock = is_viso_worldlock;
										int turi_world_lock = atoi(GetItemCount(peer, 242).c_str());
										int turi_diamond_lock = atoi(GetItemCount(peer, 1796).c_str());
										while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
											turi_diamond_lock++;
											turi_world_lock -= 100;
										} if (diamond_lock > turi_diamond_lock) {
											Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
											break;
										} while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
											turi_diamond_lock--;
											turi_world_lock += 100;
										} if (world_lock > turi_world_lock) {
											Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
											break;
										}
										turi_world_lock -= world_lock;
										turi_diamond_lock -= diamond_lock;
										RemoveItemFromInv(peer, 242, atoi(GetItemCount(peer, 242).c_str()), true);
										RemoveItemFromInv(peer, 1796, atoi(GetItemCount(peer, 1796).c_str()), true);
										AddItemToInv(world, peer, 242, turi_world_lock);
										AddItemToInv(world, peer, 1796, turi_diamond_lock);
										Player::OnConsoleMessage(peer, "`oPurchased " + to_string(kiek_turi_kainoti) + " `o" + itemDefs.at(item_id).name + " `ofor `o" + to_string(kaina_wls) + " `oWorld locks");
										Player::OnTalkBubble(peer, pData->netID, "Purchased " + to_string(kiek_turi_kainoti) + " " + itemDefs.at(item_id).name + " for " + to_string(kaina_wls) + " World locks", 0);
										SendTradeEffect(peer, item_id, pData->netID, pData->netID, 150);

										Player::PlayAudio(peer, "audio/cash_register.wav", 0);
										AddItemToInv(world, peer, item_id, kiek_turi_kainoti);
										try {
											int kiek_pirko = 0;
											ifstream infile("price_data.txt");
											for (string line; getline(infile, line);) {
												if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
													auto ex = explode("|", line);
													if (ex.at(0) == to_string(item_id)) {
														kiek_pirko = atoi(ex.at(2).c_str());
														break;
													}
												}
											}
											infile.close();
											string strReplace = to_string(item_id) + "|" + to_string(kiek_turi_kainoti) + "|" + to_string(kiek_pirko);
											kiek_pirko += kiek_turi_kainoti;
											string strNew = to_string(item_id) + "|" + to_string(kiek_turi_kainoti) + "|" + to_string(kiek_pirko);
											ifstream filein("price_data.txt");
											ofstream fileout("price_data_backup.txt");
											if (!filein || !fileout) {
												cout << "Filesystem Exception #39 Failed to update file" << endl;
												return 1;
											}
											string strTemp;
											while (filein >> strTemp) {
												if (strTemp == strReplace) {
													strTemp = strNew;
												}
												strTemp += "\n";
												fileout << strTemp;
											}
											filein.close();
											fileout.close();
											char oldname[] = "price_data_backup.txt";
											char newname[] = "price_data.txt";
											remove("price_data.txt");
											if (rename(oldname, newname) != 0) {
												cout << "Filesystem Exception #39 Failed to rename file" << endl;
											}
											remove("price_data_backup.txt");
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
										break;
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "store_sell_confirm") {
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										if (pData->laststoreselldiamondlocks == 0 && pData->laststoresellworldlocks == 0 || pData->laststoresellid == 0 || pData->laststoresellcount == 0) break;
										int diamondlocks = pData->laststoreselldiamondlocks;
										int worldlocks = pData->laststoresellworldlocks;
										int sell_id = pData->laststoresellid;
										int sell_count = pData->laststoresellcount;
										auto contains = false;
										if (HasItemsInInv(peer, sell_id, sell_count) == -1) {
											Player::OnTalkBubble(peer, pData->netID, "You don't have " + to_string(sell_count) + " of " + itemDefs.at(sell_id).name + " to sell!", 0);
											break;
										}
										RemoveItemFromInv(peer, sell_id, sell_count, true);
										if (diamondlocks != 0) {
											AddItemToInv(world, peer, 1796, diamondlocks);
										} if (worldlocks != 0) {
											AddItemToInv(world, peer, 242, worldlocks);
										}
										int kaina_wls = diamondlocks * 100 + worldlocks;
										Player::OnConsoleMessage(peer, "`oSold " + to_string(sell_count) + " `o" + itemDefs.at(sell_id).name + " `ofor `o" + to_string(kaina_wls) + " `oWorld locks");
										Player::OnTalkBubble(peer, pData->netID, "Sold " + to_string(sell_count) + " " + itemDefs.at(sell_id).name + " for " + to_string(kaina_wls) + " World locks", 0);
										if (diamondlocks != 0) SendTradeEffect(peer, 1796, pData->netID, pData->netID, 150);
										if (worldlocks != 0) SendTradeEffect(peer, 242, pData->netID, pData->netID, 150);
										Player::PlayAudio(peer, "audio/cash_register.wav", 0);
										break;
									}
									if (isMarketDialog) {
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										if (infoDat.at(1).substr(0, 19) == "sellitembyrarityid_") {
											if (!triggersell) {
												triggersell = true;
												continue;
											}
										}
										if (infoDat.at(0).substr(0, 18) == "buyitembyrarityid_") {
											string strButItemByRarityCount = infoDat.at(1);
											string id = infoDat.at(0).substr(infoDat.at(0).find("_") + 1);
											if (triggersell) {
												bool contains_non_int2 = !std::regex_match(strButItemByRarityCount, std::regex("^[0-9]+$"));
												bool contains_non_int4 = !std::regex_match(id, std::regex("^[0-9]+$"));
												if (strButItemByRarityCount == "" || contains_non_int4 || id.size() > 5 || id.size() <= 0 || strButItemByRarityCount.length() > 5 || contains_non_int2 || strButItemByRarityCount.size() > 3 || strButItemByRarityCount.size() <= 0) {
													Player::OnTalkBubble(peer, pData->netID, "You can't sell more than 200 or less than 0!", 0);
													break;
												}
												//sell items
												int item_count = atoi(strButItemByRarityCount.c_str());
												int item_id = atoi(id.c_str());
												int itemid = item_id;
												if (itemDefs.at(itemid).properties & Property_Untradable && itemDefs.at(itemid).rarity == 999 || itemDefs.at(itemid).blockType != BlockTypes::CLOTHING && itemDefs.at(itemid).rarity == 999 && itemid != 1436 && itemid != 5142 && itemid != 7188 && itemid != 9498 && itemid != 3176 && itemid != 9528 && itemid != 5154 && itemid != 5140 && itemid != 5138 && itemid != 5136 && itemid != 7382 && itemid != 4762 || itemid == 18 && itemid != 7188 || itemid == 10034 || itemDefs.at(itemid).name.find("null") != string::npos || itemid == 10036 || itemDefs.at(itemid).name.find("Mooncake") != string::npos || itemDefs.at(itemid).name.find("Harvest") != string::npos && itemid != 1830 || itemDefs.at(itemid).name.find("Autumn") != string::npos || itemid == 1056 || itemid == 1804 || itemDefs.at(itemid).blockType == BlockTypes::COMPONENT || itemid == 912 || itemid == 952 || itemid == 1472 || itemid == 1664 || itemid == 6920 || itemid == 6922 || itemid == 1874 || itemid == 1876 || itemid == 1904 || itemid == 1932 || itemid == 1900 || itemid == 1986 || itemid == 1996 || itemid == 2970 || itemid == 3140 || itemid == 3174 || itemid == 6028 || itemid == 6846 || itemid == 8962 || itemid == 2408 || itemid == 4428 || itemid == 5086 || itemid == 9240 || itemid == 9306 || itemid == 9290 || itemid == 7328 || itemid == 9416 || itemid == 10386 || itemid == 9410 || itemid == 1458 || itemid == 9408 || itemid == 9360 || itemid == 6866 || itemid == 6868 || itemid == 6870 || itemid == 6872 || itemid == 6874 || itemid == 6876 || itemid == 6878 || itemid == 2480 || itemid == 8452 || itemid == 5132 || itemid == 7166 || itemid == 5126 || itemid == 5128 || itemid == 5130 || itemid == 5144 || itemid == 5146 || itemid == 5148 || itemid == 5150 || itemid == 5162 || itemid == 5164 || itemid == 5166 || itemid == 5168 || itemid == 5180 || itemid == 5182 || itemid == 5184 || itemid == 5186 || itemid == 7168 || itemid == 7170 || itemid == 7172 || itemid == 7174 || itemid == 8834 || itemid == 7912 || itemid == 9212 || itemid == 5134 || itemid == 5152 || itemid == 5170 || itemid == 5188 || itemid == 980 || itemid == 9448 || itemid == 9310 || itemid == 10034 || itemid == 10036 || itemid == 8470 || itemid == 8286 || itemid == 6026 || itemid == 1784 || itemid == 9356 || itemid == 10022 || itemid == 902 || itemid == 10032 || itemid == 834 || itemid == 6 || itemid == 5640 || itemid == 9492 || itemid == 1782 || itemid == 9288 || itemid == 1780 || itemid == 8306 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 2950 || itemid == 4802 || itemid == 4994 || itemid == 5260 || itemid == 5814 || itemid == 5980 || itemid == 7734 || itemid == 2592 || itemid == 2242 || itemid == 1794 || itemid == 1792 || itemid == 778 || itemid == 9510 || itemid == 8774 || itemid == 2568 || itemid == 9512 || itemid == 9502 || itemid == 9482 || itemid == 2250 || itemid == 2248 || itemid == 2244 || itemid == 2246 || itemid == 2286 || itemid == 9508 || itemid == 9504 || itemid == 9506 || itemid == 274 || itemid == 276 || itemid == 9476 || itemid == 1486 || itemid == 4426 || itemid == 9496 || itemid == 278 || itemid == 9490 || itemid == 2410 || itemid == 9488 || itemid == 9452 || itemid == 9454 || itemid == 9472 || itemid == 9456 || itemid == 732 || itemid == 9458 || itemid == 6336 || itemid == 112 || itemid == 8 || itemid == 3760 || itemid == 18 || itemid == 7372 || itemid == 9438 || itemid == 9462 || itemid == 9440 || itemid == 9442 || itemid == 9444 || itemid == 7960 || itemid == 7628 || itemid == 8552) break;
												if (getItemDef(itemid).blockType == BlockTypes::SEED || itemid == 6312 || itemid == 998 || itemid == 986 || itemid == 992 || itemid == 990 || itemid == 996 || itemid == 988 || itemid == 1004 || itemid == 1006 || itemid == 1002 || itemid == 9504 || itemid == 9506 || itemid == 9508 || itemid == 9510 || itemid == 9512 || itemid == 9514 || itemid == 9518 || itemid == 9520 || itemid == 9502 || itemid == 9496 || itemid == 1790 || itemid == 9492 || itemid == 9494 || itemid == 9488 || itemid == 9222 || itemid == 1360 || itemid == 6260 || itemid == 822 || itemid == 1058 || itemid == 1094 || itemid == 1096 || itemid == 3402 || itemid == 1098 || itemid == 1828 || itemid == 3870 || itemid == 7058 || itemid == 1938 || itemid == 8452 || itemid == 1740 || itemid == 3040 || itemid == 5080 || itemid == 3100 || itemid == 1550 || itemid == 5740 || itemid == 3074 || itemid == 3010 || itemid == 8480 || itemid == 5084 || itemid == 10424 || itemid == 4656 || itemid == 7558 || itemid == 5082 || itemid == 1636 || itemid == 6008 || itemid == 4996 || itemid == 6416 || itemid == 2206 || itemid == 3792 || itemid == 3196 || itemid == 4654 || itemid == 3306 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 2242 || itemid == 2244 || itemid == 2246 || itemid == 2248 || itemid == 2250 || itemid == 4676 || itemid == 4678 || itemid == 4680 || itemid == 4682 || itemid == 4652 || itemid == 4646 || itemid == 4648 || itemid == 4652 || itemid == 4650 || itemid == 10084 || itemid == 10086 || itemid == 9168 || itemid == 5480 || itemid == 4534 || itemid == 9166 || itemid == 9164 || itemid == 9162 || itemid == 9160 || itemid == 9158 || itemid == 9156 || itemid == 9154 || itemid == 9152 || itemid == 3008 || itemid == 3010 || itemid == 3040 || itemid == 5740 || itemid == 6254 || itemid == 6256 || itemid == 6258 || itemid == 6932 || itemid == 10262 || itemid == 10616 || itemid == 10582 || itemid == 10580 || itemid == 10664 || itemid == 10596 || itemid == 10598 || itemid == 10586 || itemid == 10590 || itemid == 10592 || itemid == 10576 || itemid == 10578 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 4994 || itemid == 2978 || itemid == 9268 || itemid == 5766 || itemid == 5768 || itemid == 5744 || itemid == 5756 || itemid == 5758 || itemid == 5760 || itemid == 5762 || itemid == 5754 || itemid == 7688 || itemid == 7690 || itemid == 7694 || itemid == 7686 || itemid == 7692 || itemid == 7698 || itemid == 7696 || itemid == 9286 || itemid == 9272 || itemid == 9290 || itemid == 9280 || itemid == 9282 || itemid == 9292 || itemid == 9284 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 10660 || itemid == 10654 || itemid == 10632 || itemid == 10652 || itemid == 10626 || itemid == 10640 || itemid == 10662 || itemid == 574 || itemid == 592 || itemid == 760 || itemid == 900 || itemid == 766 || itemid == 1012 || itemid == 1272 || itemid == 1320 || itemid == 1540 || itemid == 1648 || itemid == 1740 || itemid == 1950 || itemid == 2900 || itemid == 1022 || itemid == 1030 || itemid == 1024 || itemid == 1032 || itemid == 1026 || itemid == 1028 || itemid == 1036 || itemid == 1034 || itemid == 2908 || itemid == 2974 || itemid == 3494 || itemid == 3060 || itemid == 3056 || itemid == 3052 || itemid == 3066 || itemid == 3048 || itemid == 3068 || itemid == 3166 || itemid == 2032 || itemid == 6780 || itemid == 754 || itemid == 794 || itemid == 796 || itemid == 2876 || itemid == 798 || itemid == 930 || itemid == 2204 || itemid == 2912 || itemid == 772 || itemid == 770 || itemid == 898 || itemid == 1582 || itemid == 1020 || itemid == 4132 || itemid == 3932 || itemid == 3934 || itemid == 4128 || itemid == 10246 || itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7130) break;
												if (itemid == 4762 || itemid == 5136 || itemid == 7382 || itemid == 5154 || itemid == 5140 || itemid == 5138 || itemid == 9498 || itemid == 9530 || itemid == 9526 || itemid == 9524 || itemid == 6398 || itemid == 6426 || itemid == 6340 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 2386 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 9350 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 392 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) break;
												//food
												if (itemid == 4586 || itemid == 962 || itemid == 4564 || itemid == 4570 || itemid == 4598 || itemid == 868 || itemid == 196 || itemid == 4766 || itemid == 4568 || itemid == 4596 || itemid == 3472 || itemid == 7672 || itemid == 7056 || itemid == 4764 || itemid == 6316 || itemid == 676 || itemid == 874 || itemid == 4666 || itemid == 4594 || itemid == 4602 || itemid == 4604) break;
												//robber things
												if (itemid == 9428 || itemid == 8372 || itemid == 1460 || itemid == 1970 || itemid == 3930 || itemid == 944 || itemid == 1538 || itemid == 7588 || itemid == 1696) break;
												// space alien
												if (itemid == 4820 || itemid == 1674 || itemid == 10952 || itemid == 10954 || itemid == 10956 || itemid == 10958 || itemid == 10960) break;
												// ezio
												if (itemid == 11560 || itemid == 11554 || itemid == 11556 || itemid == 11558) break;
												int kiek_turi_kainoti = 0;
												try {
													ifstream infile("price_data.txt");
													for (string line; getline(infile, line);) {
														if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
															auto ex = explode("|", line);
															if (ex.at(0) == to_string(item_id)) {
																kiek_turi_kainoti = atoi(ex.at(1).c_str());
																break;
															}
														}
													}
													infile.close();
												}
												catch (std::exception& e) {
													std::cout << e.what() << std::endl;
												}
												catch (const std::out_of_range& e) {
													std::cout << e.what() << std::endl;
												}
												if (itemid == 7188) kiek_turi_kainoti = 10000;
												int kiek_ruosiasi_parduoti = 0;
												if (itemDefs.at(item_id).blockType == BlockTypes::SIGN && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::GATEWAY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::BACKGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DOOR && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DEADLY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PAIN_BLOCK && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PLATFORM && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::FOREGROUND && itemDefs.at(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || itemDefs.at(item_id).blockType == BlockTypes::SFX_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::ANIM_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && itemDefs.at(item_id).rarity != 999) {
													if (itemDefs.at(item_id).rarity < 14) break;
													kiek_ruosiasi_parduoti = item_count * kiek_turi_kainoti;
												}
												else {
													if (itemDefs.at(item_id).rarity != 999 && itemid != 9498 && itemid != 5154 && itemid != 5140 && itemid != 5138 && itemid != 5136 && itemid != 7382 && itemid != 4762) break;
													kiek_ruosiasi_parduoti = item_count;
												}
												if (kiek_ruosiasi_parduoti < 1 || kiek_ruosiasi_parduoti > 200) {
													Player::OnTalkBubble(peer, pData->netID, "You can't sell more than 200 or less than 0!", 0);
													break;
												}
												if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
													kiek_ruosiasi_parduoti = 200;
												}
												if (HasItemsInInv(peer, item_id, kiek_ruosiasi_parduoti) == -1) {
													Player::OnTalkBubble(peer, pData->netID, "You don't have " + to_string(kiek_ruosiasi_parduoti) + " of " + itemDefs.at(item_id).name + " to sell!", 0);
													break;
												}
												auto worldlocks = 0;
												if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
													worldlocks = kiek_turi_kainoti;
												}
												else if (itemDefs.at(item_id).blockType == BlockTypes::SIGN && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::GATEWAY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::BACKGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DOOR && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DEADLY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PAIN_BLOCK && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PLATFORM && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::FOREGROUND && itemDefs.at(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || itemDefs.at(item_id).blockType == BlockTypes::SFX_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::ANIM_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && itemDefs.at(item_id).rarity != 999) {
													worldlocks = item_count;
												}
												else {
													worldlocks = kiek_turi_kainoti * kiek_ruosiasi_parduoti;
												}
												auto diamondlocks = 0;
												while (worldlocks >= 100) {
													diamondlocks++;
													worldlocks -= 100;
												}
												if (CheckItemMaxed(peer, 242, worldlocks) || worldlocks > 200) {
													Player::OnTalkBubble(peer, pData->netID, "" + to_string(worldlocks) + " World locks Wouldnt fit into my inventory!", 0);
													break;
												}
												if (CheckItemMaxed(peer, 1796, diamondlocks) || diamondlocks > 200) {
													Player::OnTalkBubble(peer, pData->netID, "" + to_string(diamondlocks) + " Diamond locks Wouldnt fit into my inventory!", 0);
													break;
												}
												string kiek_gaus = "";
												if (diamondlocks != 0) {
													kiek_gaus += "\nadd_label_with_icon|small|(`w" + to_string(diamondlocks) + "``) `2Diamond Locks``|left|1796|";
												}
												if (worldlocks != 0) {
													kiek_gaus += "\nadd_label_with_icon|small|(`w" + to_string(worldlocks) + "``) `2World Locks``|left|242|";
												}
												pData->laststoresellworldlocks = worldlocks;
												pData->laststoreselldiamondlocks = diamondlocks;
												pData->laststoresellid = item_id;
												pData->laststoresellcount = kiek_ruosiasi_parduoti;
												Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(kiek_ruosiasi_parduoti) + "``) `8" + itemDefs.at(item_id).name + "``|left|" + to_string(item_id) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + kiek_gaus + "\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|store_sell_confirm|Cancel|OK|");
												break;
											}
											bool contains_non_int2 = !std::regex_match(strButItemByRarityCount, std::regex("^[0-9]+$"));
											bool contains_non_int4 = !std::regex_match(id, std::regex("^[0-9]+$"));
											if (strButItemByRarityCount == "" || contains_non_int4 || id.size() > 5 || id.size() <= 0 || strButItemByRarityCount.length() > 5 || contains_non_int2 || strButItemByRarityCount.size() > 3 || strButItemByRarityCount.size() <= 0) {
												Player::OnTalkBubble(peer, pData->netID, "You can't buy more than 200 or less than 0!", 0);
												break;
											}
											int item_count = atoi(strButItemByRarityCount.c_str());
											if (item_count < 1 || item_count > 200) {
												Player::OnTalkBubble(peer, pData->netID, "You can't buy more than 200 or less than 0!", 0);
												break;
											}
											int item_id = atoi(id.c_str());
											int itemid = item_id;
											if (itemDefs.at(itemid).properties & Property_Untradable && itemDefs.at(itemid).rarity == 999 || itemDefs.at(itemid).blockType != BlockTypes::CLOTHING && itemDefs.at(itemid).rarity == 999 && itemid != 1436 && itemid != 5142 && itemid != 7188 && itemid != 9498 && itemid != 3176 && itemid != 9528 && itemid != 5154 && itemid != 5140 && itemid != 5138 && itemid != 5136 && itemid != 7382 && itemid != 4762 || itemid == 18 && itemid != 7188 || itemid == 10034 || itemDefs.at(itemid).name.find("null") != string::npos || itemid == 10036 || itemDefs.at(itemid).name.find("Mooncake") != string::npos || itemDefs.at(itemid).name.find("Harvest") != string::npos && itemid != 1830 || itemDefs.at(itemid).name.find("Autumn") != string::npos || itemid == 1056 || itemid == 1804 || itemDefs.at(itemid).blockType == BlockTypes::COMPONENT || itemid == 912 || itemid == 952 || itemid == 1472 || itemid == 1664 || itemid == 6920 || itemid == 6922 || itemid == 1874 || itemid == 1876 || itemid == 1904 || itemid == 1932 || itemid == 1900 || itemid == 1986 || itemid == 1996 || itemid == 2970 || itemid == 3140 || itemid == 3174 || itemid == 6028 || itemid == 6846 || itemid == 8962 || itemid == 2408 || itemid == 4428 || itemid == 5086 || itemid == 9240 || itemid == 9306 || itemid == 9290 || itemid == 7328 || itemid == 9416 || itemid == 10386 || itemid == 9410 || itemid == 1458 || itemid == 9408 || itemid == 9360 || itemid == 6866 || itemid == 6868 || itemid == 6870 || itemid == 6872 || itemid == 6874 || itemid == 6876 || itemid == 6878 || itemid == 2480 || itemid == 8452 || itemid == 5132 || itemid == 7166 || itemid == 5126 || itemid == 5128 || itemid == 5130 || itemid == 5144 || itemid == 5146 || itemid == 5148 || itemid == 5150 || itemid == 5162 || itemid == 5164 || itemid == 5166 || itemid == 5168 || itemid == 5180 || itemid == 5182 || itemid == 5184 || itemid == 5186 || itemid == 7168 || itemid == 7170 || itemid == 7172 || itemid == 7174 || itemid == 8834 || itemid == 7912 || itemid == 9212 || itemid == 5134 || itemid == 5152 || itemid == 5170 || itemid == 5188 || itemid == 980 || itemid == 9448 || itemid == 9310 || itemid == 10034 || itemid == 10036 || itemid == 8470 || itemid == 8286 || itemid == 6026 || itemid == 1784 || itemid == 9356 || itemid == 10022 || itemid == 902 || itemid == 10032 || itemid == 834 || itemid == 6 || itemid == 5640 || itemid == 9492 || itemid == 1782 || itemid == 9288 || itemid == 1780 || itemid == 8306 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 2950 || itemid == 4802 || itemid == 4994 || itemid == 5260 || itemid == 5814 || itemid == 5980 || itemid == 7734 || itemid == 2592 || itemid == 2242 || itemid == 1794 || itemid == 1792 || itemid == 778 || itemid == 9510 || itemid == 8774 || itemid == 2568 || itemid == 9512 || itemid == 9502 || itemid == 9482 || itemid == 2250 || itemid == 2248 || itemid == 2244 || itemid == 2246 || itemid == 2286 || itemid == 9508 || itemid == 9504 || itemid == 9506 || itemid == 274 || itemid == 276 || itemid == 9476 || itemid == 1486 || itemid == 4426 || itemid == 9496 || itemid == 278 || itemid == 9490 || itemid == 2410 || itemid == 9488 || itemid == 9452 || itemid == 9454 || itemid == 9472 || itemid == 9456 || itemid == 732 || itemid == 9458 || itemid == 6336 || itemid == 112 || itemid == 8 || itemid == 3760 || itemid == 18 || itemid == 7372 || itemid == 9438 || itemid == 9462 || itemid == 9440 || itemid == 9442 || itemid == 9444 || itemid == 7960 || itemid == 7628 || itemid == 8552) break;
											if (getItemDef(itemid).blockType == BlockTypes::SEED || itemid == 6312 || itemid == 998 || itemid == 986 || itemid == 992 || itemid == 990 || itemid == 996 || itemid == 988 || itemid == 1004 || itemid == 1006 || itemid == 1002 || itemid == 9504 || itemid == 9506 || itemid == 9508 || itemid == 9510 || itemid == 9512 || itemid == 9514 || itemid == 9518 || itemid == 9520 || itemid == 9502 || itemid == 9496 || itemid == 1790 || itemid == 9492 || itemid == 9494 || itemid == 9488 || itemid == 9222 || itemid == 1360 || itemid == 6260 || itemid == 822 || itemid == 1058 || itemid == 1094 || itemid == 1096 || itemid == 3402 || itemid == 1098 || itemid == 1828 || itemid == 3870 || itemid == 7058 || itemid == 1938 || itemid == 8452 || itemid == 1740 || itemid == 3040 || itemid == 5080 || itemid == 3100 || itemid == 1550 || itemid == 5740 || itemid == 3074 || itemid == 3010 || itemid == 8480 || itemid == 5084 || itemid == 10424 || itemid == 4656 || itemid == 7558 || itemid == 5082 || itemid == 1636 || itemid == 6008 || itemid == 4996 || itemid == 6416 || itemid == 2206 || itemid == 3792 || itemid == 3196 || itemid == 4654 || itemid == 3306 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 2242 || itemid == 2244 || itemid == 2246 || itemid == 2248 || itemid == 2250 || itemid == 4676 || itemid == 4678 || itemid == 4680 || itemid == 4682 || itemid == 4652 || itemid == 4646 || itemid == 4648 || itemid == 4652 || itemid == 4650 || itemid == 10084 || itemid == 10086 || itemid == 9168 || itemid == 5480 || itemid == 4534 || itemid == 9166 || itemid == 9164 || itemid == 9162 || itemid == 9160 || itemid == 9158 || itemid == 9156 || itemid == 9154 || itemid == 9152 || itemid == 3008 || itemid == 3010 || itemid == 3040 || itemid == 5740 || itemid == 6254 || itemid == 6256 || itemid == 6258 || itemid == 6932 || itemid == 10262 || itemid == 10616 || itemid == 10582 || itemid == 10580 || itemid == 10664 || itemid == 10596 || itemid == 10598 || itemid == 10586 || itemid == 10590 || itemid == 10592 || itemid == 10576 || itemid == 10578 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 4994 || itemid == 2978 || itemid == 9268 || itemid == 5766 || itemid == 5768 || itemid == 5744 || itemid == 5756 || itemid == 5758 || itemid == 5760 || itemid == 5762 || itemid == 5754 || itemid == 7688 || itemid == 7690 || itemid == 7694 || itemid == 7686 || itemid == 7692 || itemid == 7698 || itemid == 7696 || itemid == 9286 || itemid == 9272 || itemid == 9290 || itemid == 9280 || itemid == 9282 || itemid == 9292 || itemid == 9284 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 10660 || itemid == 10654 || itemid == 10632 || itemid == 10652 || itemid == 10626 || itemid == 10640 || itemid == 10662 || itemid == 574 || itemid == 592 || itemid == 760 || itemid == 900 || itemid == 766 || itemid == 1012 || itemid == 1272 || itemid == 1320 || itemid == 1540 || itemid == 1648 || itemid == 1740 || itemid == 1950 || itemid == 2900 || itemid == 1022 || itemid == 1030 || itemid == 1024 || itemid == 1032 || itemid == 1026 || itemid == 1028 || itemid == 1036 || itemid == 1034 || itemid == 2908 || itemid == 2974 || itemid == 3494 || itemid == 3060 || itemid == 3056 || itemid == 3052 || itemid == 3066 || itemid == 3048 || itemid == 3068 || itemid == 3166 || itemid == 2032 || itemid == 6780 || itemid == 754 || itemid == 794 || itemid == 796 || itemid == 2876 || itemid == 798 || itemid == 930 || itemid == 2204 || itemid == 2912 || itemid == 772 || itemid == 770 || itemid == 898 || itemid == 1582 || itemid == 1020 || itemid == 4132 || itemid == 3932 || itemid == 3934 || itemid == 4128 || itemid == 10246 || itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7130) break;
											if (itemid == 4762 || itemid == 5136 || itemid == 7382 || itemid == 5154 || itemid == 5140 || itemid == 5138 || itemid == 9498 || itemid == 9530 || itemid == 9526 || itemid == 9524 || itemid == 6398 || itemid == 6426 || itemid == 6340 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 2386 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 9350 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 392 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) break;
											//food
											if (itemid == 4586 || itemid == 962 || itemid == 4564 || itemid == 4570 || itemid == 4598 || itemid == 868 || itemid == 196 || itemid == 4766 || itemid == 4568 || itemid == 4596 || itemid == 3472 || itemid == 7672 || itemid == 7056 || itemid == 4764 || itemid == 6316 || itemid == 676 || itemid == 874 || itemid == 4666 || itemid == 4594 || itemid == 4602 || itemid == 4604) break;
											//robber things
											if (itemid == 9428 || itemid == 8372 || itemid == 1460 || itemid == 1970 || itemid == 3930 || itemid == 944 || itemid == 1538 || itemid == 7588 || itemid == 1696) break;
											// space alien
											if (itemid == 4820 || itemid == 1674 || itemid == 10952 || itemid == 10954 || itemid == 10956 || itemid == 10958 || itemid == 10960) break;
											// ezio
											if (itemid == 11560 || itemid == 11554 || itemid == 11556 || itemid == 11558) break;
											int kiek_turi_kainoti = 0;
											try {
												ifstream infile("price_data.txt");
												for (string line; getline(infile, line);) {
													if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
														auto ex = explode("|", line);
														if (ex.at(0) == to_string(item_id)) {
															kiek_turi_kainoti = atoi(ex.at(1).c_str());
															break;
														}
													}
												}
												infile.close();
											}
											catch (std::exception& e) {
												std::cout << e.what() << std::endl;
											}
											catch (const std::out_of_range& e) {
												std::cout << e.what() << std::endl;
											}
											if (item_id == 7188) kiek_turi_kainoti = 10000;
											kiek_turi_kainoti *= item_count;
											int item_per_wl = 0;
											int kaina_wls = 0;
											if (itemDefs.at(item_id).blockType == BlockTypes::SIGN && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::GATEWAY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DEADLY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DOOR && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PAIN_BLOCK && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PLATFORM && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::BACKGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::FOREGROUND && itemDefs.at(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || itemDefs.at(item_id).blockType == BlockTypes::SFX_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::ANIM_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && itemDefs.at(item_id).rarity != 999) {
												item_per_wl = kiek_turi_kainoti / item_count;
												kaina_wls = kiek_turi_kainoti / item_per_wl;
											}
											else {
												item_per_wl = kiek_turi_kainoti / item_count;
												kaina_wls = kiek_turi_kainoti;
											}
											if (item_id == 7188) {
												item_per_wl = 1 * item_count;
												kaina_wls = kiek_turi_kainoti;
											}
											auto worldlocks = 0;
											auto diamondlocks = 0;
											auto locks = 0;
											for (auto i = 0; i < pData->inventory.items.size(); i++) {
												if (pData->inventory.items.at(i).itemID == 242) {
													worldlocks = pData->inventory.items.at(i).itemCount;
												}
												if (pData->inventory.items.at(i).itemID == 1796) {
													diamondlocks = pData->inventory.items.at(i).itemCount;
												}
											}
											if (diamondlocks > 0) locks = diamondlocks * 100;
											locks += worldlocks;
											if (kaina_wls > locks) {
												Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
												break;
											}
											if (itemDefs.at(item_id).blockType == BlockTypes::SIGN && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::GATEWAY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DEADLY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DOOR && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PAIN_BLOCK && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PLATFORM && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::BACKGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::FOREGROUND && itemDefs.at(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || itemDefs.at(item_id).blockType == BlockTypes::SFX_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::ANIM_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && itemDefs.at(item_id).rarity != 999) {
												if (CheckItemMaxed(peer, item_id, kiek_turi_kainoti) || kiek_turi_kainoti > 200) {
													Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0);
													break;
												}
											}
											else {
												if (CheckItemMaxed(peer, item_id, item_count)) {
													Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0);
													break;
												}
											}
											if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
												if (CheckItemMaxed(peer, item_id, 200)) {
													Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0);
													break;
												}
											}
											pData->laststorebuyprice = kaina_wls;
											pData->laststorebuyid = item_id;
											if (itemDefs.at(item_id).blockType == BlockTypes::SIGN && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::GATEWAY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DEADLY && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::DOOR && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PAIN_BLOCK && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::PLATFORM && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::BACKGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::FOREGROUND && itemDefs.at(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || itemDefs.at(item_id).blockType == BlockTypes::SFX_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::ANIM_FOREGROUND && itemDefs.at(item_id).rarity != 999 || itemDefs.at(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && itemDefs.at(item_id).rarity != 999) {
												pData->laststorebuycount = kiek_turi_kainoti;
											}
											else {
												pData->laststorebuycount = item_count;
											}
											string kiek_per = to_string(pData->laststorebuycount);
											if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
												kiek_per = "150-200";
											}
											auto r_worldlocks = kaina_wls;
											auto r_diamondlocks = 0;
											while (r_worldlocks >= 100) {
												r_diamondlocks++;
												r_worldlocks -= 100;
											}
											string kiek_duos = "";
											if (r_diamondlocks != 0) {
												kiek_duos += "\nadd_label_with_icon|small|(`w" + to_string(r_diamondlocks) + "``) `2Diamond Locks``|left|1796|";
											}
											if (r_worldlocks != 0) {
												kiek_duos += "\nadd_label_with_icon|small|(`w" + to_string(r_worldlocks) + "``) `2World Locks``|left|242|";
											}
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + kiek_duos + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + kiek_per + "``) `2" + itemDefs.at(pData->laststorebuyid).name + "``|left|" + to_string(item_id) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|store_buy_confirm|Cancel|OK|");
										}
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "findid2") {
										FindDialog2 = true;
									}
									if (FindDialog2 && btn.substr(0, 4) == "tool") {
										int id = atoi(btn.substr(4, btn.length() - 4).c_str());
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										if (btn.substr(4, btn.length() - 4).size() > 5 || pData->currentWorld == "EXIT" || id > CoreDataItems || id <= 0 || btn.substr(4, btn.length() - 4).size() <= 0) continue;
										int kaina = 0;
										int kaina_vakar = 0;
										int kaina_uzvakar = 0;
										int kaina_uzvakar_uzvakar = 0;

										int p_1 = 0;
										int p_2 = 0;
										int p_3 = 0;
										int p_6 = 0;
										try {
											ifstream infile("price_data.txt");
											for (string line; getline(infile, line);) {
												if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
													auto ex = explode("|", line);
													if (ex.at(0) == to_string(id)) {
														kaina = atoi(ex.at(1).c_str());
														p_1 = atoi(ex.at(2).c_str());
														break;
													}
												}
											}
											infile.close();
											ifstream infiles("price_data1.txt");
											for (string line; getline(infiles, line);) {
												if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
													auto ex = explode("|", line);
													if (ex.at(0) == to_string(id)) {
														kaina_vakar = atoi(ex.at(1).c_str());
														p_2 = atoi(ex.at(2).c_str());
														break;
													}
												}
											}
											infiles.close();
											ifstream infiless("price_data2.txt");
											for (string line; getline(infiless, line);) {
												if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
													auto ex = explode("|", line);
													if (ex.at(0) == to_string(id)) {
														kaina_uzvakar = atoi(ex.at(1).c_str());
														p_3 = atoi(ex.at(2).c_str());
														break;
													}
												}
											}
											infiless.close();
											ifstream infilssse("price_data3.txt");
											for (string line; getline(infilssse, line);) {
												if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
													auto ex = explode("|", line);
													if (ex.at(0) == to_string(id)) {
														kaina_uzvakar_uzvakar = atoi(ex.at(1).c_str());
														p_6 = atoi(ex.at(2).c_str());
														break;
													}
												}
											}
											infilssse.close();
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
										if (kaina == 0) continue;
										float price_difference = (kaina - kaina_vakar) / (double)kaina_vakar * 100;
										std::stringstream stream;
										stream << std::fixed << std::setprecision(2) << price_difference;
										std::string price_difference_string = stream.str();
										if (itemDefs.at(id).blockType == BlockTypes::SIGN && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::GATEWAY && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::DEADLY && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::DOOR && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::PAIN_BLOCK && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::PLATFORM && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::BACKGROUND && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::FOREGROUND && itemDefs.at(id).rarity != 999 && id != 9498 && id != 5154 && id != 5140 && id != 5138 && id != 5136 && id != 7382 && id != 4762 || itemDefs.at(id).blockType == BlockTypes::SFX_FOREGROUND && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::ANIM_FOREGROUND && itemDefs.at(id).rarity != 999 || itemDefs.at(id).blockType == BlockTypes::TOGGLE_FOREGROUND && itemDefs.at(id).rarity != 999) {
											string history_day1 = "Yesterday Price: " + to_string(kaina_vakar) + "/1 World lock (" + to_string(p_2) + " purchased)";
											string history_day2 = "2 Days ago Price: " + to_string(kaina_uzvakar) + "/1 World lock (" + to_string(p_3) + " purchased)";
											string history_day3 = "3 Days ago Price: " + to_string(kaina_uzvakar_uzvakar) + "/1 World lock (" + to_string(p_6) + " purchased)";
											if (kaina_vakar == 0) {
												history_day1 = "`oYesterday Price: No data";
											}
											if (kaina_uzvakar == 0) {
												history_day2 = "`o2 Days ago Price: No data";
											}
											if (kaina_uzvakar_uzvakar == 0) {
												history_day3 = "`o3 Days ago Price: No data";
											}
											string price_difference_log = "";
											if ((int)price_difference < -1000) price_difference = 0;
											if ((int)price_difference < 0) {
												price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `4" + price_difference_string + "%|left|10074|";
											}
											else if ((int)price_difference == 0) {
												price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `90%|left|10072|";
											}
											else {
												price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `2" + price_difference_string + "%|left|10072|";
											}
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`oViewing `$" + itemDefs.at(id).name + " `oMarketing history``|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|Purchase items here, each 24 hours the prices are being re-rolled into higher or lower, price history can be seen below|left|\nadd_spacer|small|\nadd_textbox|`$Current Price: " + to_string(kaina) + "/1 World lock (" + to_string(p_1) + " purchased)|left|\nadd_textbox|" + history_day1 + "|left|\nadd_textbox|" + history_day2 + "|left|\nadd_textbox|" + history_day3 + "|left|\nadd_spacer|small|" + price_difference_log + "\nadd_spacer|small|\nadd_textbox|`oHow much " + itemDefs.at(id).name + " you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nadd_label_with_icon|small|`4Enter value in World locks 1 means " + to_string(kaina) + " `4blocks of " + itemDefs.at(id).name + "`4!|left|3764|\nadd_spacer|small|\nend_dialog|purchase_item|Cancel|Purchase|");
										}
										else {
											string kiek_per = "1";
											string per_ka = "World locks";
											string warning = "";
											if (id == 9498 || id == 5154 || id == 5140 || id == 5138 || id == 5136 || id == 7382 || id == 4762) {
												kiek_per = "150-200";
												warning = "\nadd_label_with_icon|small|`4Enter value in amount of purchase 1 means " + kiek_per + " `4blocks of " + itemDefs.at(id).name + "`4!|left|3764|";
											}
											if (id == 7188) {
												kiek_per = "1";
												per_ka = "Diamond locks";
												kaina = 100;
												warning = "\nadd_label_with_icon|small|`4This item has a fixed price, it isnt changing`4!|left|3764|";
											}
											string history_day1 = "Yesterday Price: 1/" + to_string(kaina_vakar) + " " + per_ka + " (" + to_string(p_2) + " purchased)";
											string history_day2 = "2 Days ago Price: 1/" + to_string(kaina_uzvakar) + " " + per_ka + " (" + to_string(p_3) + " purchased)";
											string history_day3 = "3 Days ago Price: 1/" + to_string(kaina_uzvakar_uzvakar) + " " + per_ka + " (" + to_string(p_6) + " purchased)";
											if (kaina_vakar == 0) {
												history_day1 = "`oYesterday Price: No data";
											}
											if (kaina_uzvakar == 0) {
												history_day2 = "`o2 Days ago Price: No data";
											}
											if (kaina_uzvakar_uzvakar == 0) {
												history_day3 = "`o3 Days ago Price: No data";
											}
											string price_difference_log = "";
											if ((int)price_difference < -1000) price_difference = 0;
											if ((int)price_difference < 0) {
												price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `4" + price_difference_string + "%|left|10074|";
											}
											else if ((int)price_difference == 0) {
												price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `90%|left|10072|";
											}
											else {
												price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `2" + price_difference_string + "%|left|10072|";
											}
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`oViewing `$" + itemDefs.at(id).name + " `oMarketing history``|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|Purchase items here, each 24 hours the prices are being re-rolled into higher or lower, price history can be seen below|left|\nadd_spacer|small|\nadd_textbox|`$Current Price: " + kiek_per + "/" + to_string(kaina) + " " + per_ka + " (" + to_string(p_1) + " purchased)|left|\nadd_textbox|" + history_day1 + "|left|\nadd_textbox|" + history_day2 + "|left|\nadd_textbox|" + history_day3 + "|left|\nadd_spacer|small|" + price_difference_log + "\nadd_spacer|small|\nadd_textbox|`oHow much " + itemDefs.at(id).name + " you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||" + warning + "\nadd_spacer|small|\nend_dialog|purchase_item|Cancel|Purchase|");
										}
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "statsblock")
										isGrowScanDialog = true;
									if (isGrowScanDialog) {
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										if (infoDat.at(0) == "isStatsWorldBlockUsableByPublic") {
											int x = pData->lastPunchX;
											int y = pData->lastPunchY;
											if (x < 0 || y < 0) continue;
											if (infoDat.at(1) == "1") {
												world->items.at(x + (y * world->width)).opened = true;
											}
											else if (infoDat.at(1) == "0") {
												world->items.at(x + (y * world->width)).opened = false;
											}
											SaveBlockState(world, peer, x, y);
										} if (infoDat.at(0) == "isStatsFloatingItemsUsableByPublic") {
											int x = pData->lastPunchX;
											int y = pData->lastPunchY;
											if (x < 0 || y < 0) continue;
											if (infoDat.at(1) == "1") {
												world->items.at(x + (y * world->width)).rm = true;
											}
											else if (infoDat.at(1) == "0") {
												world->items.at(x + (y * world->width)).rm = false;
											}
											SaveBlockState(world, peer, x, y);
										} if (btn.substr(0, 9) == "findTile_") {
											sendArrow(peer, atoi(btn.substr(9, btn.length() - 9).c_str()), false);
										} if (btn.substr(0, 11) == "findObject_") {
											sendArrow(peer, atoi(btn.substr(11, btn.length() - 11).c_str()), true);
										} if (infoDat.at(1) == "backToStatsBlock") {
											try {
												int x = ((PlayerInfo*)(peer->data))->lastPunchX;
												int y = ((PlayerInfo*)(peer->data))->lastPunchY;
												if (x < 0 || y < 0) continue;
												string EditableDialog = "";
												string button_dialog = "";
												string allowFloat = "0";
												string allowDrop = "0";
												string endDialog = "";
												if (world->items.at(x + (y * world->width)).rm) allowFloat = "1";
												if (world->items.at(x + (y * world->width)).opened) allowDrop = "1";
												if (isWorldOwner(peer, world)) {
													endDialog = "\nend_dialog|statsblock|Cancel|Apply|";
													button_dialog = "\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|\nadd_button|floatingItems|Floating Items|noflags|0|0|";
													EditableDialog = "\nadd_textbox|`wYou can set the stats to be usable by the public.|left\nadd_checkbox|isStatsWorldBlockUsableByPublic|World blocks is usable by public|" + allowDrop + "\nadd_checkbox|isStatsFloatingItemsUsableByPublic|Floating items is usable by public|" + allowFloat + "\nadd_spacer|small|";
												}
												else if (world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).opened) {
													endDialog = "\nend_dialog|statsblock|Cancel||";
													button_dialog = "\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|\nadd_button|floatingItems|Floating Items|noflags|0|0|";
												}
												else if (world->items.at(x + (y * world->width)).rm) {
													endDialog = "\nend_dialog|statsblock|Cancel||";
													button_dialog = "\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|floatingItems|Floating Items|noflags|0|0|";
												}
												else if (world->items.at(x + (y * world->width)).opened) {
													endDialog = "\nend_dialog|statsblock|Cancel||";
													button_dialog = "\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|";
												}
												else {
													endDialog = "\nend_dialog|statsblock|Cancel||";
													button_dialog = "\nadd_textbox|`wThis growscan options are set to private!|left";
												}
												Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|\nadd_textbox|`wThis amazing block can show the stats for the whole world!|left\nadd_spacer|small|" + button_dialog + "\nadd_spacer|small|" + EditableDialog + "" + endDialog + "");
											}
											catch (std::exception& e) {
												std::cout << e.what() << std::endl;
											}
											catch (const std::out_of_range& e) {
												std::cout << e.what() << std::endl;
											}
										} if (infoDat.at(1) == "worldBlocks" || infoDat.at(1) == "backToWorldBlocks") {
											int total_blocks = 0;
											int total_backgrounds = 0;
											int total_untradeable = 0;
											int total_rare = 0;
											int total_rarity = 0;
											int total_fire = 0;
											int total_water = 0;
											int total_earth = 0;
											int total_air = 0;
											for (int i = 0; i < world->width * world->height; i++) {
												if (world->items.at(i).foreground != 0) total_blocks++;
												if (world->items.at(i).background != 0 && world->items.at(i).background != 6864) total_backgrounds++;
												if (world->items.at(i).foreground != 0 && itemDefs.at(world->items.at(i).foreground).properties & Property_Untradable || world->items.at(i).background != 0 && world->items.at(i).background != 6864 && itemDefs.at(world->items.at(i).background).properties & Property_Untradable) total_untradeable++;
												if (world->items.at(i).foreground != 0 && itemDefs.at(world->items.at(i).foreground).rarity == 999 || world->items.at(i).background != 0 && world->items.at(i).background != 6864 && itemDefs.at(world->items.at(i).background).rarity == 999) total_rare++;
												if (world->items.at(i).foreground != 0 && itemDefs.at(world->items.at(i).foreground).rarity != 999) total_rarity += itemDefs.at(world->items.at(i).foreground).rarity;
												if (world->items.at(i).foreground != 0 && itemDefs.at(world->items.at(i).foreground).blockType == BlockTypes::PAIN_BLOCK) total_fire++;
												else if (world->items.at(i).foreground != 0 && world->items.at(i).foreground == 5034 || world->items.at(i).foreground == 5048 || world->items.at(i).foreground == 7520 || world->items.at(i).foreground == 7522 || world->items.at(i).foreground == 7772 || world->items.at(i).foreground == 7774 || world->items.at(i).foreground == 8240 || world->items.at(i).foreground == 3506 || world->items.at(i).foreground == 3584) total_water++;
												else if (world->items.at(i).foreground != 0 && itemDefs.at(world->items.at(i).foreground).blockType == BlockTypes::FOREGROUND && world->items.at(i).foreground != 5034 && world->items.at(i).foreground != 5048 && world->items.at(i).foreground != 7520 && world->items.at(i).foreground != 7522 && world->items.at(i).foreground != 7772 && world->items.at(i).foreground != 7774 && world->items.at(i).foreground != 2794 || world->items.at(i).foreground != 2796 || world->items.at(i).foreground != 2810 && world->items.at(i).foreground != 8240 && world->items.at(i).foreground != 3506 && world->items.at(i).foreground != 3584) total_earth++;
												else if (world->items.at(i).foreground != 0 && world->items.at(i).foreground == 2794 || world->items.at(i).foreground == 2796 || world->items.at(i).foreground == 2810) total_air++;
											}
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_label|small|`wThis world contains|left\nadd_textbox|`wBlocks: " + to_string(total_blocks) + "``|\nadd_textbox|`wBackgrounds: " + to_string(total_backgrounds) + "``|\nadd_textbox|`wUntradeable blocks: " + to_string(total_untradeable) + "``|left|\nadd_textbox|`wSuper rare items: " + to_string(total_rare) + "|left|\nadd_textbox|`wTotal block rarity: " + to_string(total_rarity) + "``|left|\nadd_label_with_icon|small|`wFire: " + to_string(total_fire) + "|left|6020|\nadd_label_with_icon|small|`wWater: " + to_string(total_water) + "|left|6024|\nadd_label_with_icon|small|`wEarth: " + to_string(total_earth) + "|left|6018|\nadd_label_with_icon|small|`wAir: " + to_string(total_air) + "|left|6022|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|searchInWorldBlocks|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|blockInWorldBlocks|Search Blocks|noflags|0|0|\nadd_button|backgroundInWorldBlocks|Search Backgrounds|noflags|0|0|\nadd_button|untradableInWorldBlocks|Search Untradeable|noflags|0|0|\nadd_spacer|small|\nadd_button|backToStatsBlock|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										} if (infoDat.at(1) == "untradableInWorldBlocks") {
											string additems = "";
											vector<string> scanned_items;
											for (int i = 0; i < world->width * world->height; i++) {
												if (world->items.at(i).foreground != 0) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).foreground)) != scanned_items.end()) continue;
													}
													if (itemDefs.at(world->items.at(i).foreground).properties & Property_Untradable) {
														scanned_items.push_back(to_string(world->items.at(i).foreground));
														int count = 0;
														for (int iss = 0; iss < world->width * world->height; iss++) {
															if (world->items.at(iss).foreground == world->items.at(i).foreground) count++;
														}
														additems += "" + to_string(world->items.at(i).foreground) + "," + to_string(count) + ",";
													}
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
										} if (infoDat.at(1) == "backgroundInWorldBlocks") {
											string additems = "";
											vector<string> scanned_items;
											for (int i = 0; i < world->width * world->height; i++) {
												if (world->items.at(i).background != 0 && world->items.at(i).background != 6864) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).background)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(world->items.at(i).background));
													int count = 0;
													for (int iss = 0; iss < world->width * world->height; iss++) {
														if (world->items.at(iss).background == world->items.at(i).background) count++;
													}
													additems += "" + to_string(world->items.at(i).background) + "," + to_string(count) + ",";
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
										} if (infoDat.at(1) == "blockInWorldBlocks") {
											string additems = "";
											vector<string> scanned_items;
											for (int i = 0; i < world->width * world->height; i++) {
												if (world->items.at(i).foreground != 0) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).foreground)) != scanned_items.end()) continue;
													}
													if (itemDefs.at(world->items.at(i).foreground).blockType == BlockTypes::FOREGROUND || itemDefs.at(world->items.at(i).foreground).blockType == BlockTypes::BACKGROUND || itemDefs.at(world->items.at(i).foreground).blockType == BlockTypes::SFX_FOREGROUND || itemDefs.at(world->items.at(i).foreground).blockType == BlockTypes::BEDROCK || itemDefs.at(world->items.at(i).foreground).blockType == BlockTypes::PAIN_BLOCK) {
														scanned_items.push_back(to_string(world->items.at(i).foreground));
														int count = 0;
														for (int iss = 0; iss < world->width * world->height; iss++) {
															if (world->items.at(iss).foreground == world->items.at(i).foreground) count++;
														}
														additems += "" + to_string(world->items.at(i).foreground) + "," + to_string(count) + ",";
													}
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
										} if (infoDat.at(1) == "searchInWorldBlocks") {
											string additems = "";
											vector<string> scanned_items;
											for (int i = 0; i < world->width * world->height; i++) {
												if (world->items.at(i).foreground != 0) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).foreground)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(world->items.at(i).foreground));
													int count = 0;
													for (int iss = 0; iss < world->width * world->height; iss++) {
														if (world->items.at(iss).foreground == world->items.at(i).foreground) count++;
													}
													additems += "" + to_string(world->items.at(i).foreground) + "," + to_string(count) + ",";
												}
												if (world->items.at(i).background != 0 && world->items.at(i).background != 6864) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).background)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(world->items.at(i).background));
													int count = 0;
													for (int iss = 0; iss < world->width * world->height; iss++) {
														if (world->items.at(iss).background == world->items.at(i).background) count++;
													}
													additems += "" + to_string(world->items.at(i).background) + "," + to_string(count) + ",";
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
										} if (infoDat.at(1) == "floatingItems" || infoDat.at(1) == "backToFloatingItems") {
											int totalitems_withcount = 0;
											int totalitems_rarity = 0;
											int totalitems_super = 0;
											int total_gems = 0;
											vector<string> scanned_items;
											for (int i = 0; i < world->droppedItems.size(); i++) {
												int id = world->droppedItems.at(i).id;
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(id));
												int count = 0;
												for (int is = 0; is < world->droppedItems.size(); is++) {
													if (world->droppedItems.at(is).id == id) {
														if (world->droppedItems.at(is).id == 112) total_gems += world->droppedItems.at(is).count;
														count += world->droppedItems.at(is).count;
														totalitems_withcount += world->droppedItems.at(is).count;
														if (itemDefs.at(world->droppedItems.at(is).id).rarity != 999) totalitems_rarity += itemDefs.at(world->droppedItems.at(is).id).rarity * world->droppedItems.at(is).count;
														if (itemDefs.at(world->droppedItems.at(is).id).rarity == 999 && world->droppedItems.at(is).id != 112) {
															totalitems_super += world->droppedItems.at(is).count;
														}
													}
												}
											}
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|`wTotal number in world: " + to_string(totalitems_withcount) + "|left\nadd_textbox|`wTotal floating item rarity: " + to_string(totalitems_rarity) + "|left|\nadd_textbox|`wTotal super rare items: " + to_string(totalitems_super) + "|left|\nadd_textbox|`wTotal gems: " + to_string(total_gems) + "|left|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|searchInFloatingItems|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|filterByClothingInFloatingItems|Search Clothing|noflags|0|0|\nadd_button|filterByConsumablesInFloatingItems|Search Consumables|noflags|0|0|\nadd_button|filterByBlocksInFloatingItems|Search Blocks and Backgrounds|noflags|0|0|\nadd_button|filterBySeedsInFloatingItems|Search Seeds|noflags|0|0|\nadd_button|filterByLocksInFloatingItems|Search Locks|noflags|0|0|\nadd_button|filterByOthersInFloatingItems|Search Others|noflags|0|0|\nadd_spacer|small|\nadd_button|backToStatsBlock|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										} if (infoDat.at(1) == "filterByOthersInFloatingItems") {
											string additems = "";
											int totalfloatinggems = 0;
											vector<string> scanned_items;
											for (int i = 0; i < world->droppedItems.size(); i++) {
												int id = world->droppedItems.at(i).id;
												if (itemDefs.at(id).blockType != BlockTypes::CONSUMABLE && itemDefs.at(id).blockType != BlockTypes::CLOTHING && itemDefs.at(id).blockType != BlockTypes::LOCK && itemDefs.at(id).blockType != BlockTypes::SEED && itemDefs.at(id).blockType != BlockTypes::FOREGROUND && itemDefs.at(id).blockType != BlockTypes::BACKGROUND && itemDefs.at(id).blockType != BlockTypes::SFX_FOREGROUND && itemDefs.at(id).blockType != BlockTypes::BEDROCK && itemDefs.at(id).blockType != BlockTypes::PAIN_BLOCK) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(id));
													int count = 0;
													for (int is = 0; is < world->droppedItems.size(); is++) {
														if (world->droppedItems.at(is).id == id) {
															count += world->droppedItems.at(is).count;
														}
													}
													additems += "" + to_string(id) + "," + to_string(count) + ",";
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										} if (infoDat.at(1) == "filterByLocksInFloatingItems") {
											string additems = "";
											int totalfloatinggems = 0;
											vector<string> scanned_items;
											for (int i = 0; i < world->droppedItems.size(); i++) {
												int id = world->droppedItems.at(i).id;
												if (itemDefs.at(id).blockType == BlockTypes::LOCK) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(id));
													int count = 0;
													for (int is = 0; is < world->droppedItems.size(); is++) {
														if (world->droppedItems.at(is).id == id) {
															count += world->droppedItems.at(is).count;
														}
													}
													additems += "" + to_string(id) + "," + to_string(count) + ",";
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										} if (infoDat.at(1) == "filterBySeedsInFloatingItems") {
											string additems = "";
											int totalfloatinggems = 0;
											vector<string> scanned_items;
											for (int i = 0; i < world->droppedItems.size(); i++) {
												int id = world->droppedItems.at(i).id;
												if (itemDefs.at(id).blockType == BlockTypes::SEED) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(id));
													int count = 0;
													for (int is = 0; is < world->droppedItems.size(); is++) {
														if (world->droppedItems.at(is).id == id) {
															count += world->droppedItems.at(is).count;
														}
													}
													additems += "" + to_string(id) + "," + to_string(count) + ",";
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										} if (infoDat.at(1) == "filterByBlocksInFloatingItems") {
											string additems = "";
											int totalfloatinggems = 0;
											vector<string> scanned_items;
											for (int i = 0; i < world->droppedItems.size(); i++) {
												int id = world->droppedItems.at(i).id;
												if (itemDefs.at(id).blockType == BlockTypes::FOREGROUND || itemDefs.at(id).blockType == BlockTypes::BACKGROUND || itemDefs.at(id).blockType == BlockTypes::SFX_FOREGROUND || itemDefs.at(id).blockType == BlockTypes::BEDROCK || itemDefs.at(id).blockType == BlockTypes::PAIN_BLOCK) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(id));
													int count = 0;
													for (int is = 0; is < world->droppedItems.size(); is++) {
														if (world->droppedItems.at(is).id == id) {
															count += world->droppedItems.at(is).count;
														}
													}
													additems += "" + to_string(id) + "," + to_string(count) + ",";
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										} if (infoDat.at(1) == "filterByClothingInFloatingItems") {
											string additems = "";
											int totalfloatinggems = 0;
											vector<string> scanned_items;
											for (int i = 0; i < world->droppedItems.size(); i++) {
												int id = world->droppedItems.at(i).id;
												if (itemDefs.at(id).blockType == BlockTypes::CLOTHING) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(id));
													int count = 0;
													for (int is = 0; is < world->droppedItems.size(); is++) {
														if (world->droppedItems.at(is).id == id) {
															count += world->droppedItems.at(is).count;
														}
													}
													additems += "" + to_string(id) + "," + to_string(count) + ",";
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										} if (infoDat.at(1) == "filterByConsumablesInFloatingItems") {
											string additems = "";
											int totalfloatinggems = 0;
											vector<string> scanned_items;
											for (int i = 0; i < world->droppedItems.size(); i++) {
												int id = world->droppedItems.at(i).id;
												if (itemDefs.at(id).blockType == BlockTypes::CONSUMABLE) {
													if (scanned_items.size() != 0) {
														if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
													}
													scanned_items.push_back(to_string(id));
													int count = 0;
													for (int is = 0; is < world->droppedItems.size(); is++) {
														if (world->droppedItems.at(is).id == id) {
															count += world->droppedItems.at(is).count;
														}
													}
													additems += "" + to_string(id) + "," + to_string(count) + ",";
												}
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										} if (infoDat.at(1) == "searchInFloatingItems") {
											string additems = "";
											int totalfloatinggems = 0;
											vector<string> scanned_items;
											for (int i = 0; i < world->droppedItems.size(); i++) {
												int id = world->droppedItems.at(i).id;
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(id));
												int count = 0;
												for (int is = 0; is < world->droppedItems.size(); is++) {
													if (world->droppedItems.at(is).id == id) {
														count += world->droppedItems.at(is).count;
													}
												}
												additems += "" + to_string(id) + "," + to_string(count) + ",";
											}
											if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
											break;
										}
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "usetelephone")
										isTeleDialog = true;
									if (isTeleDialog)
									{
										if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
										if (infoDat[0] == "telephonenumber")
										{
											Player::OnTextOverlay(peer, "Salesman under development!");
											break;
											if (infoDat.at(1).size() > 5 || infoDat.at(1).size() <= 0)
											{
												continue;
											}
											if (infoDat.at(1) != "12345" && infoDat.at(1) != "53785")
											{
												Player::OnTextOverlay(peer, "This phone number does not exist!");
											}
											else if (infoDat.at(1) == "12345")
											{
												auto dailyitem1 = 0;
												for (auto i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 170 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
														dailyitem1 = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
													}
												}
												auto dailyitem2 = 0;
												for (auto i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 76 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
														dailyitem2 = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
													}
												}
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wTelephone|left|3898|\nadd_spacer|small|\nadd_button|dailyquest|`oDaily Quest|\nadd_button|changegt|`oBuy Growtoken|\nadd_spacer|small|\n\nadd_quick_exit|\nnend_dialog|gazette|`wNever Mind!||");
											}
											else
											{
												Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|bglphone|Blue Gem Lock|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
											}
										}
									}
									if (infoDat.at(0) == "billitem") {
										billpicker = true;
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "vip_entrance") {
										isVipDialog = true;
									}
									if (infoDat.at(0) == "VipAcc") {
										vipid = infoDat.at(1);
										VipAccess = true;
									}
									if (VipAccess) {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
											int x = ((PlayerInfo*)(peer->data))->lastPunchX;
											int y = ((PlayerInfo*)(peer->data))->lastPunchY;
											if (x < 0 || y < 0) continue;
											string accessnames = "";
											for (std::vector<string>::const_iterator i = world->viplist.begin(); i != world->viplist.end(); ++i) {
												accessnames = *i;
											}
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (((PlayerInfo*)(currentPeer->data))->netID == stoi(vipid)) {
													if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(currentPeer->data))->rawName) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou can't access yourself", 1);
													}
													else {
														WorldInfo info;
														if (find(world->viplist.begin(), world->viplist.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != world->viplist.end()) {
														}
														else {
															string text = "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0\n";
															BYTE* data = new BYTE[5 + text.length()];
															BYTE zero = 0;
															int type = 3;
															memcpy(data, &type, 4);
															memcpy(data + 4, text.c_str(), text.length());
															memcpy(data + 4 + text.length(), &zero, 1);
															ENetPacket* packet2 = enet_packet_create(data,
																5 + text.length(),
																ENET_PACKET_FLAG_RELIABLE);
															enet_peer_send(peer, 0, packet2);
															delete[] data;
															Player::OnConsoleMessage(currentPeer, "`o" + ((PlayerInfo*)(peer->data))->displayName + " `oput you to VIP List.");
															world->viplist.push_back(((PlayerInfo*)(currentPeer->data))->rawName);
															Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPut " + ((PlayerInfo*)(currentPeer->data))->displayName + " `won the VIP List,", 0);
															sendTileData(currentPeer, x, y, 0x00, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, EntranceTiles(0x20, ((PlayerInfo*)(currentPeer->data))->userID));
														}
													}
												}
											}
										}
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "RemoveMyVipAccess") {
										RemoveVipAccess = true;
									}
									if (RemoveVipAccess) {
										int x = ((PlayerInfo*)(peer->data))->lastPunchX;
										int y = ((PlayerInfo*)(peer->data))->lastPunchY;
										if (x < 0 || y < 0) continue;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->rawName) {
												WorldInfo info;
												world->viplist.erase(std::remove(world->viplist.begin(), world->viplist.end(), ((PlayerInfo*)(currentPeer->data))->rawName), world->viplist.end());
												SendConsoleMsgAll(peer, "`o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " removed their access from a Vip List.");
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI've removed my access from Vip List", 0);
												sendTileData(currentPeer, x, y, 0x00, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, EntranceTilesLocked(0x00, ((PlayerInfo*)(currentPeer->data))->userID));
												break;
											}
										}
									}
									if (infoDat[0] == "VipAccess" && infoDat[1] == "0") {
										int x = ((PlayerInfo*)(peer->data))->lastPunchX;
										int y = ((PlayerInfo*)(peer->data))->lastPunchY;
										if (x < 0 || y < 0) continue;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->rawName) {
												WorldInfo info;
												string offname = "";
												for (std::vector<string>::const_iterator i = world->viplist.begin(); i != world->viplist.end(); ++i) {
													offname = *i;
												}
												world->viplist.erase(std::remove(world->viplist.begin(), world->viplist.end(), offname), world->viplist.end());
												SendConsoleMsgAll(peer, "`o" + offname + " `owas removed from a VIP List.");
												sendTileData(currentPeer, x, y, 0x00, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, EntranceTilesLocked(0x00, ((PlayerInfo*)(currentPeer->data))->userID));
												break;
											}
										}
									}
									if (isVipDialog) {
										if (infoDat.at(0) == "vip_public") {
											vipPub = infoDat.at(1);
											int x = ((PlayerInfo*)(peer->data))->lastPunchX;
											int y = ((PlayerInfo*)(peer->data))->lastPunchY;
											if (x < 0 || y < 0) continue;
											int fg = world->items[x + (y * world->width)].foreground;
											int bg = world->items[x + (y * world->width)].background;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) {
													if (world->items[x + (y * world->width)].foreground == 3798 && has_only_digits(vipPub)) {
														int checkbox_public = atoi(vipPub.c_str());
														if (checkbox_public == 1) {
															world->items[x + (y * world->width)].rm = true;
															sendTileData(currentPeer, x, y, 0x00, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, EntranceTiles(0x20, ((PlayerInfo*)(currentPeer->data))->userID));
															SaveBlockState(world, peer, x, y);
														}
														else {
															if (world->owner == ((PlayerInfo*)(currentPeer->data))->rawName || (find(world->viplist.begin(), world->viplist.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != world->viplist.end())) {
															}
															else {
																world->items[x + (y * world->width)].rm = false;
																sendTileData(currentPeer, x, y, 0x00, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, EntranceTilesLocked(0x00, ((PlayerInfo*)(currentPeer->data))->userID));
																SaveBlockState(world, peer, x, y);
															}
														}
													}
												}
											}
										}
									}
									if (billpicker) if (infoDat.at(0) == "billitem")
									{
										billitem = atoi(infoDat.at(1).c_str());
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "givedonationboxitemConfirm")
										isgivedonationboxitemConfirm = true;
									if (isgivedonationboxitemConfirm)
									{
										auto pData = (PlayerInfo*)peer->data;
										if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
										if (infoDat.at(0).substr(0, 25) == "givedonationboxitemCount_")
										{
											givedonationboxitemCount = infoDat.at(1);
											string coord_and_id = infoDat.at(0).erase(0, 25);
											string::size_type pos = coord_and_id.find('_');
											if (pos != std::string::npos)
											{
												givedonationboxitemCoord = coord_and_id.substr(0, pos);
												coord_and_id.erase(0, pos + 1);
												givedonationboxitemItemID = coord_and_id;
											}
											else
											{
												break;
											}
											auto isdbox = std::experimental::filesystem::exists("donationboxes/_" + pData->currentWorld + "/X" + givedonationboxitemCoord + ".json");
											if (!isdbox)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting donation box info.", 0);
												break;
											}
											bool contains_non_int3 = !std::regex_match(givedonationboxitemItemID, std::regex("^[0-9]+$"));
											if (contains_non_int3 == true)
											{
												break;
											}
											bool contains_non_int4 = !std::regex_match(givedonationboxitemCount, std::regex("^[0-9]+$"));
											if (contains_non_int4 == true)
											{
												Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0);
												break;
											}
											givedonationboxitemCountInt = atoi(givedonationboxitemCount.c_str());
											givedonationboxitemItemIDInt = atoi(givedonationboxitemItemID.c_str());
											if (givedonationboxitemItemIDInt < 1 || givedonationboxitemItemIDInt > CoreDataItems)
											{
												break;
											}

											if (itemDefs.at(givedonationboxitemItemIDInt).rarity < 2)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4You can donate items higher than 2 rarity!", 0);
												break;
											}
											if (givedonationboxitemCountInt < 1 || givedonationboxitemCountInt > 200)
											{
												Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0);
												break;
											}
										}
										if (infoDat.at(0) == "givedonationboxitemNote")
										{
											auto pData = (PlayerInfo*)peer->data;
											givedonationboxitemNote = infoDat.at(1);
											if (givedonationboxitemNote.size() < 1 || givedonationboxitemNote.size() > 50) {
												Player::OnTextOverlay(peer, "`4The note should be at least 1 letter.");
												break;
											}
											ifstream ifff("donationboxes/_" + pData->currentWorld + "/X" + givedonationboxitemCoord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											if (j["donated"] > 19) {
												Player::OnTalkBubble(peer, pData->netID, "`4Donation box is full!", 0);
												break;
											}
											if (HasItemsInInv(peer, givedonationboxitemItemIDInt, givedonationboxitemCountInt) == -1) continue;
											RemoveItemFromInv(peer, givedonationboxitemItemIDInt, givedonationboxitemCountInt, true);
											j["donated"] = j["donated"].get<double>() + 1;
											for (int i = 0; i < 20; i++) {
												if (j["donatedItems"].at(i)["itemid"] == 0) {
													j["donatedItems"].at(i)["itemid"] = givedonationboxitemItemIDInt;
													j["donatedItems"].at(i)["itemcount"] = givedonationboxitemCountInt;
													j["donatedItems"].at(i)["sentBy"] = pData->displayName;
													j["donatedItems"].at(i)["note"] = givedonationboxitemNote;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnTalkBubble(peer, pData->netID, "`w[`5[`w" + pData->displayName + " `wplaces `5" + to_string(givedonationboxitemCountInt) + " `2" + itemDefs.at(givedonationboxitemItemIDInt).name + " `winto the " + itemDefs.at(world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground).name + "`5]`w]", 0);
															Player::OnConsoleMessage(currentPeer, "`w[`5[`w" + pData->displayName + " `wplaces `5" + to_string(givedonationboxitemCountInt) + " `2" + itemDefs.at(givedonationboxitemItemIDInt).name + " `winto the " + itemDefs.at(world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground).name + "`5]`w]");
															if (pData->lastPunchX >= 0 && pData->lastPunchY >= 0)
															{
																SendDonateData2(currentPeer, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).background, pData->lastPunchX, pData->lastPunchY, 65);
															}
														}
													}
													break;
												}
											}
											ofstream of("donationboxes/_" + pData->currentWorld + "/X" + givedonationboxitemCoord + ".json");
											of << j << std::endl;
											of.close();
										}
									}
									if (isaddItemToDonationBox)
									{
										if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
										if (infoDat.at(0).substr(0, 16) == "addDonationItem_") addItemToDonationBox = infoDat.at(1);
										if (addItemToDonationBox.size() > 5) break;
										string coord = infoDat.at(0).substr(16, infoDat.at(0).length() - 1).c_str();
										int itemid = atoi(addItemToDonationBox.c_str());
										auto pData = (PlayerInfo*)peer->data;

										if (itemid < 1 || itemid > CoreDataItems)
										{
											break;
										}
										if (itemid == 18 || itemid == 32 || itemid == 6336 || itemDefs.at(itemid).properties & Property_Untradable || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
										{
											Player::OnTextOverlay(peer, "`4You can't donate " + itemDefs.at(itemid).name + ".");
											break;
										}

										if (itemDefs.at(itemid).rarity < 2)
										{
											Player::OnConsoleMessage(peer, "`4Oops! `oYou only can donate items higher than 2 rarity!");
											break;
										}

										auto isdbox = std::experimental::filesystem::exists("donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnConsoleMessage(peer, "`4Oops! `oAn error occured while getting donation box info.");
											break;
										}



										ifstream ifff("donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["donated"] > 19)
										{
											Player::OnTalkBubble(peer, pData->netID, "`4Donation box is full!", 0);
											break;
										}

										GTDialog myDbox;
										myDbox.addLabelWithIcon(itemDefs.at(itemid).name, itemid, LABEL_BIG);
										myDbox.addSmallText("`$How many to put in the box as a gift? (Note: you will `4LOSE `$the items you give!)");
										myDbox.addInputBox("givedonationboxitemCount_" + coord + "_" + to_string(itemid) + "", "Count:", "", 5);
										myDbox.addSpacer(SPACER_SMALL);
										myDbox.addInputBox("givedonationboxitemNote", "Optional Note:", "", 50);

										myDbox.addSpacer(SPACER_SMALL);
										myDbox.addQuickExit();
										myDbox.endDialog("givedonationboxitemConfirm", "`4Give the item(s)", "Cancel");
										Player::OnDialogRequest(peer, myDbox.finishDialog());
									}
									if (infoDat[0] == "dialog_name" && infoDat[1] == "change_block")
										entrancedialog = true;
									if (entrancedialog)
									{
										if (!world || world->name == "EXIT") continue;
										auto x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
										auto y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
										if (x < 0 || y < 0) continue;
										if (infoDat.at(0) == "public" && infoDat.at(1) == "1") {
											if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
											world->items[x + (y * world->width)].entrance_open = true;
											UpdateBlockState(peer, x, y, true, world);
											SaveBlockState(world, peer, x, y);
										}
										if (infoDat.at(0) == "public" && infoDat.at(1) == "0") {
											if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
											world->items[x + (y * world->width)].entrance_open = false;
											UpdateBlockState(peer, x, y, true, world);
											SaveBlockState(world, peer, x, y);
										}
									}
									if (btn == "buygrowtoken") {
										Player::OnDialogRequest(peer, "set_default_color|`w\nadd_label_with_icon|big|`wPurchase `2Growtoken``|left|32|\nadd_spacer|small|\nadd_label_with_icon|small|`w1 Growtoken = 1 Diamond Lock|left|1796|\nadd_smalltext|`rHow many would you like to buy?|\nadd_text_input|buycount2|||3|\nend_dialog|purchasegtoken|Close|Purchase Growtoken!|");
									}
									if (btn == "changepass") {
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wChange Password|left|1280|\n\nadd_spacer|small|\nadd_textbox|`oAfter changing your password, you will be required to relogin with the new password that you have entered.``|\nadd_text_input|oldpass|`$Current Password``||18|\nadd_text_input|newpass|`$New Password``||18|\nadd_text_input|verifypass|`$Confirm Password``||18|\nend_dialog|pssdia|`wCancel``|`wConfirm!``|");
									}
									if (btn == "enaaapbutton") {
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w2-Step Verification|left|1424|\nadd_spacer|small|\nadd_textbox|`oBy setting a PIN. you will required to enter this everytime you log in. You can type type /disableaap to disable `w2-Step Verification`o.``|\nadd_textbox|`4NOTE: `oYour PIN must be 4 digits.``|left|\nadd_text_input|newpin|`$New PIN``||4|\nadd_text_input|verifynewpin|`$Confirm PIN``||4|\nend_dialog|pindia|`wCancel``|`wConfirm!``|");
									}
									if (btn == "disableaapbutton") {
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w2-Step Verification|left|1424|\nadd_spacer|small|\nadd_textbox|`oPlease enter your PIN to confirm that you want to `4disable `w2-Step Verification`o.``|\nadd_text_input|pinenter|`$PIN``||4|\nend_dialog|pin2||`wConfirm!``|");
									}
									if (btn == "aapbutton") Security_Pin(peer);
									if (btn == "listplayerban_") {
										std::ifstream ifs("rules.txt");
										std::string content((std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
										Player::OnDialogRequest(peer, content);
									}
									if (btn == "addvend") {
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
										int xxx = pData->lastPunchX;
										int yyy = pData->lastPunchY;
										if (xxx < 0 && yyy < 0) break;
										try {
											int iditem = world->items.at(xxx + (yyy * world->width)).fruitcount;
											int countitem = world->items.at(xxx + (yyy * world->width)).intdata;
											auto mtitems = 0;
											for (auto i = 0; i < pData->inventory.items.size(); i++) {
												if (pData->inventory.items.at(i).itemID == iditem) {
													mtitems = pData->inventory.items.at(i).itemCount;
													break;
												}
											}
											if (HasItemsInInv(peer, iditem, mtitems) == -1) continue;
											else {
												RemoveItemFromInv(peer, iditem, mtitems, true);
												if (countitem >= 5000 && world->items.at(xxx + (yyy * world->width)).foreground == 2978) {
													Player::OnTalkBubble(peer, pData->netID, "This " + itemDefs.at(2978).name + " is full!", 0);
													break;
												}
												else if (countitem >= 10000 && world->items.at(xxx + (yyy * world->width)).foreground == 9268) {
													Player::OnTalkBubble(peer, pData->netID, "This " + itemDefs.at(9268).name + " is full!", 0);
													break;
												}
												countitem += mtitems;
												world->items.at(xxx + (yyy * world->width)).intdata = countitem;
												Player::OnTalkBubble(peer, pData->netID, "`wAdded " + to_string(mtitems) + " to the machine.", 0);
											}
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
									if (btn == "dragonpass") {
										string name = getItemDef(((PlayerInfo*)(peer->data))->cloth_hand).name;
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + getItemDef(((PlayerInfo*)(peer->data))->cloth_hand).name + " Transform|left|11508|\nadd_spacer|small|\nadd_button|transaldragon|`$Transform to " + name + "|\nadd_button|transhumdragon|`$Transform to Human|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
									}
									if (btn == "transaldragon") {
										((PlayerInfo*)(peer->data))->transform = 524544;
										GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), 524544));
										memcpy(p.data + 8, &((PlayerInfo*)(peer->data))->netID, 4);
										ENetPacket* packet3 = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHerez(peer, currentPeer)) {
												enet_peer_send(currentPeer, 0, packet3);
											}
										}
										delete p.data;
									}
									if (btn == "transhumdragon") {
										((PlayerInfo*)(peer->data))->transform = 256;
										GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), 256));
										memcpy(p.data + 8, &((PlayerInfo*)(peer->data))->netID, 4);
										ENetPacket* packet3 = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHerez(peer, currentPeer)) {
												enet_peer_send(currentPeer, 0, packet3);
											}
										}
										delete p.data;
									}
									if (btn == "Ezio") {
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + getItemDef(((PlayerInfo*)(peer->data))->cloth_necklace).name + " Transform|left|11560|\nadd_spacer|small|\nadd_button|transEzio|`$Transform to " + getItemDef(((PlayerInfo*)(peer->data))->cloth_necklace).name + "|\nadd_button|transhum|`$Transform to Human|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
									}
									if (btn == "transEzio") {
										((PlayerInfo*)(peer->data))->transform = 1929312;
										GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), 1929312));
										memcpy(p.data + 8, &((PlayerInfo*)(peer->data))->netID, 4);
										ENetPacket* packet3 = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHerez(peer, currentPeer)) {
												enet_peer_send(currentPeer, 0, packet3);
											}
										}
										delete p.data;
									}
									if (btn == "transform_alien") {
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + getItemDef(((PlayerInfo*)(peer->data))->cloth_hand).name + " Transform|left|11398|\nadd_spacer|small|\nadd_button|transal|`$Transform to " + getItemDef(((PlayerInfo*)(peer->data))->cloth_hand).name + "|\nadd_button|transhum|`$Transform to Human|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
									}
									if (btn == "transal") {
										((PlayerInfo*)(peer->data))->transform = 262400;
										GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), 262400));
										memcpy(p.data + 8, &((PlayerInfo*)(peer->data))->netID, 4);
										ENetPacket* packet3 = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHerez(peer, currentPeer)) {
												enet_peer_send(currentPeer, 0, packet3);
											}
										}
										delete p.data;
									}
									if (btn == "transhum") {
										((PlayerInfo*)(peer->data))->transform = 256;
										GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), 256));
										memcpy(p.data + 8, &((PlayerInfo*)(peer->data))->netID, 4);
										ENetPacket* packet3 = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHerez(peer, currentPeer)) {
												enet_peer_send(currentPeer, 0, packet3);
											}
										}
										delete p.data;
									}
									if (infoDat.at(0) == "magplantitem")
										isMagDialog = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "magplantupdate")
										isMagUpdateDialog = true;
									if (isMagUpdateDialog) {
										if (world == nullptr || world->name == "EXIT") continue;
										if (infoDat.at(0) == "checkbox_publicremote") {
											publicremote = infoDat.at(1);
											if (publicremote != "1" && publicremote != "0") break;
											if (isWorldOwner(peer, world) || isDev(peer)) {
												int x = ((PlayerInfo*)(peer->data))->lastPunchX;
												int y = ((PlayerInfo*)(peer->data))->lastPunchY;
												if (publicremote == "1") world->items.at(x + (y * world->width)).rm = true;
												else if (publicremote == "0") world->items.at(x + (y * world->width)).rm = false;
												SaveBlockState(world, peer, x, y);
												break;
											}
										}
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "usethermoblast")
										isThermoDialog = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "mars_dialog")
										ismars = true;
									if (ismars) {
										if (infoDat.at(0) == "mars_name") {
											string upsd = infoDat.at(1);
											string act = infoDat.at(1);
											std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
											if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
												Player::OnConsoleMessage(peer, "Sorry, a world name can't contain special characters or spaces.");
												continue;
											}
											if (!world_exist(upsd)) {
												if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
													Player::OnConsoleMessage(peer, "Sorry, a world name can't contain special characters or spaces.");
												}
												else if (upsd.find(" ") != string::npos) {
													Player::OnConsoleMessage(peer, "Sorry, a world name can't contain special characters or spaces.");
												}
												else if (upsd == "EXIT") {
													Player::OnConsoleMessage(peer, "That world name already exists. You'll have to be more original. Maybe add some numbers after it?");
												}
												else if (upsd == ((PlayerInfo*)(peer->data))->currentWorld) {
													Player::OnConsoleMessage(peer, "That world name already exists. You'll have to be more original. Maybe add some numbers after it?");
												}
												else {
													if (HasItemsInInv(peer, 1136, 1) == -1) continue;
													RemoveItemFromInv(peer, 1136, 1, true);
													usemars = true;
													WorldInfo info = worldDB.get(infoDat.at(1));
													if (info.name == "error") {
														Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
														continue;
													}
													string act = infoDat.at(1);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnTalkBubble(currentPeer, ((PlayerInfo*)(peer->data))->netID, "`5** " + ((PlayerInfo*)(peer->data))->displayName + " `5activates a Mars Blast! `5**", 0);
															Player::OnConsoleMessage(currentPeer, "`5** " + ((PlayerInfo*)(peer->data))->displayName + " `5activates a Mars Blast! `5**");
														}
													}
													Send_Cancel_Game(peer);
													sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
													handle_world(peer, act);
												}
											}
											else {
												Player::OnConsoleMessage(peer, "That world name already exists. You'll have to be more original. Maybe add some numbers after it?");
											}
										}
									}

									if (isThermoDialog) {
										if (infoDat.at(0) == "thermoname") {
											thermoname = infoDat.at(1);
											string upsd = thermoname;
											string act = thermoname;
											std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
											if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
												Player::OnConsoleMessage(peer, "Sorry, a world name can't contain special characters or spaces.");
												continue;
											}
											if (!world_exist(upsd)) {
												if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
													Player::OnConsoleMessage(peer, "Sorry, a world name can't contain special characters or spaces.");
												}
												else if (upsd.find(" ") != string::npos) {
													Player::OnConsoleMessage(peer, "Sorry, a world name can't contain special characters or spaces.");
												}
												else if (upsd == "EXIT") {
													Player::OnConsoleMessage(peer, "That world name already exists. You'll have to be more original. Maybe add some numbers after it?");
												}
												else if (upsd == ((PlayerInfo*)(peer->data))->currentWorld) {
													Player::OnConsoleMessage(peer, "That world name already exists. You'll have to be more original. Maybe add some numbers after it?");
												}
												else {
													if (HasItemsInInv(peer, 1402, 1) == -1) continue;
													RemoveItemFromInv(peer, 1402, 1, true);
													usedthermoblast = true;
													WorldInfo info = worldDB.get(thermoname);
													if (info.name == "error") {
														Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
														continue;
													}
													string act = thermoname;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnTalkBubble(currentPeer, ((PlayerInfo*)(peer->data))->netID, "`5** " + ((PlayerInfo*)(peer->data))->displayName + " `5activates a Thermonuclear Blast! `5**", 0);
															Player::OnConsoleMessage(currentPeer, "`5** " + ((PlayerInfo*)(peer->data))->displayName + " `5activates a Thermonuclear Blast! `5**");
														}
													}
													Send_Cancel_Game(peer);
													sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
													handle_world(peer, act);
												}
											}
											else {
												Player::OnConsoleMessage(peer, "That world name already exists. You'll have to be more original. Maybe add some numbers after it?");
											}
										}
									}
									if (isMagDialog) {
										if (world == nullptr || world->name == "EXIT" || ((PlayerInfo*)(peer->data))->rawName != world->owner && !isDev(peer) && world->owner != "") break;
										int magplantitemi = 0;
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										int x = pData->lastPunchX;
										int y = pData->lastPunchY;
										if (x < 0 || y < 0) continue;
										int suckerid = pData->suckerid;
										string suckername = pData->suckername;
										if (infoDat.at(0) == "magplantitem") magplantitem = infoDat.at(1);
										magplantitemi = atoi(magplantitem.c_str());
										bool allow = true;
										for (int i = 0; i < world->width * world->height; i++) {
											if (world->items.at(i).foreground == 5638 || world->items.at(i).foreground == 6946 || world->items.at(i).foreground == 6948) {
												string SuckerName3 = "";
												if (world->items.at(i).foreground == 5638) SuckerName3 = "magplant";
												if (world->items.at(i).foreground == 6946) SuckerName3 = "gaiabeacon";
												if (world->items.at(i).foreground == 6948) SuckerName3 = "unstabletesseract";
												if (magplantitemi == world->items.at(i).intdata) allow = false;
											}
										}
										if (magplantitemi == 18 || magplantitemi == 32 || itemDefs.at(magplantitemi).properties & Property_Untradable || itemDefs.at(magplantitemi).properties & Property_Permanent) {
											Player::OnTalkBubble(peer, pData->netID, "You cannot use this item in " + itemDefs.at(suckerid).name + "!", 0);
										}
										else if (suckerid == 6946 && getItemDef(magplantitemi).blockType != BlockTypes::SEED) {
											Player::OnTalkBubble(peer, pData->netID, itemDefs.at(suckerid).name + " supports only seeds!", 0);
										}
										else if (suckerid == 6948 && itemDefs.at(magplantitemi).blockType != BlockTypes::FOREGROUND && itemDefs.at(magplantitemi).blockType != BlockTypes::PAIN_BLOCK && itemDefs.at(magplantitemi).blockType != BlockTypes::GROUND_BLOCK && itemDefs.at(magplantitemi).blockType != BlockTypes::BACKGROUND) {
											Player::OnTalkBubble(peer, pData->netID, itemDefs.at(suckerid).name + " supports only foregrounds or backgrounds!", 0);
										}
										else if (allow == false) {
											Player::OnTalkBubble(peer, pData->netID, "There is already Item Sucker with such item!", 0);
										}
										else {
											auto contains = false;
											if (HasItemsInInv(peer, magplantitemi, 1) == -1) continue;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													sendMag(currentPeer, suckerid, x, y, magplantitemi, 0, true, true, world->items.at(x + (y * world->width)).background);
												}
											}
											world->items.at(x + (y * world->width)).intdata = magplantitemi;
											world->items.at(x + (y * world->width)).fruitcount = 0;
										}
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "vending")
										vending = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "vending_buy")
										vending_buy = true;
									if (vending_buy) {
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										string v_buycount = pData->lastvendbuycount;
										pData->lastvendbuycount = "";
										if (v_buycount.size() > 3) break;
										int buy_count = atoi(v_buycount.c_str());
										int x = pData->lastPunchX;
										int y = pData->lastPunchY;
										if (x < 0 || y < 0) continue;
										if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::VENDING) break;
										auto realprice = world->items.at(x + (y * world->width)).growtime;
										auto kiekmoketi = buy_count * realprice;
										auto worldlocks = 0;
										auto diamondlocks = 0;
										auto locks = 0;
										for (auto i = 0; i < pData->inventory.items.size(); i++) {
											if (pData->inventory.items.at(i).itemID == 242) {
												worldlocks = pData->inventory.items.at(i).itemCount;
											}
											if (pData->inventory.items.at(i).itemID == 1796) {
												diamondlocks = pData->inventory.items.at(i).itemCount;
											}
										}
										if (diamondlocks > 0) locks = diamondlocks * 100;
										locks += worldlocks;
										if (kiekmoketi > locks && !world->items.at(x + (y * world->width)).opened) {
											Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
											break;
										}
										else {
											if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).fruitcount, buy_count) || buy_count > 200) {
												Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0);
												break;
											}
											int yracount = world->items.at(x + (y * world->width)).intdata;
											int yrawithdraw = world->items.at(x + (y * world->width)).vdraw;
											if (yracount < buy_count || buy_count <= 0) {
												Player::OnTalkBubble(peer, pData->netID, "Out of order", 0);
												break;
											}
											if (world->items.at(x + (y * world->width)).opened) {
												if (buy_count < world->items.at(x + (y * world->width)).growtime) {
													Player::OnConsoleMessage(peer, "You have to buy at least 1 World Lock's worth.");
													Player::OnTalkBubble(peer, pData->netID, "You have to buy at least 1 World Lock's worth.", 0);
													break;
												}
												int oldbuyprice = buyprice;
												buy_count = round(((double)buy_count / world->items.at(x + (y * world->width)).growtime));
												kiekmoketi = buy_count;
												buy_count *= world->items.at(x + (y * world->width)).growtime;
												if (buy_count > world->items.at(x + (y * world->width)).intdata) {
													buy_count = round(oldbuyprice / world->items.at(x + (y * world->width)).growtime);
													kiekmoketi = buy_count;
													buy_count *= world->items.at(x + (y * world->width)).growtime;
												}
												if (kiekmoketi > locks) {
													Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
													break;
												}
											}
											int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
											int is_viso_worldlock = kiekmoketi;
											while (is_viso_worldlock >= 100) {
												is_viso_worldlock -= 100;
												diamond_lock++;
											}
											world_lock = is_viso_worldlock;
											int turi_world_lock = atoi(GetItemCount(peer, 242).c_str());
											int turi_diamond_lock = atoi(GetItemCount(peer, 1796).c_str());
											while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
												turi_diamond_lock++;
												turi_world_lock -= 100;
											} if (diamond_lock > turi_diamond_lock) {
												Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
												break;
											} while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
												turi_diamond_lock--;
												turi_world_lock += 100;
											} if (world_lock > turi_world_lock) {
												Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
												break;
											}
											turi_world_lock -= world_lock;
											turi_diamond_lock -= diamond_lock;
											RemoveItemFromInv(peer, 242, atoi(GetItemCount(peer, 242).c_str()), true);
											RemoveItemFromInv(peer, 1796, atoi(GetItemCount(peer, 1796).c_str()), true);
											AddItemToInv(world, peer, 242, turi_world_lock);
											AddItemToInv(world, peer, 1796, turi_diamond_lock);
											world->items.at(x + (y * world->width)).intdata = world->items.at(x + (y * world->width)).intdata - buy_count;
											int buy_id = world->items.at(x + (y * world->width)).fruitcount;
											if (world->items.at(x + (y * world->width)).intdata <= 0) {
												world->items.at(x + (y * world->width)).intdata = 0;
												world->items.at(x + (y * world->width)).fruitcount = 0;
											}
											world->items.at(x + (y * world->width)).vdraw = world->items.at(x + (y * world->width)).vdraw + kiekmoketi;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													Player::OnConsoleMessage(currentPeer, "`7[`9" + pData->displayName + " `9bought " + to_string(buy_count) + " " + itemDefs.at(buy_id).name + " for " + to_string(kiekmoketi) + " World Locks.`7]");
													SendTradeEffect(currentPeer, buy_id, pData->netID, pData->netID, 150);
													if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
														UpdateVend(currentPeer, x, y, 0, true, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
													}
													else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).fruitcount, true, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
													Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
												}
											}
											AddItemToInv(world, peer, buy_id, buy_count);
										}
										break;
									}
									if (btn == "getremote") {
										if (world == nullptr || world->name == "EXIT") continue;
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										try {
											int x = pData->lastPunchX;
											int y = pData->lastPunchY;
											if (x < 0 || y < 0) continue;
											bool canuseremote = true;
											if (canuseremote) {
												if (pData->inventory.items.size() == pData->inventory.inventorySize) {
													Player::OnTalkBubble(peer, pData->netID, "`wInventory is full!", 0);
													continue;
												}
												if (!CheckItemExists(peer, 5640)) {
													if (isWorldOwner(peer, world) && world->items.at(x + (y * world->width)).intdata != 0 && world->items.at(x + (y * world->width)).fruitcount != 0 || world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).intdata != 0 && world->items.at(x + (y * world->width)).fruitcount != 0) {
														Player::OnTalkBubble(peer, pData->netID, "`wYou received a MAGPLANT 5000 Remote.", 0);
														bool success = true;
														AddItemToInv(world, peer, 5640, 1);
														GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnPlanterActivated"), world->items.at(x + (y * world->width)).intdata));
														ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet3);
														delete p3.data;
														pData->magplantitemid = world->items.at(x + (y * world->width)).intdata;
														pData->magplantx = x;
														pData->magplanty = y;
													}
												}
												else {
													GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnPlanterActivated"), world->items.at(x + (y * world->width)).intdata));
													ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet3);
													delete p3.data;
													pData->magplantitemid = world->items.at(x + (y * world->width)).intdata;
													pData->magplantx = x;
													pData->magplanty = y;
													Player::OnTalkBubble(peer, pData->netID, "`wYou received a MAGPLANT 5000 Remote.", 0);
												}
											}
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
									if (btn.substr(0, 14) == "retrieveGifts_")
									{
										if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
										string coord = btn.substr(btn.find("_") + 1);
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										auto isdbox = std::experimental::filesystem::exists("donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											continue;
										}
										if (pData->rawName == world->owner || world->owner == "" || isDev(peer))
										{
											try {
												ifstream ifff("donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();
												if (j["donated"] < 1)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4There is no any donations!", 0);
													continue;
												}
												bool success = true;
												for (int i = 0; i < 20; i++)
												{
													if (j["donatedItems"].at(i)["itemid"] != 0)
													{
														int howManyEarnings = j["donatedItems"].at(i)["itemcount"];
														int itemid = j["donatedItems"].at(i)["itemid"];
														string whoSent = j["donatedItems"].at(i)["sentBy"];
														if (j["donatedItems"].at(i)["itemcount"] > 200)
														{
															Player::OnTextOverlay(peer, "You cant receive that!");
															break;
														}
														if (CheckItemExists(peer, j["donatedItems"].at(i)["itemid"]))
														{
															int currentlyHave = GetQuantityOfItem(peer, j["donatedItems"].at(i)["itemid"]);
															if (j["donatedItems"].at(i)["itemcount"].get<double>() + currentlyHave < 251)
															{
																AddItemToInv(world, peer, j["donatedItems"].at(i)["itemid"], j["donatedItems"].at(i)["itemcount"]);
																j["donatedItems"].at(i)["itemid"] = 0;
																j["donatedItems"].at(i)["itemcount"] = 0;
																j["donatedItems"].at(i)["sentBy"] = "";
																j["donatedItems"].at(i)["note"] = "";
																j["donated"] = j["donated"].get<double>() - 1;
																ENetPeer* currentPeer;
																for (currentPeer = server->peers;
																	currentPeer < &server->peers[server->peerCount];
																	++currentPeer)
																{
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer))
																	{
																		Player::OnConsoleMessage(currentPeer, "`w[`o" + pData->displayName + " `oreceives `5" + to_string(howManyEarnings) + " `w" + itemDefs.at(itemid).name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
																	}
																}
																Player::OnTalkBubble(peer, pData->netID, "`2Box emptied.", 0);
															}
															else
															{
																int kiekTrukstaIki250 = 200 - currentlyHave;
																AddItemToInv(world, peer, j["donatedItems"].at(i)["itemid"], kiekTrukstaIki250);
																j["donatedItems"].at(i)["itemcount"] = j["donatedItems"].at(i)["itemcount"].get<double>() - kiekTrukstaIki250;
																howManyEarnings -= kiekTrukstaIki250;
																ENetPeer* currentPeer;
																for (currentPeer = server->peers;
																	currentPeer < &server->peers[server->peerCount];
																	++currentPeer)
																{
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer))
																	{
																		Player::OnConsoleMessage(currentPeer, "`w[`o" + pData->rawName + " receives `5" + to_string(kiekTrukstaIki250) + " (`w" + to_string(howManyEarnings) + " `5left) `w" + itemDefs.at(itemid).name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
																	}
																}
																Player::OnTalkBubble(peer, pData->netID, "`2Box emptied.", 0);
															}
														}
														else
														{
															if (pData->inventory.items.size() == pData->inventory.inventorySize)
															{
																Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
																break;
															}

															AddItemToInv(world, peer, j["donatedItems"].at(i)["itemid"], j["donatedItems"].at(i)["itemcount"]);
															j["donatedItems"].at(i)["itemid"] = 0;
															j["donatedItems"].at(i)["itemcount"] = 0;
															j["donatedItems"].at(i)["sentBy"] = "";
															j["donatedItems"].at(i)["note"] = "";
															j["donated"] = j["donated"].get<double>() - 1;
															ENetPeer* currentPeer;
															for (currentPeer = server->peers;
																currentPeer < &server->peers[server->peerCount];
																++currentPeer)
															{
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer))
																{
																	Player::OnConsoleMessage(currentPeer, "`w[`o" + pData->rawName + " receives `5" + to_string(howManyEarnings) + " `w" + itemDefs.at(itemid).name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
																}
															}
															Player::OnTalkBubble(peer, pData->netID, "`2Box emptied.", 0);
														}
													}
												}

												if (j["donated"] <= 0)
												{
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer))
														{
															if (pData->lastPunchX >= 0 && pData->lastPunchY >= 0)
															{
																SendDonateData2(currentPeer, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).background, pData->lastPunchX, pData->lastPunchY, 0);
															}
														}
													}
												}
												ofstream of("donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
											}
											catch (std::exception& e) {
												std::cout << e.what() << std::endl;
											}
											catch (const std::out_of_range& e) {
												std::cout << e.what() << std::endl;
											}
										}
									}
									if (btn == "retrieveitem") {
										if (world == nullptr || world->name == "EXIT") continue;
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										if (pData->rawName != world->owner && !isDev(peer)) continue;
										try {
											int x = pData->lastPunchX;
											int y = pData->lastPunchY;
											if (x < 0 || y < 0) continue;
											int suckerid = pData->suckerid;
											string suckername = pData->suckername;
											if (world->items.at(x + (y * world->width)).fruitcount > 200) {
												if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).intdata, 200)) {
													Player::OnTalkBubble(peer, pData->netID, "`wI dont have a free space to pickup `2200 `$" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + "`w!", 0);
													continue;
												}
												else {
													world->items.at(x + (y * world->width)).fruitcount -= 200;
													bool success = true;
													AddItemToInv(world, peer, world->items.at(x + (y * world->width)).intdata, 200);
													Player::OnTalkBubble(peer, pData->netID, "`oCollected `2200 `5" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + " `oFrom the " + itemDefs.at(suckerid).name + "!", 0);
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															sendMag(currentPeer, suckerid, x, y, world->items.at(x + (y * world->width)).intdata, 1, true, true, world->items.at(x + (y * world->width)).background);
														}
													}
												}
											}
											else {
												if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).intdata, world->items.at(x + (y * world->width)).fruitcount)) {
													Player::OnTalkBubble(peer, pData->netID, "`wI dont have a free space to pickup `2" + to_string(world->items.at(x + (y * world->width)).fruitcount) + " `$" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + "`w!", 0);
													continue;
												}
												else {
													bool iscontainss = false;
													if (HasItemsInInv(peer, 5640, 1) == -1) {
														pData->magplantitemid = 0;
														RemoveItemFromInv(peer, 5640, 1, true);
													}
													bool success = true;
													AddItemToInv(world, peer, world->items.at(x + (y * world->width)).intdata, world->items.at(x + (y * world->width)).fruitcount);
													Player::OnTalkBubble(peer, pData->netID, "`oCollected `2" + to_string(world->items.at(x + (y * world->width)).fruitcount) + " `5" + itemDefs.at(world->items.at(x + (y * world->width)).intdata).name + " `oFrom the " + itemDefs.at(suckerid).name + "!", 0);
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															sendMag(currentPeer, suckerid, x, y, world->items.at(x + (y * world->width)).intdata, 0, true, true, world->items.at(x + (y * world->width)).background);
														}
													}
													world->items.at(x + (y * world->width)).fruitcount = 0;
												}
											}
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
									if (btn == "pullstock")
									{
										if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
										int xxx = ((PlayerInfo*)(peer->data))->lastPunchX;
										int yyy = ((PlayerInfo*)(peer->data))->lastPunchY;
										if (xxx < 0 && yyy < 0) break;
										try {
											int withdrawcpy = world->items.at(xxx + (yyy * world->width)).vdraw;
											if (withdrawcpy != 0) {
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wWithdraw the world locks first!", 0);
												break;
											}
											int realid = world->items.at(xxx + (yyy * world->width)).fruitcount;
											int countid = world->items.at(xxx + (yyy * world->width)).intdata;
											if (CheckItemMaxed(peer, realid, countid)) {
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou can't carry any of those!", 0);
												Player::OnConsoleMessage(peer, "`oYou can't carry any of those!");
												break;
											} if (countid > 200) {
												bool success = true;
												AddItemToInv(world, peer, realid, 200);
												world->items.at(xxx + (yyy * world->width)).intdata -= 200;
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou picked up 200 " + itemDefs.at(realid).name + "`w, leaving " + to_string(world->items.at(xxx + (yyy * world->width)).intdata) + " in the machine.", 0);
												Player::OnConsoleMessage(peer, "`oYou picked up 200 " + itemDefs.at(realid).name + "`o, leaving " + to_string(world->items.at(xxx + (yyy * world->width)).intdata) + " in the machine.");
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).intdata < world->items.at(xxx + (yyy * world->width)).growtime) {
															UpdateVend(currentPeer, xxx, yyy, 0, false, world->items.at(xxx + (yyy * world->width)).growtime, world->items.at(xxx + (yyy * world->width)).foreground, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened, world);
														}
														else UpdateVend(currentPeer, xxx, yyy, world->items.at(xxx + (yyy * world->width)).fruitcount, false, world->items.at(xxx + (yyy * world->width)).growtime, world->items.at(xxx + (yyy * world->width)).foreground, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened, world);
													}
												}
											}
											else {
												world->items.at(xxx + (yyy * world->width)).growtime = 0;
												bool success = true;
												AddItemToInv(world, peer, realid, countid);
												world->items.at(xxx + (yyy * world->width)).fruitcount = 0;
												world->items.at(xxx + (yyy * world->width)).intdata = 0;
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou picked up " + to_string(countid) + " " + itemDefs.at(realid).name + "`w.", 0);
												Player::OnConsoleMessage(peer, "`oYou picked up " + to_string(countid) + " " + itemDefs.at(realid).name + "`o.");
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).intdata < world->items.at(xxx + (yyy * world->width)).growtime) {
															UpdateVend(currentPeer, xxx, yyy, 0, false, world->items.at(xxx + (yyy * world->width)).growtime, world->items.at(xxx + (yyy * world->width)).foreground, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened, world);
														}
														else UpdateVend(currentPeer, xxx, yyy, 0, false, 0, world->items.at(xxx + (yyy * world->width)).foreground, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened, world);
													}
												}
											}
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
									if (btn == "withdraw") {
										if (world->owner != "" && !isWorldOwner(peer, world)) break;
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										int xxx = ((PlayerInfo*)(peer->data))->lastPunchX;
										int yyy = ((PlayerInfo*)(peer->data))->lastPunchY;
										if (xxx < 0 && yyy < 0) break;
										int withdrawcpy = world->items[xxx + (yyy * world->width)].vdraw;
										int count, Rem = 0; int counts = 0; string text = "";
										if (withdrawcpy != 0) {
											if (withdrawcpy <= 100) {
												count = withdrawcpy;
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242) {
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														break;
													}
												}
												int plus = currentItemCount + count;
												if (plus > 200) {
													counts = 200 - currentItemCount;
													if (CheckItemMaxed(peer, 242, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0);
														continue;
													}
													else {
														AddItemToInv(world, peer, 242, counts);
														world->items[xxx + (yyy * world->width)].vdraw -= counts;
														int cn = world->items[xxx + (yyy * world->width)].vdraw;
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " World Locks, leaving " + to_string(cn) + " World Locks in the machine!", 0);
													}
												}
												else {
													if (CheckItemMaxed(peer, 242, withdrawcpy)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0);
														continue;
													}
													else {
														AddItemToInv(world, peer, 242, withdrawcpy);
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(withdrawcpy) + " World Locks.", 0);
														world->items[xxx + (yyy * world->width)].vdraw = 0;
													}
												}
											}
											else if (withdrawcpy > 100) {
												count = withdrawcpy / 100;
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1796) {
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														break;
													}
												}
												int plus = currentItemCount + count;
												if (plus > 200) {
													counts = 200 - currentItemCount;
													if (CheckItemMaxed(peer, 1796, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect Diamond Locks!", 0);
														continue;
													}
													AddItemToInv(world, peer, 1796, counts);
													world->items[xxx + (yyy * world->width)].vdraw -= counts * 100;
													int cn = world->items[xxx + (yyy * world->width)].vdraw;
													short int currentItemCount1 = 0; string dtxt, dtxt2, dtxt3 = ""; int total, total1 = 0;
													for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
														if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1796) {
															currentItemCount1 = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (currentItemCount1 == 200 && cn > 100) {
														total = cn / 100;
														total1 = total - cn;
														if (total1 > 0) {
															dtxt2 = " " + to_string(total1) + " World Locks";
															dtxt3 = " and";
														}
														dtxt = "" + to_string(total) + " Diamond Lock" + dtxt3 + "";
													}
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " Diamond Locks, leaving " + dtxt + dtxt2 + " in the machine!", 0);
												}
												else {
													if (count < 200) counts += count;
													else if (count > 199) counts += 200;
													if (CheckItemMaxed(peer, 1796, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks & Diamond Locks!", 0);
														continue;
													}
													AddItemToInv(world, peer, 1796, counts);
													world->items[xxx + (yyy * world->width)].vdraw -= counts * 100;
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(count) + " Diamond Lock.", 0);
													int cn = world->items[xxx + (yyy * world->width)].vdraw;
													if (cn != 0) {
														int countz = 0; short int currentItemCount = 0;
														for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
															if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242) {
																currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
																break;
															}
														}
														int plus = currentItemCount + cn;
														if (plus > 200) countz = 200 - currentItemCount;
														else if (cn < 200) countz += cn;
														else if (cn > 199) countz += 200;
														if (CheckItemMaxed(peer, 242, countz)) {
															Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0);
															continue;
														}
														AddItemToInv(world, peer, 242, countz);
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " Diamond Lock and " + to_string(countz) + " World Locks.", 0);
														world->items[xxx + (yyy * world->width)].vdraw -= countz;
													}
													else {
													}
												}
											}
											int realid = world->items.at(xxx + (yyy * world->width)).fruitcount;
											int priceid = world->items.at(xxx + (yyy * world->width)).growtime;
											if (world->items.at(xxx + (yyy * world->width)).intdata == 0) {
												priceid = 0; realid = 0;
											}
											bool with = false;
											if (world->items[xxx + (yyy * world->width)].vdraw > 0) with = true;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).intdata < world->items.at(xxx + (yyy * world->width)).growtime) {
														UpdateVend(currentPeer, xxx, yyy, 0, false, priceid, world->items.at(xxx + (yyy * world->width)).foreground, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
													else UpdateVend(currentPeer, xxx, yyy, realid, false, priceid, world->items.at(xxx + (yyy * world->width)).foreground, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
												}
											}
										}
										else {
										}
									}
									if (vending) {
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										if (infoDat.at(1) == "pullstock") break;
										if (infoDat.at(0) == "chk_peritem") {
											per_item = infoDat.at(1);
										}
										if (infoDat.at(0) == "chk_perlock") {
											if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
											int x = pData->lastPunchX;
											int y = pData->lastPunchY;
											if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::VENDING) break;
											bool Changedmh = false;
											if (per_item == "1" && infoDat.at(1) == "1") {
												Player::OnConsoleMessage(peer, "You can't have it both ways.");
												Player::OnTalkBubble(peer, pData->netID, "You can't have it both ways.", 0);
												break;
											}
											if (!world->items.at(x + (y * world->width)).opened && per_item == "0" && world->items.at(x + (y * world->width)).rm && infoDat.at(1) != "1") {
												Player::OnConsoleMessage(peer, "You need to pick a pricing method.");
												Player::OnTalkBubble(peer, pData->netID, "You need to pick a pricing method.", 0);
												break;
											}
											if (per_item == "0" && world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).growtime > world->items.at(x + (y * world->width)).intdata && world->items.at(x + (y * world->width)).fruitcount != 0) {
												Player::OnConsoleMessage(peer, "You don't have enough in there for anyone to buy at that price!");
												Player::OnTalkBubble(peer, pData->netID, "You don't have enough in there for anyone to buy at that price!", 0);
												break;
											}
											if (per_item == "1" && !world->items.at(x + (y * world->width)).rm) {
												Changedmh = true;
												world->items.at(x + (y * world->width)).rm = true;
												auto islocks = false;
												if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
															UpdateVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
														}
														else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).fruitcount, islocks, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
													}
												}
												SaveBlockState(world, peer, x, y);
											}
											else if (per_item == "0" && world->items.at(x + (y * world->width)).rm) {
												Changedmh = true;
												world->items.at(x + (y * world->width)).rm = false;
												auto islocks = false;
												if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
															UpdateVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
														}
														else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).fruitcount, islocks, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
													}
												}
												SaveBlockState(world, peer, x, y);
											}
											if (!world->items.at(x + (y * world->width)).rm && infoDat.at(1) == "0" && world->items.at(x + (y * world->width)).opened) {
												Player::OnConsoleMessage(peer, "You need to pick a pricing method.");
												Player::OnTalkBubble(peer, pData->netID, "You need to pick a pricing method.", 0);
												break;
											}
											if (infoDat.at(1) == "1" && !world->items.at(x + (y * world->width)).opened) {
												Changedmh = true;
												world->items.at(x + (y * world->width)).opened = true;
												auto islocks = false;
												if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
															UpdateVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
														}
														else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).fruitcount, islocks, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
													}
												}
												SaveBlockState(world, peer, x, y);
											}
											else if (infoDat.at(1) == "0" && world->items.at(x + (y * world->width)).opened) {
												Changedmh = true;
												world->items.at(x + (y * world->width)).opened = false;
												auto islocks = false;
												if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
															UpdateVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
														}
														else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).fruitcount, islocks, world->items.at(x + (y * world->width)).growtime, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
													}
												}
												SaveBlockState(world, peer, x, y);
											}
											if (Changedmh) {
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(x + (y * world->width)).opened) {
															Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
															Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0);
														}
														else {
															Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
															Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0);
														}
														Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
													}
												}
											}
											if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
											string setpricestr = vend_set_price;
											if (setpricestr.size() > 5 || setpricestr.size() <= 0) break;
											setprice = atoi(setpricestr.c_str());
											if (setprice <= 0) continue;
											if (setprice > 20000) {
												Player::OnTalkBubble(peer, pData->netID, "Well, that's a silly price.", 0);
												break;
											}
											if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::VENDING) break;
											if (world->items.at(x + (y * world->width)).opened && setprice > world->items.at(x + (y * world->width)).intdata && world->items.at(x + (y * world->width)).fruitcount != 0) {
												Player::OnConsoleMessage(peer, "You don't have enough in there for anyone to buy at that price!");
												Player::OnTalkBubble(peer, pData->netID, "You don't have enough in there for anyone to buy at that price!", 0);
												break;
											}
											if (world->items.at(x + (y * world->width)).opened && setprice > 200 && world->items.at(x + (y * world->width)).fruitcount != 0) {
												Player::OnConsoleMessage(peer, "That price is so low, nobody can carry a World Lock worth of items!");
												Player::OnTalkBubble(peer, pData->netID, "That price is so low, nobody can carry a World Lock worth of items!", 0);
												break;
											}
											if (setprice == world->items.at(x + (y * world->width)).growtime) continue;
											world->items.at(x + (y * world->width)).growtime = setprice;
											auto islocks = false;
											if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (!Changedmh) {
														if (world->items.at(x + (y * world->width)).opened) {
															Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
															Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0);
														}
														else {
															Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
															Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0);
														}
														Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
													}
													if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
														UpdateVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
													}
													else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).fruitcount, islocks, setprice, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
												}
											}
											break;
										}
										if (infoDat.at(0) == "stockitem") {
											if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
											string stockitemstr = infoDat.at(1);
											if (stockitemstr.size() > 5 || stockitemstr.size() <= 0) break;
											stockitem = atoi(stockitemstr.c_str());
											if (stockitem < 0 || stockitem > CoreDataItems) break;
											if (stockitem == 18 || stockitem == 32 || stockitem == 6336 || itemDefs.at(stockitem).properties & Property_Untradable || stockitem == 8552 || stockitem == 9472 || stockitem == 9482 || stockitem == 9356 || stockitem == 9492 || stockitem == 9498 || stockitem == 8774 || stockitem == 1790 || stockitem == 2592 || stockitem == 1784 || stockitem == 1792 || stockitem == 1794 || stockitem == 7734 || stockitem == 8306 || stockitem == 9458) {
												Player::OnConsoleMessage(peer, "`oCan't put that in a Vending Machine.");
												Player::OnTalkBubble(peer, pData->netID, "`wCan't put that in a Vending Machine.", 0);
												break;
											}
											int count = 1;
											for (auto i = 0; i < pData->inventory.items.size(); i++) {
												if (pData->inventory.items.at(i).itemID == stockitem) {
													count = pData->inventory.items.at(i).itemCount;
													break;
												}
											}
											if (stockitem == 0 || count == 0) break;
											auto contains = false;
											if (HasItemsInInv(peer, stockitem, count) == -1) continue;
											RemoveItemFromInv(peer, stockitem, count, true);
											UpdatePlayerSet(peer, stockitem);
											int x = pData->lastPunchX;
											int y = pData->lastPunchY;
											if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::VENDING) break;
											world->items.at(x + (y * world->width)).growtime = setprice;
											world->items.at(x + (y * world->width)).fruitcount = stockitem;
											world->items.at(x + (y * world->width)).intdata = count;
											auto islocks = false;
											if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `oput `2" + itemDefs.at(stockitem).name + " `o" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + ".`7]");
													Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wput `2" + itemDefs.at(stockitem).name + "`w " + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + ".`7]", 0);
													if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
														UpdateVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
													}
													else UpdateVend(currentPeer, x, y, stockitem, islocks, setprice, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
													Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
												}
											}
											try {
												int x = ((PlayerInfo*)(peer->data))->lastPunchX;
												int y = ((PlayerInfo*)(peer->data))->lastPunchY;
												int squaresign = x + (y * world->width);
												string type = "";
												if (world->items.at(x + (y * world->width)).rm) {
													type = "\nadd_checkbox|chk_peritem|World Locks per Item|1\nadd_checkbox|chk_perlock|Items per World Lock|0";
												}
												if (world->items.at(x + (y * world->width)).opened) {
													type = "\nadd_checkbox|chk_peritem|World Locks per Item|0\nadd_checkbox|chk_perlock|Items per World Lock|1";
												}
												if (world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).opened) {
													type = "\nadd_checkbox|chk_peritem|World Locks per Item|1\nadd_checkbox|chk_perlock|Items per World Lock|1";
												}
												string currentworld = ((PlayerInfo*)(peer->data))->currentWorld + "X" + std::to_string(squaresign);
												string withdrawdialog = "";
												if (world->items.at(x + (y * world->width)).vdraw > 0) withdrawdialog = "\nadd_smalltext|`oYou have earned " + to_string(world->items.at(x + (y * world->width)).vdraw) + " World Locks.``|left|\nadd_button|withdraw|Withdraw World Locks|";
												if (world->items.at(x + (y * world->width)).fruitcount == 0 || world->items.at(x + (y * world->width)).intdata == 0) {
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_textbox|This machine is empty.|left|\nadd_item_picker|stockitem|`wPut an item in``|Choose an item to put in the machine!|" + withdrawdialog + "|\nend_dialog|vending|Close||");
												}
												else if (world->items.at(x + (y * world->width)).intdata != 0) {
													string addthemdialog = "";
													auto mtitems = 0;
													for (auto i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
														if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == world->items.at(x + (y * world->width)).fruitcount) {
															mtitems = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (mtitems != 0) {
														addthemdialog = "\nadd_smalltext|`oYou have " + to_string(mtitems) + " " + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + " in your backpack.``|left|\nadd_button|addvend|Add them to the machine|";
													}
													string saledialog = "\nadd_textbox|Not currently for sale!|left|";
													if (world->items.at(x + (y * world->width)).growtime != 0) {
														if (world->items.at(x + (y * world->width)).opened) saledialog = "\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|1 x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|";
														else saledialog = "\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|1 x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|";
													}
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|" + saledialog + "|" + addthemdialog + "|\nadd_button|pullstock|Empty the machine|noflags|0|0|\nadd_smalltext|`5(" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + to_string(world->items.at(x + (y * world->width)).growtime) + "|5|" + type + "|" + withdrawdialog + "|\nend_dialog|vending|Close|Update|");
												}
												else if (world->items.at(x + (y * world->width)).intdata != 0 && world->items.at(x + (y * world->width)).growtime != 0) {
													if (world->items.at(x + (y * world->width)).opened) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|1 x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_button|pullstock|Empty the machine|noflags|0|0|\nadd_smalltext|`5(" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + to_string(world->items.at(x + (y * world->width)).growtime) + "|5|" + type + "|" + withdrawdialog + "|\nend_dialog|vending|Close|Update|");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).foreground) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|The machine contains a total of " + to_string(world->items.at(x + (y * world->width)).intdata) + " `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``.|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + to_string(world->items.at(x + (y * world->width)).growtime) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|1 x `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_button|pullstock|Empty the machine|noflags|0|0|\nadd_smalltext|`5(" + itemDefs.at(world->items.at(x + (y * world->width)).foreground).name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + to_string(world->items.at(x + (y * world->width)).growtime) + "|5|" + type + "|" + withdrawdialog + "|\nend_dialog|vending|Close|Update|");
												}
											}
											catch (std::exception& e) {
												std::cout << e.what() << std::endl;
											}
											catch (const std::out_of_range& e) {
												std::cout << e.what() << std::endl;
											}
											break;
										}
										if (infoDat.at(0) == "setprice") {
											if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
											string setpricestr = infoDat.at(1);
											if (setpricestr.size() > 5 || setpricestr.size() <= 0) break;
											setprice = atoi(setpricestr.c_str());
											if (setprice <= 0) continue;
											if (setprice > 20000) {
												Player::OnTalkBubble(peer, pData->netID, "Well, that's a silly price.", 0);
												break;
											}
											int x = pData->lastPunchX;
											int y = pData->lastPunchY;
											if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::VENDING) break;
											if (vend_set_price == "0") {
												vend_set_price = to_string(setprice);
												continue;
											}
											if (world->items.at(x + (y * world->width)).opened && setprice > world->items.at(x + (y * world->width)).intdata && world->items.at(x + (y * world->width)).fruitcount != 0) {
												Player::OnConsoleMessage(peer, "You don't have enough in there for anyone to buy at that price!");
												Player::OnTalkBubble(peer, pData->netID, "You don't have enough in there for anyone to buy at that price!", 0);
												break;
											}
											if (world->items.at(x + (y * world->width)).opened && setprice > 200 && world->items.at(x + (y * world->width)).fruitcount != 0) {
												Player::OnConsoleMessage(peer, "That price is so low, nobody can carry a World Lock worth of items!");
												Player::OnTalkBubble(peer, pData->netID, "That price is so low, nobody can carry a World Lock worth of items!", 0);
												break;
											}
											if (setprice == world->items.at(x + (y * world->width)).growtime) continue;
											world->items.at(x + (y * world->width)).growtime = setprice;
											auto islocks = false;
											if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (world->items.at(x + (y * world->width)).opened) {
														Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
														Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0);
													}
													else {
														Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
														Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0);
													}
													Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
													if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).intdata < world->items.at(x + (y * world->width)).growtime) {
														UpdateVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
													}
													else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).fruitcount, islocks, setprice, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened, world);
												}
											}
											break;
										}
										if (infoDat.at(0) == "buycount") {
											string buycountstr = infoDat.at(1);
											if (buycountstr.size() > 3 || buycountstr.size() <= 0) break;
											buyprice = atoi(buycountstr.c_str());
											if (buyprice <= 0) break;
											int x = pData->lastPunchX;
											int y = pData->lastPunchY;
											if (itemDefs.at(world->items.at(x + (y * world->width)).foreground).blockType != BlockTypes::VENDING) break;
											auto realprice = world->items.at(x + (y * world->width)).growtime;
											auto kiekmoketi = buyprice * realprice;
											auto worldlocks = 0;
											auto diamondlocks = 0;
											auto locks = 0;
											for (auto i = 0; i < pData->inventory.items.size(); i++) {
												if (pData->inventory.items.at(i).itemID == 242) {
													worldlocks = pData->inventory.items.at(i).itemCount;
												}
												if (pData->inventory.items.at(i).itemID == 1796) {
													diamondlocks = pData->inventory.items.at(i).itemCount;
												}
											}
											if (diamondlocks > 0) locks = diamondlocks * 100;
											locks += worldlocks;
											if (kiekmoketi > locks && !world->items.at(x + (y * world->width)).opened) {
												Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
												break;
											}
											if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).fruitcount, buyprice)) {
												Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0);
												break;
											}
											int yracount = world->items.at(x + (y * world->width)).intdata;
											int yrawithdraw = world->items.at(x + (y * world->width)).vdraw;
											if (yracount < buyprice) {
												Player::OnTalkBubble(peer, pData->netID, "Out of order", 0);
												break;
											}
											if (world->items.at(x + (y * world->width)).opened) {
												if (buyprice < world->items.at(x + (y * world->width)).growtime) {
													Player::OnConsoleMessage(peer, "You have to buy at least 1 World Lock's worth.");
													Player::OnTalkBubble(peer, pData->netID, "You have to buy at least 1 World Lock's worth.", 0);
													break;
												}
												int oldbuyprice = buyprice;
												buyprice = round(((double)buyprice / world->items.at(x + (y * world->width)).growtime));
												kiekmoketi = buyprice;
												buyprice *= world->items.at(x + (y * world->width)).growtime;
												if (buyprice > world->items.at(x + (y * world->width)).intdata) {
													buyprice = round(oldbuyprice / world->items.at(x + (y * world->width)).growtime);
													kiekmoketi = buyprice;
													buyprice *= world->items.at(x + (y * world->width)).growtime;
												}
											}
											if (kiekmoketi > locks) {
												Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
												break;
											}
											((PlayerInfo*)(peer->data))->lastvendbuycount = to_string(buyprice);
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(kiekmoketi) + "``) `8World Locks``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(buyprice) + "``) `2" + itemDefs.at(world->items.at(x + (y * world->width)).fruitcount).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).fruitcount) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|vending_buy|Cancel|OK|");
											break;
										}
									}
									if (billpicker) {
										if (world == nullptr || world->name == "EXIT") continue;
										if (getItemDef(billitem).properties & Property_Untradable) {
											SendBillBoard(peer);
											Player::OnTextOverlay(peer, "This item is untradable!");
											continue;
										}
										if (itemDefs.at(billitem).blockType == BlockTypes::LOCK) {
											SendBillBoard(peer);
											Player::OnTextOverlay(peer, "That would never have worked, let's be honest.");
											continue;
										}
										((PlayerInfo*)(peer->data))->billboardid = billitem;
										BillBoard(peer, ((PlayerInfo*)(peer->data))->billboardid, ((PlayerInfo*)(peer->data))->billboardprice, ((PlayerInfo*)(peer->data))->billboardtab, ((PlayerInfo*)(peer->data))->billboardperwhat);
										SendBillBoard(peer);
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "updatebillboard") {
										isBillBoard = true;
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "findid")
									{
										isFindDialog = true;
									}
									if (isBillBoard) {
										if (infoDat.at(0) == "itemperwl") itemperwl = infoDat.at(1);
										if (infoDat.at(0) == "showbill") showbillboard = infoDat.at(1);
										if (infoDat.at(0) == "wlperitem") wlperitem = infoDat.at(1);
										if (infoDat.at(0) == "billprice") billboardprice = infoDat.at(1);
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "editdoor")
									{
										isEditDoorDialog = true;
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "trashdialog")
										isTrashDialog = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "bansubmit")
										bansubmit = true;
									if (bansubmit)
									{
										if (!isMod(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) continue;
										if (infoDat.at(0) == "1day") day1 = infoDat.at(1);
										if (infoDat.at(0) == "7day") day7 = infoDat.at(1);
										if (infoDat.at(0) == "31day") day31 = infoDat.at(1);
										if (infoDat.at(0) == "a") forever = infoDat.at(1);
										if (infoDat.at(0) == "bantest") reason = infoDat.at(1);
										if (infoDat.at(0) == "checkbox_public") checkbox_public = infoDat.at(1);
									}
									if (isBillBoard) {
										if (world == nullptr || world->name == "EXIT") continue;
										if (itemperwl == "") continue;
										if (wlperitem == "") continue;
										if (showbillboard == "") continue;
										if (billboardprice == "") continue;
										bool contains_non_int2 = !std::regex_match(billboardprice, std::regex("^[0-9]+$"));
										if (contains_non_int2) {
											SendBillBoard(peer);
											Player::OnTextOverlay(peer, "symbols not allowed.");
											continue;
										}
										if (wlperitem == "1" && itemperwl == "1") {
											SendBillBoard(peer);
											Player::OnTextOverlay(peer, "You can't have it both ways.");
											continue;
										}
										if (wlperitem == "0" && itemperwl == "0") {
											SendBillBoard(peer);
											Player::OnTextOverlay(peer, "You have to pick atleast one.");
											continue;
										}
										if (itemperwl == "1") {
											((PlayerInfo*)(peer->data))->billboardperwhat = 0;
										}
										if (wlperitem == "1") {
											((PlayerInfo*)(peer->data))->billboardperwhat = 1;
										}
										if (showbillboard == "0") {
											((PlayerInfo*)(peer->data))->billboardtab = 0;
										}
										else if (showbillboard == "1") {
											((PlayerInfo*)(peer->data))->billboardtab = 1;
										}
										((PlayerInfo*)(peer->data))->billboardprice = stoi(billboardprice);
										BillBoard(peer, ((PlayerInfo*)(peer->data))->billboardid, ((PlayerInfo*)(peer->data))->billboardprice, ((PlayerInfo*)(peer->data))->billboardtab, ((PlayerInfo*)(peer->data))->billboardperwhat);
										SendBillBoard(peer);
									}
									if (infoDat.at(0) == "buttonClicked" && infoDat.at(1) == "guildconfirm")
										isGuildDialog = true;
									if (isGuildDialog) {
										if (infoDat.at(0) == "gname") guildName = infoDat.at(1);
										if (infoDat.at(0) == "gstatement") guildStatement = infoDat.at(1);
										if (infoDat.at(0) == "ggcflagbg") guildFlagBg = infoDat.at(1);
										if (infoDat.at(0) == "ggcflagfg") guildFlagFg = infoDat.at(1);
									}
									if (isTrashDialog) {
										if (infoDat.at(0) == "trashitemcount") trashitemcount = infoDat.at(1);
									}
									if (isFindDialog) {
										if (infoDat.at(0) == "item") itemFind = infoDat.at(1);
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "art_update") {
										isCanvas = true;
									}
									if (infoDat.at(0) == "art_pick") {
										isCanvas = true;
									}
									if (isCanvas) {
										if (infoDat.at(0) == "art_pick") {
											canvasitem = infoDat.at(1);
											int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
											int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
											if (x < 0 || y < 0) continue;
											world->items.at(x + (y * world->width)).intdata = atoi(canvasitem.c_str());
											world->items.at(x + (y * world->width)).sign = "";
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													SendCanvasData(currentPeer, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, x, y, atoi(canvasitem.c_str()), getItemDef(atoi(canvasitem.c_str())).name);
												}
											}
											break;
										}
										if (infoDat.at(0) == "arttest") {
											canvastext = infoDat.at(1);
											int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
											int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
											if (x < 0 || y < 0) continue;
											int id = world->items.at(x + (y * world->width)).intdata;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (canvastext == "") {
														SendCanvasData(currentPeer, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, x, y, id, getItemDef(id).name);
													}
													else {
														SendCanvasData(currentPeer, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, x, y, id, canvastext);
													}
													world->items.at(x + (y * world->width)).sign = canvastext;
												}
											}
										}
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "loaak")
										isShelf = true;
									if (infoDat.at(0) == "netid") {
										if (isWorldOwner(peer, world) || adminLevel(peer) > 1) {
											netid = infoDat.at(1);
										}
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "gtbuyt") {
										bgtoken = true;
									}
									if (bgtoken) {
										PlayerInfo* pData = (PlayerInfo*)peer->data;
										auto count = ((PlayerInfo*)(peer->data))->buy_dd;
										auto ccount = 0;
										auto ItemID = 1486;

										try {
											for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
												if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242 && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 1) {
													ccount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
													break;
												}
											}
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
										int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
										int is_viso_worldlock = ((PlayerInfo*)(peer->data))->buygkto;
										while (is_viso_worldlock >= 100) {
											is_viso_worldlock -= 100;
											diamond_lock++;
										}
										world_lock = is_viso_worldlock;
										int turi_world_lock = atoi(GetItemCount(peer, 242).c_str());
										int turi_diamond_lock = atoi(GetItemCount(peer, 1796).c_str());
										while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
											turi_diamond_lock++;
											turi_world_lock -= 100;
										} if (diamond_lock > turi_diamond_lock) {
											Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
											break;
										} while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
											turi_diamond_lock--;
											turi_world_lock += 100;
										} if (world_lock > turi_world_lock) {
											Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0);
											break;
										}
										turi_world_lock -= world_lock;
										turi_diamond_lock -= diamond_lock;
										RemoveItemFromInv(peer, 242, atoi(GetItemCount(peer, 242).c_str()), true);
										RemoveItemFromInv(peer, 1796, atoi(GetItemCount(peer, 1796).c_str()), true);
										AddItemToInv(world, peer, 242, turi_world_lock);
										AddItemToInv(world, peer, 1796, turi_diamond_lock);
										AddItemToInv(world, peer, ItemID, count);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										Player::OnConsoleMessage(peer, "CP:_ `4[NOTIFICATION]: `$You've purchased " + to_string(count) + " `o" + itemDefs.at(ItemID).name + " `wfor `$" + to_string(((PlayerInfo*)(peer->data))->buygkto) + " `9Wls`$.\n\n`4[NOTIFICATION]: `5Received: ``" + to_string(count) + " " + itemDefs.at(ItemID).name);
									}
									if (infoDat.at(0) == "buycount2") {
										growtokencount = infoDat.at(1);
										bool contains_non_int = !std::regex_match(growtokencount, std::regex("^[0-9]+$"));

										if (contains_non_int)
										{
											Player::OnTextOverlay(peer, "You can't using symbols!");
										}
										else if (stoi(growtokencount) > 200) {
											Player::OnTextOverlay(peer, "You can't afford that many!");
										}
										else {
											auto Price = 100 * stoi(growtokencount);
											auto ItemID = 1486;
											((PlayerInfo*)(peer->data))->buygkto = Price;
											((PlayerInfo*)(peer->data))->buy_dd = stoi(growtokencount);
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(Price) + "``) `8" + itemDefs.at(242).name + "``|left|" + to_string(242) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + growtokencount + "``) `8" + itemDefs.at(1486).name + "``|left|1486|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|gtbuyt|Cancel|OK|");
											//OnPurchaseRequest2(peer, ItemID, Price, world);
										}
									}
									if (infoDat.at(0) == "tempo")
									{
										tempo = atoi(infoDat.at(1).c_str());
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHere(peer, currentPeer)) {
												if (((PlayerInfo*)(currentPeer->data))->netID == atoi(netid.c_str())) {
													accessPlayer(currentPeer, world);
													break;
												}
											}
										}
										if (world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										if (static_cast<int>(tempo) < 20 || static_cast<int>(tempo) > 200)
										{
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Tempo must be from 20-200 BPM.", true);
											continue;
										}
										if (tempo > 20 || tempo < 200) {
											world->bpm = tempo;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) {
													auto x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
													auto y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
													if (x < 0 || y < 0) continue;
													BYTE yes = 0x00;
													if (world->invisible_music == 1) yes = 32;
													sendTileData(peer, x, y, 0x10, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, lockTileDatas(yes, world->ownerID, 0, 0, false, world->bpm));
												}
											}
										}
									}
									if (infoDat.at(0).substr(0, 9) == "checkbox_") {
										string name = infoDat.at(0).substr(infoDat.at(0).find("_") + 1);
										if (world == NULL && world->name == "EXIT" && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										try {
											for (int i = 0; i < world->accessworld.size(); i++) {
												if (world->accessworld.at(i) == "") continue;
												if (world->accessworld.at(i) == name && infoDat.at(1) == "0") {
													world->accessworld.erase(std::remove(world->accessworld.begin(), world->accessworld.end(), name), world->accessworld.end());
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (((PlayerInfo*)(currentPeer->data))->rawName == name) {
															if (((PlayerInfo*)(currentPeer->data))->adminLevel == 0)
															{
																string lol999 = "";
																lol999 += ((PlayerInfo*)(currentPeer->data))->displayName = ((PlayerInfo*)(currentPeer->data))->tankIDName;
																((PlayerInfo*)(currentPeer->data))->displayName = ((PlayerInfo*)(currentPeer->data))->tankIDName;
																Player::OnNameChanged(currentPeer, ((PlayerInfo*)(currentPeer->data))->netID, lol999);
															}
														}
														if (isHere(peer, currentPeer)) {
															Player::OnConsoleMessage(peer, "" + name + " `owas removed from a World Lock.");
														}
													}
												}
											}
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
											break;
										}
									}
									if (infoDat.at(0) == "isWorldPublic" && infoDat.at(1) == "1")
									{
										if (world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										string name = ((PlayerInfo*)(peer->data))->rawName;
										world->isPublic = true;
									}
									if (infoDat.at(0) == "isWorldPublic" && infoDat.at(1) == "0")
									{
										if (world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										string name = ((PlayerInfo*)(peer->data))->rawName;
										world->isPublic = false;
									}
									if (infoDat.at(0) == "cannoclip" && infoDat.at(1) == "1")
									{
										if (not world->allowNoclip || world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										world->allowNoclip = false;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (isHere(peer, currentPeer)) {
												if (((PlayerInfo*)(currentPeer->data))->canWalkInBlocks == true && ((PlayerInfo*)(currentPeer->data))->adminLevel == 0)
												{
													GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oNoclipping `wis disabled in here!"));
													ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(currentPeer, 0, packet);
													delete p.data;
													((PlayerInfo*)(currentPeer->data))->canWalkInBlocks = false;
													sendState(currentPeer);
												}
											}
										}
									}
									if (infoDat.at(0) == "cannoclip" && infoDat.at(1) == "0")
									{
										if (world->allowNoclip == true || world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										world->allowNoclip = true;
									}
									if (infoDat.at(0) == "cantsay" && infoDat.at(1) == "1")
									{
										if (world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										world->silence = true;
									}
									if (infoDat.at(0) == "cantsay" && infoDat.at(1) == "0")
									{
										if (world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										world->silence = false;
									}

									if (infoDat.at(0) == "checkbox_disable_music_render" && infoDat.at(1) == "1") {
										if (world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										ENetPeer* currentPeer;
										world->invisible_music = 0x1;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (isHere(peer, currentPeer)) {
												auto x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
												auto y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
												if (x < 0 || y < 0) continue;
												sendTileData(peer, x, y, 0x10, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, lockTileDatas(32, world->ownerID, 0, 0, false, world->bpm));
											}

										}
									}
									if (infoDat.at(0) == "checkbox_disable_music_render" && infoDat.at(1) == "0") {
										if (world == NULL && world->name == "EXIT" && !isWorldAdmin(peer, world) && !isWorldOwner(peer, world) && world->owner != "" && adminLevel(peer) < 1) continue;
										ENetPeer* currentPeer;
										world->invisible_music = 0;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (isHere(peer, currentPeer)) {
												auto x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
												auto y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
												if (x < 0 || y < 0) continue;
												sendTileData(peer, x, y, 0x10, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, lockTileDatas(0x00, world->ownerID, 0, 0, false, world->bpm));
											}
										}
									}
									if (isShelf) {
										try {
											auto x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
											auto y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
											if (x < 0 || y < 0) continue;
											if (x == -1 || y == -1) break;
											int i = x + (y * world->width); string s1 = "0", s2 = "0", s3 = "0", s4 = "0"; bool clear = false;
											if (infoDat.at(0) == "buttonClicked" && infoDat.at(1) == "remshelf") { world->items.at(i).sign = ""; clear = true; }
											WorldItem item = world->items.at(i);
											if (getItemDef(item.foreground).blockType != BlockTypes::DISPLAY_SHELF && world->owner != "" && !isWorldOwner(peer, world) && !isWorldAdmin(peer, world) && world->isPublic == false) break;
											if (item.sign != "") {
												auto p = explode("|", item.sign); s1 = p.at(0), s2 = p.at(1), s3 = p.at(2), s4 = p.at(3);
												if (infoDat.at(0) == "shelf1") s1 = infoDat.at(1); if (infoDat.at(0) == "shelf2") s2 = infoDat.at(1);
												if (infoDat.at(0) == "shelf3") s3 = infoDat.at(1); if (infoDat.at(0) == "shelf4") s4 = infoDat.at(1);
											}
											if (s1 == "18" || s1 == "32" || s2 == "18" || s2 == "32" || s3 == "18" || s3 == "32" || s4 == "18" || s4 == "32")
											{
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "That would never have worked, let's be honest.", 0);
												continue;
											}
											string datas = s1 + "|" + s2 + "|" + s3 + "|" + s4;
											if (!clear) world->items.at(i).sign = datas;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) UpdateDisplayShelf(currentPeer, x, y, item.foreground, item.background, atoi(s1.c_str()), atoi(s2.c_str()), atoi(s3.c_str()), atoi(s4.c_str()));
											}
										}
										catch (exception& n) {
											continue;
										}
									}
									PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "lquestconfirm")
										isConfirmQuest = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "dropdialog") {
										isDropDialog = true;
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "growscan_float")
										isGrowscan = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "mars_dialog")
										isMarsDialog = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "buyitem")
										confirmPurchase = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "stuff_weather")
										isStuff = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "bg_weather")
										isBG = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "heatwave")
										isHeatWave = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "captcha_submit")
										captcha = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "findid")
										isFindDialog = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "editsign")
										signEditor = true;
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "tradeconfirm") {
										isFinishTrade = true;

									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1).find("trade_add") == 0)
									{

										itemtodo = atoi(infoDat.at(1).substr(9).c_str());
										if (itemtodo == -1) break;
										isTradeDialog = true;
									}
									if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "storedialog")
										store = true;
									if (store && btn.substr(0, 4) == "buy_") {
										PlayerInfo* p = (PlayerInfo*)peer->data;
										int id = atoi(btn.substr(4, btn.length() - 4).c_str());
										if (id == 10424) {
											OnPurchaseRequest(peer, 10424, "150");
										}
										else if (id == 6946) {
											OnPurchaseRequest(peer, 6946, "250");
										}
										else if (id == 6948) {
											OnPurchaseRequest(peer, 6948, "300");
										}
										else if (id == 5638) {
											OnPurchaseRequest(peer, 5638, "400");
										}
										else if (id == 8372) {
											OnPurchaseRequest(peer, 8372, "450");
										}
										else if (id == 4820) {
											OnPurchaseRequest(peer, 4820, "20");
										}
										else if (id == 6312) {
											OnPurchaseRequest(peer, 6312, "4.000");
										}
										else if (id == 10952 || id == 10954 || id == 10956 || id == 10958 || id == 10960 || id == 11560 || id == 11554 || id == 11556 || id == 11558) {
											OnPurchaseRequest(peer, id, "5.000");
										}
										else if (id == 5480) {
											OnPurchaseRequest(peer, 5480, "1000");
										}
										else if (id == 8552) {
											OnPurchaseRequest(peer, 8552, "400");
										}
										else if (id == 1874) {
											OnPurchaseRequest(peer, 1874, "600");
										}
										else if (id == 8286) {
											OnPurchaseRequest(peer, 8286, "2500");

										}
										else if (id == 1460) {
											OnPurchaseRequest(peer, 1460, "1500");


										}
										else if (id == 1970) {
											OnPurchaseRequest(peer, 1970, "1100");
										}
										else if (id == 1204 || id == 1804) {
											OnPurchaseRequest(peer, id, "10.000");
										}
										else if (id == 1674) {
											OnPurchaseRequest(peer, 1674, "600");
										}
										else if (id == 1442) {
											OnPurchaseRequest(peer, 1442, "3.000");
										}
										else if (id == 11550) {
											OnPurchaseRequest(peer, 11550, "500");
										}
										else if (id == 9428) {
											OnPurchaseRequest(peer, 9428, "130");
										}
										else if (id == 6016) {
											OnPurchaseRequest(peer, 6016, "3000");
										}
									}

									int pances = 95000;
									int maura = 9428;
									int lwiz = 1970;
									int pw = 60000;

									if (confirmPurchase && btn.substr(0, 8) == "buyitem_") {
										PlayerInfo* p = (PlayerInfo*)peer->data;
										PlayerInfo* pData = ((PlayerInfo*)(peer->data));
										int id = atoi(btn.substr(8, btn.length() - 8).c_str());
										if (id == 10424) {
											OnPurchaseRequest2(peer, 10424, 150, world);
										}
										else if (id == 6946) {
											OnPurchaseRequest2(peer, 6946, 250, world);
										}
										else if (id == 6948) {
											OnPurchaseRequest2(peer, 6948, 300, world);
										}
										else if (id == 4820) {
											OnPurchaseRequest2(peer, 4820, 20, world);
										}
										else if (id == 6312) {
											OnPurchaseRequest2(peer, 6312, 4000, world);
										}
										else if (id == 5638) {
											OnPurchaseRequest2(peer, 5638, 400, world);
										}
										else if (id == 1442) {
											OnPurchaseRequest2(peer, 1442, 3000, world);
										}
										else if (id == 10952 || id == 10954 || id == 10956 || id == 10958 || id == 10960 || id == 11560 || id == 11554 || id == 11556 || id == 11558) {
											OnPurchaseRequest2(peer, id, 5000, world);
										}
										else if (id == 5480) {
											OnPurchaseRequest2(peer, 5480, 1000, world);
										}
										else if (id == 8552) {
											OnPurchaseRequest2(peer, 8552, 400, world);
										}
										else if (id == 1874) {
											OnPurchaseRequest2(peer, 1874, 600, world);
										}
										else if (id == 8286) {
											OnPurchaseRequest2(peer, 8286, 2500, world);
										}
										else if (id == 8372) {
											OnPurchaseRequest2(peer, 8372, 450, world);
										}
										else if (id == 11550) {
											OnPurchaseRequest2(peer, 11550, 500, world);
										}
										else if (id == 1460) {
											OnPurchaseRequest2(peer, 1460, 1500, world);


										}
										else if (id == 1970) {
											OnPurchaseRequest2(peer, 1970, 1100, world);
										}
										else if (id == 1204 || id == 1804) {
											OnPurchaseRequest2(peer, id, 10000, world);
										}
										else if (id == 1674) {
											OnPurchaseRequest2(peer, 1674, 600, world);
										}
										else if (id == 9428) {
											OnPurchaseRequest2(peer, 9428, 130, world);
										}
										else if (id == 6016) {
											OnPurchaseRequest2(peer, 6016, 3000, world);
										}
										// 8552 mercy 200k

										// 1874 // force 200k
										// 8286 da vinci 80k //gangel 1460 60k // ndev 1970 60k


									}
									if (signEditor) {
										if (infoDat.at(0) == "signtextas") message = infoDat.at(1);
									}

									if (isDropDialog) {
										if (infoDat.at(0) == "dropitemcount") dropitemcount = infoDat.at(1);

									}
									if (isDropDialog) {
										if (infoDat.at(0) == "amount") dropitemcount = infoDat.at(1);
									}

									if (isStuff) {


										if (infoDat.at(0) == "stuff_pick") stuffITEM = infoDat.at(1);


										if (infoDat.at(0) == "stuff_gravity") stuff_gravity = infoDat.at(1);
										if (infoDat.at(0) == "stuff_spin") stuff_spin = atoi(infoDat.at(1).c_str());
										if (infoDat.at(0) == "stuff_invert") stuff_invert = atoi(infoDat.at(1).c_str());


									}
									if (isMarsDialog) {
										if (infoDat.at(0) == "mars_name") marsname = infoDat.at(1);
									}
									if (isRegisterDialog) {
										if (infoDat.at(0) == "username") username = infoDat.at(1);
										if (infoDat.at(0) == "password") password = infoDat.at(1);
										if (infoDat.at(0) == "passwordverify") passwordverify = infoDat.at(1);
										if (infoDat.at(0) == "email") email = infoDat.at(1);

									}
									if (isHeatWave) {
										if (infoDat.at(0) == "heatwave_red") r = atoi(infoDat.at(1).c_str());
										if (infoDat.at(0) == "heatwave_green") g = atoi(infoDat.at(1).c_str());
										if (infoDat.at(0) == "heatwave_blue") b = atoi(infoDat.at(1).c_str());

									}
									if (isTradeDialog) {

										if (infoDat.at(0) == "count")
										{
											counttodo = atoi(infoDat.at(1).c_str());
											if (counttodo == -1) continue;
										}
									}

									if (isGrowscan && btn.substr(0, 4) == "item") {

										int Id = atoi(btn.substr(4, btn.length() - 4).c_str());
										int intid = atoi(btn.substr(4, btn.length() - 4).c_str());
										string ide = btn.substr(4, btn.length() - 4).c_str();
										cout << Id << "kek" << endl;
										sendArrow(peer, Id, true);

									}
									if (isConfirmQuest) {
										PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
										string btntext = "";
										if (pinfo->gems < 1) {
											btntext = "You have none to deliver!";
										}
										else if (pinfo->gems < 100001) {
											btntext = "Deliver " + to_string(pinfo->gems) + " Gems";

										}
										else {
											btntext = "Deliver " + to_string(100000) + " Gems";
										}
										string ste = "set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Fire``|left|1790|\nadd_smalltext|(Step 1/5)|\nadd_spacer|small|\nadd_textbox|`oI challenge you to bring me 100,000 gems!|\nadd_spacer|small|\nadd_smalltext|Current progress " + to_string(((PlayerInfo*)(peer->data))->lquestprogress) + "/100000|\nadd_button|lwizstep1|" + btntext + "|\nadd_button|giveup|Give up this quest|\nend_dialog|lqueststep1|Goodbye!|";
										((PlayerInfo*)(peer->data))->lqueststep = 1;
										((PlayerInfo*)(peer->data))->ltype = 1;
										Player::OnDialogRequest(peer, ste);
									}
									if (isEditDoorDialog) {
										if (infoDat.at(0) == "dest")
										{
											string a = getStrUpper(infoDat.at(1));
											const auto b = explode(":", a);
											if (b.size() == 1)
											{
												destworld = b.at(0);
											}
											else if (b.size() > 1)
											{
												destworld = b.at(0);
												destid = b.at(1);
											}
										}
										if (infoDat.at(0) == "label")
										{
											label = infoDat.at(1);
										}
										if (infoDat.at(0) == "doorid")
										{
											currid = getStrUpper(infoDat.at(1));
										}
										if (infoDat.at(0) == "opentopublic") {
											opens = infoDat.at(1);
										}
									}
									if (isEditDoorDialog)
									{
										PlayerInfo* pinfo = (PlayerInfo*)peer->data;
										if (pinfo->wrenchedBlockLocation < 0 && pinfo->wrenchedBlockLocation > 6000) break;
										world->items[pinfo->wrenchedBlockLocation].destWorld = destworld;
										world->items[pinfo->wrenchedBlockLocation].destId = destid;
										world->items[pinfo->wrenchedBlockLocation].currId = currid;
										world->items[pinfo->wrenchedBlockLocation].sign = label;

										bool tahun = false;
										if (opens == "1") tahun = false;
										else tahun = true;

										world->items[pinfo->wrenchedBlockLocation].opened = tahun;
										string labelForDoor = label == "" ? (destid == "" ? destworld : destworld + "...") : label;

										if (world->items[pinfo->wrenchedBlockLocation].opened)
										{
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) {
													if (isWorldOwner(currentPeer, world) || isWorldAdmin(currentPeer, world) || ((PlayerInfo*)(currentPeer->data))->adminLevel > 1) {
														updateDoor(currentPeer, world->items[pinfo->wrenchedBlockLocation].foreground, world->items[pinfo->wrenchedBlockLocation].background, pinfo->wrenchedBlockLocation % world->width, pinfo->wrenchedBlockLocation / world->width, labelForDoor);
													}
													else UpdateUnlockedDoorVisuals(currentPeer, world->items[pinfo->wrenchedBlockLocation].foreground, pinfo->wrenchedBlockLocation % world->width, pinfo->wrenchedBlockLocation / world->width, world->items[pinfo->wrenchedBlockLocation].background, "`w<Locked>", true, 0);
												}

											}
										}
										else updateDoor(peer, world->items[pinfo->wrenchedBlockLocation].foreground, world->items[pinfo->wrenchedBlockLocation].background, pinfo->wrenchedBlockLocation % world->width, pinfo->wrenchedBlockLocation / world->width, labelForDoor);

										// .....
									}
									if (btn == "gaback") {
										sendGazette(peer);

									}
									//if (btn == "riftoptions") RiftOptions(peer);
									if (btn == "billboardchange") {
										SendBillBoard(peer);
									}
									if (btn == "growmojis")
									{
										Player::OnDialogRequest(peer, "add_label_with_icon|big|Growmojis |left|1366|\nadd_spacer|small|\nadd_smalltext_forced| (sigh) |left|\nadd_smalltext_forced| (mad) |left|\nadd_smalltext_forced| (smile) |left|\nadd_smalltext_forced| (tongue) |left|\nadd_smalltext_forced| (wow) |left|\nadd_smalltext_forced| (no) |left|\nadd_smalltext_forced| (shy) |left|\nadd_smalltext_forced| (wink) |left|\nadd_smalltext_forced| (music) |left|\nadd_smalltext_forced| (lol) |left|\nadd_smalltext_forced| (yes) |left|\nadd_smalltext_forced| (love) |left|\nadd_smalltext_forced| (megaphone) |left|\nadd_smalltext_forced| (heart) |left|\nadd_smalltext_forced| (cool) |left|\nadd_smalltext_forced| (kiss) |left|\nadd_smalltext_forced| (agree) |left|\nadd_smalltext_forced| (see-no-evil) |left|\nadd_smalltext_forced| (dance) |left|\nadd_smalltext_forced| (build) |left|\nadd_smalltext_forced| (oops) | 0.5|left|\nadd_smalltext_forced| (sleep) | 0.5|left|\nadd_smalltext_forced| (punch) | 0.5|left|\nadd_smalltext_forced| (bheart) | 0.5|left|\nadd_smalltext_forced| (cry) | 0.5|left|\nadd_smalltext_forced| (bunny) | 0.5|left|\nadd_smalltext_forced| (cactus) | 0.5|left|\nadd_smalltext_forced| (pine) | 0.5|left|\nadd_smalltext_forced| (peace) | 0.5|left|\nadd_smalltext_forced| (terror) | 0.5|left|\nadd_smalltext_forced| (fireworks) | 0.5|left|\nadd_smalltext_forced| (party) | 0.5|left|\nadd_smalltext_forced| (song) | 0.5|left|\nadd_smalltext_forced| (ghost) | 0.5|left|\nadd_smalltext_forced| (nuke) | 0.5|left|\nadd_smalltext_forced| (halo) | 0.5|left|\nadd_smalltext_forced| (lucky) | 0.5|left|\nadd_smalltext_forced| (wl) | 0.5|left|\nadd_smalltext_forced| (grow) | 0.5|left|\nadd_smalltext_forced| (gems) | 0.5|left|\nadd_smalltext_forced| (gtoken) | 0.5|left|\nadd_smalltext_forced| (vend) | 0.5|left|\nadd_smalltext_forced| (football) | 0.5|left|\nadd_smalltext_forced| (ill) | 0.5|left|\nadd_smalltext_forced| (eyes) | 0.5|left|\nadd_smalltext_forced| (weary) | 0.5|left|\nadd_spacer|small|\nadd_button|btw|`wBack``|noflags|0|0|\nadd_quick_exit|");
									}
									if (btn == "createguildinfo") {
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild|left|5814||\nadd_textbox|`oWelcome to Grow Guilds where you can create a Guild! With a Guild you can compete in Guild Leaderboards to earn rewards and level up the Guild to add more members.|left|\nadd_spacer|small|\nadd_textbox|`oTo create a Guild you must either be a `2Supporter `oor `2Super Supporter`o.|left|\nadd_textbox|`oThe cost for `2Supporters `ois: `6200.000 `oGems.|left|\nadd_spacer|small|\nadd_textbox|`oYou will be charged: `6200.000 `oGems.|left|\nadd_spacer|small|\nadd_textbox|`6Caution`o: A guild can only be created in a world owned by you and locked with a `5World Lock`o!|left|\nadd_spacer|small|`\nadd_button|createguild|`oCreate a Guild``|0|0|\nadd_button|backfriend|Back|0|0|\nend_dialog||Close||");

									}
									if (btn == "createguild") {
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation``|left|5814|\nadd_spacer|small|\nadd_text_input|gname|Guild Name: ||20|\nadd_text_input|gstatement|Guild Statement: ||100|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``||5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``||5|\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create guild.|left|\nadd_textbox|`6Remember`o: A guild can be created in a world owned by you and locked with a `5World Lock`o!|left|\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|left|\nadd_spacer|small|\nadd_button|guildconfirm|`oCreate Guild|\nend_dialog||Cancel|");

									}

									if (btn == "inviteguildbutton") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
										if (((PlayerInfo*)(peer->data))->guild != "") {
											int number = ((PlayerInfo*)(peer->data))->guildmatelist.size();
											if (number > 24) {
												Player::OnConsoleMessage(peer, "`3GUILD ERROR: `oYou already have `425 `oMembers! Please remove some before adding new ones!");
												continue;
											}
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastuser) {
														string name = ((PlayerInfo*)(currentPeer->data))->rawName;
														if (((PlayerInfo*)(currentPeer->data))->guild != "") {
															Player::OnConsoleMessage(peer, "`3GUILD ERROR: `w" + ((PlayerInfo*)(currentPeer->data))->displayName + "`o is already in a Guild!");
														}
														else {
															Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`5[`wGuild request sent to `2" + ((PlayerInfo*)(currentPeer->data))->displayName + "`5]", true);
															Player::PlayAudio(currentPeer, "audio/tip_start.wav", 128);
															((PlayerInfo*)(currentPeer->data))->guildlast = ((PlayerInfo*)(peer->data))->guild;
															((PlayerInfo*)(currentPeer->data))->isinvited = true;
															Player::OnConsoleMessage(currentPeer, "`5[GUILD REQUEST] `oYou've been invited to join `2" + ((PlayerInfo*)(peer->data))->guild + "`o by `w" + ((PlayerInfo*)(peer->data))->displayName + "`o! To accept, `wwrench yourself `oand then choose `2Join " + ((PlayerInfo*)(peer->data))->guild + "`o.");
														}
														break;
													}
												}
											}
										}
										else {
											Player::OnConsoleMessage(peer, "`5[GUILD ERROR] `oYou must be in a Guild as a Elder or higher in order to invite players!");
										}
									}
									if (btn == "joinguild") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
											continue;
										}
										vector<string> gmembers;
										string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guildlast);
										if (guildname != "") {
											try {
												std::ifstream ifff("guilds/" + guildname + ".json");
												if (ifff.fail()) {
													ifff.close();
													continue;
												}
												json j;
												ifff >> j;
												ifff.close();
												int glevel;
												glevel = j["GuildLevel"];
												for (int i = 0; i < j["Member"].size(); i++) {
													gmembers.push_back(j["Member"].at(i));
												}
												int membercount = gmembers.size();
												int maxmembers = 15;
												if (membercount >= maxmembers) {
													Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `oThat guild is already full!");
													continue;
												}
												else {
													((PlayerInfo*)(peer->data))->guild = ((PlayerInfo*)(peer->data))->guildlast;
													((PlayerInfo*)(peer->data))->guildlast = "";
													((PlayerInfo*)(peer->data))->isinvited = false;
													((PlayerInfo*)(peer->data))->joinguild = true;
													updateInvis(peer);
													std::ifstream ifff("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
													if (ifff.fail()) {
														ifff.close();
														Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
														continue;
													}
													if (ifff.is_open()) {
													}
													json j;
													ifff >> j; //load
													ifff.close();
													vector<string> gmlist;
													for (int i = 0; i < j["Member"].size(); i++) {
														gmlist.push_back(j["Member"].at(i));
													}
													gmlist.push_back(((PlayerInfo*)(peer->data))->rawName);
													j["Member"] = gmlist; //edit
													std::ofstream o("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
													if (!o.is_open()) continue;
													o << j << std::endl;
													o.close();
													{
														try {
															ifstream read_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
															if (!read_player.is_open()) {
																continue;
															}
															json jj;
															read_player >> jj;
															read_player.close();
															jj["joinguild"] = true;
															jj["guild"] = ((PlayerInfo*)(peer->data))->guild;
															ofstream write_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
															write_player << jj << std::endl;
															write_player.close();
														}
														catch (std::exception& e) {
															std::cout << e.what() << std::endl;
														}
														catch (const std::out_of_range& e) {
															std::cout << e.what() << std::endl;
														}
													}
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
															updateGuild(peer);
															updateGuild(currentPeer);
															Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou Succesfully joined " + ((PlayerInfo*)(currentPeer->data))->guildlast, 0);
															Player::OnConsoleMessage(currentPeer, "`5[GUILD ALERT] `2" + ((PlayerInfo*)(peer->data))->displayName + " `ojoined the guild!");
															((PlayerInfo*)(peer->data))->guildFg = atoi(((PlayerInfo*)(peer->data))->createGuildFlagFg.c_str());
															((PlayerInfo*)(peer->data))->guildBg = atoi(((PlayerInfo*)(peer->data))->createGuildFlagBg.c_str());
															updateInvis(peer);
														}
													}
												}
											}
											catch (...) {
												cout << "joinguild Critical error details: name: " + ((PlayerInfo*)(peer->data))->rawName << endl;
												enet_peer_disconnect_now(peer, 0);
											}
										}
									}
									if (btn == "EditStatement") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wEdit Guild Statement|left|5814|\nadd_text_input|EditState|`$Guild Statement: |" + ((PlayerInfo*)(peer->data))->LastState + "|25|\nadd_spacer|small|\nadd_button|ConfirmState|`$Confirm|0|0|\nend_dialog|cl0se|Close||");
									}
									if (btn == "showguild") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
											continue;
										}
										string onlinegmlist = "";
										string grole = "";
										int onlinecount = 0;
										string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild);
										if (guildname != "") {
											try {
												std::ifstream ifff("guilds/" + guildname + ".json");
												if (ifff.fail()) {
													ifff.close();
													((PlayerInfo*)(peer->data))->guild = "";
													continue;
												}
												json j;
												ifff >> j;
												ifff.close();
												int gfbg, gffg, guildlvl, guildxp;
												string gstatement, gleader;
												vector<string> gmembers; vector<string> GE; vector<string> GC;
												gfbg = j["backgroundflag"];
												gffg = j["foregroundflag"];
												gstatement = j["GuildStatement"].get<std::string>();
												gleader = j["Leader"].get<std::string>();
												guildlvl = j["GuildLevel"];
												guildxp = j["GuildExp"];
												for (int i = 0; i < j["Member"].size(); i++) {
													gmembers.push_back(j["Member"].at(i));
												}
												for (int i = 0; i < j["Elder-Leader"].size(); i++) {
													GE.push_back(j["Elder-Leader"].at(i));
												}
												for (int i = 0; i < j["Co-Leader"].size(); i++) {
													GC.push_back(j["Co-Leader"].at(i));
												}
												((PlayerInfo*)(peer->data))->guildlevel = guildlvl;
												((PlayerInfo*)(peer->data))->guildexp = guildxp;
												((PlayerInfo*)(peer->data))->guildBg = gfbg;
												((PlayerInfo*)(peer->data))->guildFg = gffg;
												((PlayerInfo*)(peer->data))->guildStatement = gstatement;
												((PlayerInfo*)(peer->data))->guildLeader = gleader;
												((PlayerInfo*)(peer->data))->guildMembers = gmembers;
												((PlayerInfo*)(peer->data))->guildGE = GE;
												((PlayerInfo*)(peer->data))->guildGC = GC;
											}
											catch (...) {
												cout << "showguild Critical error details: name: " + ((PlayerInfo*)(peer->data))->rawName << endl;
												enet_peer_disconnect_now(peer, 0);
											}
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											string name = ((PlayerInfo*)(currentPeer->data))->rawName;
											if (find(((PlayerInfo*)(peer->data))->guildMembers.begin(), ((PlayerInfo*)(peer->data))->guildMembers.end(), name) != ((PlayerInfo*)(peer->data))->guildMembers.end()) {
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
													onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " `e(GL)``|0|0|";
													onlinecount++;
												}
												else {
													onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " " + grole + "``|0|0|";
													onlinecount++;
												}
											}
										}
										int guildsize = 15;
										if (((PlayerInfo*)(peer->data))->guildlevel == 2) guildsize = 20;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 3) guildsize = 25;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 4) guildsize = 30;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 5) guildsize = 35;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 6) guildsize = 40;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 7) guildsize = 45;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 8) guildsize = 50;
										if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
											string guilds = "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oGuild Name: " + guildname + "|left|\nadd_textbox|Guild Statement: " + ((PlayerInfo*)(peer->data))->guildStatement + "``|\nadd_textbox|`oGuild size: " + to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(((PlayerInfo*)(peer->data))->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|guildleveluper|`wUpgrade Guild``|0|0|\nadd_button|EditStatement|`wEdit Guild Statement|0|0|\nadd_button|leavefromguild|`4Abandon Guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|";
											Player::OnDialogRequest(peer, guilds);
										}
										else {
											string guild = "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oGuild Name: " + guildname + "|left|\nadd_textbox|Guild Statement: " + ((PlayerInfo*)(peer->data))->guildStatement + "``|\nadd_textbox|`oGuild size: " + to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(((PlayerInfo*)(peer->data))->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|";
											Player::OnDialogRequest(peer, guild);
										}
									}
									if (btn == "leavefromguild") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
											continue;
										}
										if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
											Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`8Are you sure?``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oAfter `4Abandon `ofrom the guild, all guild's members will be `4kicked out `oand the guild will be `4destroyed`o!|left|8|\nadd_spacer|small|\nadd_button|confirmguildleaderleave|`4Yes, Abandon!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
										}
										else {
											try {
												std::ifstream ifff("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
												if (ifff.fail()) {
													ifff.close();
													Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
													continue;
												}
												if (ifff.is_open()) {
												}
												remove(("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json").c_str());
												json j;
												ifff >> j; //load
												ifff.close();
												vector<string> gmlist;
												for (int i = 0; i < j["Member"].size(); i++) {
													gmlist.push_back(j["Member"].at(i));
												}
												gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(peer->data))->rawName), gmlist.end());
												j["Member"] = gmlist;
												std::ofstream o("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
												if (!o.is_open()) continue;
												o << j << std::endl;
												o.close();
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
														updateGuild(currentPeer);
														updateInvis(currentPeer);
													}
												}
												((PlayerInfo*)(peer->data))->guildBg = 0;
												((PlayerInfo*)(peer->data))->guildFg = 0;
												((PlayerInfo*)(peer->data))->guildLeader = "";
												((PlayerInfo*)(peer->data))->guild = "";
												((PlayerInfo*)(peer->data))->guildStatement = "";
												((PlayerInfo*)(peer->data))->guildlast = "";
												((PlayerInfo*)(peer->data))->lastgm = "";
												((PlayerInfo*)(peer->data))->lastgmname = "";
												((PlayerInfo*)(peer->data))->joinguild = false;
												((PlayerInfo*)(peer->data))->lastgmworld = "";
												((PlayerInfo*)(peer->data))->guildMembers.clear();
												updateInvis(peer);
												try {
													ifstream read_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
													if (!read_player.is_open()) {
														continue;
													}
													json jj;
													read_player >> jj;
													read_player.close();
													jj["joinguild"] = false;
													jj["guild"] = "";
													ofstream write_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
													write_player << jj << std::endl;
													write_player.close();
												}
												catch (std::exception& e) {
													std::cout << e.what() << std::endl;
												}
												catch (const std::out_of_range& e) {
													std::cout << e.what() << std::endl;
												}
											}
											catch (...) {
												cout << "leavefromguild Critical error details: name: " + ((PlayerInfo*)(peer->data))->rawName << endl;
												enet_peer_disconnect_now(peer, 0);
											}
										}
									}
									if (btn == "confirmguildleaderleave") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
											continue;
										}
										try {
											std::ifstream ifff("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
											if (ifff.fail()) {
												ifff.close();
												Player::OnDialogRequest(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
												continue;
											}
											json j;
											ifff >> j; //load
											ifff.close();
											vector<string> gmlist;
											for (int i = 0; i < j["Member"].size(); i++) {
												gmlist.push_back(j["Member"].at(i));
											}
											const int result = remove(("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json").c_str());
											if (result == 0) {
											}
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (find(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != gmlist.end()) {
													((PlayerInfo*)(currentPeer->data))->guildBg = 0;
													((PlayerInfo*)(currentPeer->data))->guildFg = 0;
													((PlayerInfo*)(currentPeer->data))->guildLeader = "";
													((PlayerInfo*)(currentPeer->data))->guild = "";
													((PlayerInfo*)(currentPeer->data))->guildStatement = "";
													((PlayerInfo*)(currentPeer->data))->guildlast = "";
													((PlayerInfo*)(currentPeer->data))->lastgm = "";
													((PlayerInfo*)(currentPeer->data))->lastgmname = "";
													((PlayerInfo*)(currentPeer->data))->joinguild = false;
													((PlayerInfo*)(currentPeer->data))->lastgmworld = "";
													((PlayerInfo*)(currentPeer->data))->guildMembers.clear();
													updateInvis(currentPeer);
													Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `4Unfortunately, `obut guild's leader `4abandoned `ofrom the guild and you were `4kicked out`o.");
												}
											}
											for (int i = 0; i < gmlist.size(); i++) {
												try {
													ifstream read_player("players/" + gmlist.at(i) + ".json");
													if (!read_player.is_open()) {
														continue;
													}
													json jj;
													read_player >> jj;
													read_player.close();
													jj["joinguild"] = false;
													jj["guild"] = "";
													ofstream write_player("players/" + gmlist.at(i) + ".json");
													write_player << jj << std::endl;
													write_player.close();
												}
												catch (std::exception& e) {
													std::cout << e.what() << std::endl;
												}
												catch (const std::out_of_range& e) {
													std::cout << e.what() << std::endl;
												}
											}
										}
										catch (...) {
											cout << "confirmguildleave Critical error details: name: " + ((PlayerInfo*)(peer->data))->rawName << endl;
											enet_peer_disconnect_now(peer, 0);
										}
									}
									if (btn == "guildoffline") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
											continue;
										}
										string onlinegmlist = "";
										string offname, offlinegm;
										string grole = "";
										int onlinecount = 0;
										int totalcount = ((PlayerInfo*)(peer->data))->guildMembers.size();
										string gstatement = ((PlayerInfo*)(peer->data))->guildLeader;
										string bg = std::to_string(((PlayerInfo*)(peer->data))->guildBg);
										string fg = std::to_string(((PlayerInfo*)(peer->data))->guildFg);
										string guildname = ((PlayerInfo*)(peer->data))->guild;
										string guildleader = ((PlayerInfo*)(peer->data))->guildLeader;
										string guildlvl = "0";
										string guildexp = "0";
										vector<string> offlineguild = ((PlayerInfo*)(peer->data))->guildMembers;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											string name = ((PlayerInfo*)(currentPeer->data))->rawName;
											if (find(((PlayerInfo*)(peer->data))->guildMembers.begin(), ((PlayerInfo*)(peer->data))->guildMembers.end(), name) != ((PlayerInfo*)(peer->data))->guildMembers.end()) {
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
													onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " `e(GL)``|0|0|";
													onlinecount++;
												}
												else {
													onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " " + grole + "``|0|0|";
													onlinecount++;
													offlineguild.erase(std::remove(offlineguild.begin(), offlineguild.end(), name), offlineguild.end());
												}
											}
										}
										for (std::vector<string>::const_iterator i = offlineguild.begin(); i != offlineguild.end(); ++i) {
											offname = *i;
											offlinegm += "\nadd_button|offlinegm_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";
										}
										int guildsize = 15;
										if (((PlayerInfo*)(peer->data))->guildlevel == 2) guildsize = 20;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 3) guildsize = 25;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 4) guildsize = 30;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 5) guildsize = 35;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 6) guildsize = 40;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 7) guildsize = 45;
										else if (((PlayerInfo*)(peer->data))->guildlevel == 8) guildsize = 50;
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|" + ((PlayerInfo*)(peer->data))->guildStatement + "``|\nadd_textbox|`oGuild size: " + std::to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(((PlayerInfo*)(peer->data))->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + " `wGuild Members Online|" + offlinegm + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|");
									}
									if (btn.substr(0, 10) == "offlinegm_") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
										((PlayerInfo*)(peer->data))->lastgm = btn.substr(10, cch.length() - 10 - 1);
										if (btn.substr(10, cch.length() - 10 - 1) == ((PlayerInfo*)(peer->data))->guildLeader) {
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + ((PlayerInfo*)(peer->data))->lastgm + "|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Leader|\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|");
										}
										else {
											if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + ((PlayerInfo*)(peer->data))->lastgm + "|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Member|\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|removegmoffline|`oKick from the guild``|0|0|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|");
											}
											else {
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + ((PlayerInfo*)(peer->data))->lastgm + "|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Member|\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|");
											}
										}
									}
									if (btn.substr(0, 9) == "onlinegm_") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == btn.substr(9, cch.length() - 9 - 1)) {
												((PlayerInfo*)(peer->data))->lastgmworld = ((PlayerInfo*)(currentPeer->data))->currentWorld;
												((PlayerInfo*)(peer->data))->lastgmname = ((PlayerInfo*)(currentPeer->data))->displayName;
												((PlayerInfo*)(peer->data))->lastgm = ((PlayerInfo*)(currentPeer->data))->rawName;
												break;
											}
										}
										if (btn.substr(9, cch.length() - 9 - 1) == ((PlayerInfo*)(peer->data))->rawName) {
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|This is you!|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|");
										}
										else {
											if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\nadd_spacer|small|\nadd_button|removegmonline|Kick from guild|0|0|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|");
											}
											else {
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|");
											}
										}
									}
									if (btn == "removegmoffline") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
												try {
													std::ifstream ifff("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
													if (ifff.fail()) {
														ifff.close();
														Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
														continue;
													}
													if (ifff.is_open()) {
													}
													json j;
													ifff >> j; //load
													ifff.close();
													vector<string> gmlist;
													for (int i = 0; i < j["Member"].size(); i++) {
														gmlist.push_back(j["Member"].at(i));
													}
													gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(peer->data))->lastgm), gmlist.end());
													j["Member"] = gmlist; //edit
													std::ofstream o("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
													if (!o.is_open()) continue;
													o << j << std::endl;
													o.close();
													{
														try {
															ifstream read_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
															if (!read_player.is_open()) {
																continue;
															}
															json jj;
															read_player >> jj;
															read_player.close();
															jj["joinguild"] = false;
															jj["guild"] = "";
															ofstream write_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
															write_player << jj << std::endl;
															write_player.close();
														}
														catch (std::exception& e) {
															std::cout << e.what() << std::endl;
														}
														catch (const std::out_of_range& e) {
															std::cout << e.what() << std::endl;
														}
													}
													Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `2" + ((PlayerInfo*)(peer->data))->lastgm + "`o has been kicked from the guild!");
												}
												catch (...) {
													cout << "removegmoffline Critical error details: name: " + ((PlayerInfo*)(peer->data))->rawName << endl;
													enet_peer_disconnect_now(peer, 0);
												}
											}
										}
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`4Guild Member removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgm + " is no longer in the guild.``|\n\nadd_spacer|small|\nadd_button|guildportalbutton|`oOK``|0|0|\nadd_quick_exit|");
									}
									if (btn == "removegmonline") {
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastgm) {
												try {
													std::ifstream ifff("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
													if (ifff.fail()) {
														ifff.close();
														Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
														continue;
													}
													if (ifff.is_open()) {
													}
													json j;
													ifff >> j;
													ifff.close();
													vector<string> gmlist;
													for (int i = 0; i < j["Member"].size(); i++) {
														gmlist.push_back(j["Member"].at(i));
													}
													gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(peer->data))->lastgm), gmlist.end());
													j["Member"] = gmlist;
													std::ofstream o("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
													if (!o.is_open()) continue;
													o << j << std::endl;
													o.close();
													((PlayerInfo*)(currentPeer->data))->guildBg = 0;
													((PlayerInfo*)(currentPeer->data))->guildFg = 0;
													((PlayerInfo*)(currentPeer->data))->guildLeader = "";
													((PlayerInfo*)(currentPeer->data))->guild = "";
													((PlayerInfo*)(currentPeer->data))->guildStatement = "";
													((PlayerInfo*)(currentPeer->data))->guildlast = "";
													((PlayerInfo*)(currentPeer->data))->lastgm = "";
													((PlayerInfo*)(currentPeer->data))->lastgmname = "";
													((PlayerInfo*)(currentPeer->data))->joinguild = false;
													((PlayerInfo*)(currentPeer->data))->lastgmworld = "";
													((PlayerInfo*)(currentPeer->data))->guildMembers.clear();
													updateInvis(currentPeer);
													updateInvis(peer);
													{
														try {
															ifstream read_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
															if (!read_player.is_open()) {
																continue;
															}
															json jj;
															read_player >> jj;
															read_player.close();
															jj["joinguild"] = false;
															jj["guild"] = "";
															ofstream write_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
															write_player << jj << std::endl;
															write_player.close();
														}
														catch (std::exception& e) {
															std::cout << e.what() << std::endl;
														}
														catch (const std::out_of_range& e) {
															std::cout << e.what() << std::endl;
														}
													}
													Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `oYou have been kicked from the guild by `2" + ((PlayerInfo*)(peer->data))->displayName + "`o.");
												}
												catch (...) {
													cout << "removegmonline Critical error details: name: " + ((PlayerInfo*)(peer->data))->rawName << endl;
													enet_peer_disconnect_now(peer, 0);
												}
											}
											if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
												updateGuild(currentPeer);
												Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `2" + ((PlayerInfo*)(peer->data))->lastgmname + "`o has been kicked from the guild!");
											}
										}
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`4Guild Member removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is no longer in the guild.``|\n\nadd_spacer|small|\nadd_button|guildportalbutton|`oOK``|0|0|\nadd_quick_exit|");
									}
									if (btn == "confirmcreateguild") {
										if (((PlayerInfo*)(peer->data))->gems > 249999) {
											((PlayerInfo*)(peer->data))->gems = ((PlayerInfo*)(peer->data))->gems - 250000;
											FlushPlayer(peer);
											Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
											string guildName = ((PlayerInfo*)(peer->data))->createGuildName;
											string guildStatement = ((PlayerInfo*)(peer->data))->createGuildStatement;
											string fixedguildName = PlayerDB::getProperName(guildName);
											string guildFlagbg = ((PlayerInfo*)(peer->data))->createGuildFlagBg;
											string guildFlagfg = ((PlayerInfo*)(peer->data))->createGuildFlagFg;
											Player::OnAddNotification(peer, "`w" + guildName + " guild have been created!", "audio/gong.wav", "interface/large/gd_prom.rttex");
											try {
												std::ofstream o("guilds/" + fixedguildName + ".json");
												if (!o.is_open()) {
													break;
												}
												json j;
												vector<string> test1s;
												vector<string>test2s;
												((PlayerInfo*)(peer->data))->guildMembers.push_back(((PlayerInfo*)(peer->data))->rawName);
												j["GuildName"] = ((PlayerInfo*)(peer->data))->createGuildName;
												j["GuildRawName"] = fixedguildName;
												j["GuildStatement"] = ((PlayerInfo*)(peer->data))->createGuildStatement;
												j["Leader"] = ((PlayerInfo*)(peer->data))->rawName;
												j["Co-Leader"] = ((PlayerInfo*)(peer->data))->guildGC;
												j["Elder-Leader"] = ((PlayerInfo*)(peer->data))->guildGE;
												j["Member"] = ((PlayerInfo*)(peer->data))->guildMembers;
												j["GuildLevel"] = 1;
												j["GuildExp"] = 0;
												j["GuildWorld"] = ((PlayerInfo*)(peer->data))->currentWorld;
												j["backgroundflag"] = stoi(((PlayerInfo*)(peer->data))->createGuildFlagBg);
												j["foregroundflag"] = stoi(((PlayerInfo*)(peer->data))->createGuildFlagFg);
												o << j << std::endl;
												o.close();
											}
											catch (std::exception& e) {
												std::cout << e.what() << std::endl;
											}
											{
												try {
													ifstream read_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
													if (!read_player.is_open()) {
														continue;
													}
													json jj;
													read_player >> jj;
													read_player.close();
													jj["joinguild"] = true;
													jj["guild"] = guildName;
													ofstream write_player("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
													write_player << jj << std::endl;
													write_player.close();
												} catch (const exception& e) {
													cout << e.what() << endl;
												} catch (const std::out_of_range& e) {
													cout << e.what() << endl;
												}
											}
											((PlayerInfo*)(peer->data))->guild = guildName;
											((PlayerInfo*)(peer->data))->joinguild = true;
											((PlayerInfo*)(peer->data))->guildFg = atoi(((PlayerInfo*)(peer->data))->createGuildFlagFg.c_str());
											((PlayerInfo*)(peer->data))->guildBg = atoi(((PlayerInfo*)(peer->data))->createGuildFlagBg.c_str());
											// GAY
											string name2;
											string namemsg = ((PlayerInfo*)(peer->data))->rawName;
											if (((PlayerInfo*)(peer->data))->adminLevel == 3) {
												name2 = "`6@" + ((PlayerInfo*)(peer->data))->tankIDName + " `e(GL)";
												((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
											}
											else if (((PlayerInfo*)(peer->data))->adminLevel == 2) {
												name2 = "`4@" + ((PlayerInfo*)(peer->data))->tankIDName + " `e(GL)";
												((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
											}
											else if (((PlayerInfo*)(peer->data))->adminLevel == 1) {
												name2 = "`#@" + ((PlayerInfo*)(peer->data))->tankIDName + " `e(GL)";
												((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
											}
											else if (haveSubscription(peer)) {
												name2 = "`e[VIP] ```w" + ((PlayerInfo*)(peer->data))->tankIDName + " `e(GL)";
												((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
											}
											else {
												name2 = "`w" + ((PlayerInfo*)(peer->data))->tankIDName + " `e(GL)";
											}
											((PlayerInfo*)(peer->data))->displayName = name2;
											((PlayerInfo*)(peer->data))->backupName = namemsg;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) {
													Player::OnNameChanged(currentPeer, ((PlayerInfo*)(peer->data))->netID, name2);
												}
											}
											updateInvis(peer);
										}
										else {
											Player::OnTextOverlay(peer, "You don't have enough gems.");
										}
									}
									if (btn == "goguildhome") {
										string gworld;
										string guildName = ((PlayerInfo*)(peer->data))->guild;
										std::ifstream ifs("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
										if (ifs.is_open()) {
											json j;
											ifs >> j;
											ifs.close();
											gworld = j["GuildWorld"].get<string>();
										}
										Send_Cancel_Game(peer);
										sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
										handle_world(peer, gworld);
									}

									if (btn == "cntn") {
										try {
											handle_world(peer, "START");
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
									if (btn == "tutorial") {

										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wChoose Destination``|left|6128|\n\nadd_spacer|small|\nadd_button|findhelp|`wHow to get any item?``|\nadd_button|gemshelp|`wHow to get `2Gems`w?``|\nadd_button|bluehelp|`wHow to get `2Level`w?``|\nadd_textbox|`wTo see all commands type`o `2/help`w or `2/?`w.|\nadd_spacer|small|\nadd_button|explore|`2Thanks``|\nend_dialog|gazette|||");

									}
									if (btn == "findhelp") {

										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wHow to get any items``|left|6016|\n\nadd_spacer|small|\nadd_textbox|`wAll you have to do is type `2/find`w and enter your item name in dialog!``|\nadd_button|tutorial|`wBack``|\nend_dialog|gazette|||");

									}
									if (btn == "gemshelp") {

										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wHow to get gems``|left|112|\n\nadd_spacer|small|\nadd_label_with_icon|small|`wTo get gems you must break `5blocks`w and with gems you can do whatever you want``|left|112|\n\nadd_spacer|small|\nadd_button|tutorial|`wBack``|\nend_dialog|gazette|||");

									}
									if (btn == "bluehelp") {

										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wHow to get levels``|left|18|\n\nadd_spacer|small|\nadd_label_with_icon|small|`wTo get `2levels`w you must break `5blocks`w, you can see your information by wrenching your self, and if you are level 125+ you can get `eBlue Name!``|left|18|\n\nadd_spacer|small|\nadd_button|tutorial|`wBack``|\nend_dialog|gazette|||");

									}
									if (btn == "trade") {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHere(peer, currentPeer)) {
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastuser) {
													auto a = WaitForTradeWithThisPlayer(peer, currentPeer);
													if (a == -1)
													{
														Player::OnTextOverlay(peer, "That player is busy.");
													}
													if (a == -2)
													{
														Player::OnTextOverlay(peer, "You can't trade with yourself!");
													}
													if (a == -3)
													{
														Player::OnTextOverlay(peer, "This player is not in the same world as you!");
													}
													break;
												}
											}
										}
									}
									if (btn == "bxp") { // purchase xp-boost??

										string ahyes = "set_default_color|`o\nadd_label_with_icon|big|`wPurchase `1XP``|left|1488|\nadd_textbox|This will let you get 2x more xp per block for 30 minutes`p!``````|five|\nadd_textbox|This will cost you: `43.000 `oGems!````|\nadd_button|ybxp|`5Purchase!|NOFLAGS|\nadd_quick_exit|\nadd_button|backtoitemstore|`wBack|";
										Player::OnDialogRequest(peer, ahyes.c_str());
									}
									if (btn == "ybxp") {
										if (((PlayerInfo*)(peer->data))->gems >= 3000) {
											((PlayerInfo*)(peer->data))->xptime = time(NULL);
											((PlayerInfo*)(peer->data))->xpboost += 30 * 60;
											((PlayerInfo*)(peer->data))->gems = ((PlayerInfo*)(peer->data))->gems - 3000;
											string fail = "set_default_color|`o\nadd_label_with_icon|big|`2Purchase Success``|left|112|\nadd_spacer|small|\nadd_textbox|`wYou successfully bought `1XP-BOOST`w!|\nadd_spacer|small|\nadd_button|backtoitemstore|`wBack|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|failedpurchase|";
											Player::OnDialogRequest(peer,
												fail);
											FlushPlayer(peer);
											Player::OnSetBux(peer, pinfo->gems, 0);
										}
										else {
											string fail = "set_default_color|`o\nadd_label_with_icon|big|`4Purchase Failed``|left|1432|\nadd_spacer|small|\nadd_textbox|`wYou dont have enough gems!|\nadd_spacer|small|\nadd_button|backtoitemstore|`wBack|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|failedpurchase|";
											Player::OnDialogRequest(peer, fail);
										}
									}
									if (btn == "bassets") {

										string view = "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Assets``|left|32|\nadd_spacer|small|\nadd_button_with_icon|buyadmin|`4ADMINISTRATOR``|staticBlueFrame|276|1000|\nadd_button_with_icon|buyminimod|`rMODERATOR``|staticBlueFrame|278|600|\nadd_button_with_icon|buyvip|`1VIP-SUBSCRIPTION``|staticBlueFrame|6802|100|\nadd_button_with_icon|buygems|`9GEMS``|staticBlueFrame|112||\nadd_button_with_icon|buylvl|`2LEVEL``|staticBlueFrame|18|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|bac02|`wBack..``|left|\nadd_button|bac0kvyte|`oClose|left|";
										Player::OnDialogRequest(peer, view);
									}

									if (btn == "kick") {
										if (world == NULL || world->name == "EXIT") continue;
										if (isWorldOwner(peer, world) || ((PlayerInfo*)(peer->data))->adminLevel > 1 || isWorldAdmin(peer, world)) {
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) {
													if (peer != currentPeer) {
														if (((PlayerInfo*)(currentPeer->data))->userID == ((PlayerInfo*)(peer->data))->lastUserID) playerRespawn(world, currentPeer, 0);
													}
												}
											}
										}
									}

									if (btn == "worldban") {
										if (world == NULL || world->name == "EXIT") continue;
										if (isWorldOwner(peer, world) || ((PlayerInfo*)(peer->data))->adminLevel > 1 || isWorldAdmin(peer, world)) {
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													Player::OnConsoleMessage(currentPeer, "`o" + ((PlayerInfo*)(peer->data))->rawName + " `4World Bans " + "`o" + ((PlayerInfo*)(peer->data))->lastuser + " from `w" + world->name + "`o!````");
													Player::PlayAudio(currentPeer, "audio/repair.wav", 128);
													if (peer != currentPeer) {
														if (((PlayerInfo*)(currentPeer->data))->userID == ((PlayerInfo*)(peer->data))->lastUserID) {
															Send_Cancel_Game(currentPeer);
															sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
															sendWorldOffers(currentPeer);
															((PlayerInfo*)(currentPeer->data))->currentWorld = "EXIT";
															try {
																WorldAdministration w{};
																w.userID = ((PlayerInfo*)(currentPeer->data))->userID;
																w.bannedAt = GetCurrentTimeInternalSeconds() + 3600;
																world->wbans.push_back(w);
															}
															catch (...)
															{
																break;
															}
														}
													}
												}
											}
										}
									}

									if (btn == "pull") {
										if (world == NULL || world->name == "EXIT") continue;
										if (isWorldOwner(peer, world) || ((PlayerInfo*)(peer->data))->adminLevel > 0 || isWorldAdmin(peer, world)) {
											if (((PlayerInfo*)(peer->data))->adminLevel > 0) {
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer)) {
														if (peer != currentPeer) {
															if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastuser) {
																Player::OnSetPos(currentPeer, ((PlayerInfo*)(currentPeer->data))->netID, ((PlayerInfo*)(peer->data))->x, ((PlayerInfo*)(peer->data))->y, 0);
																Player::PlayAudio(peer, "audio/object_spawn.wav", 150);
																Player::OnTextOverlay(currentPeer, "You were summoned by a mod.");
																break;
															}
														}
													}
												}
											}
											else {
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer)) {
														if (peer != currentPeer) {
															if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastuser) {
																Player::OnSetPos(currentPeer, ((PlayerInfo*)(currentPeer->data))->netID, ((PlayerInfo*)(peer->data))->x, ((PlayerInfo*)(peer->data))->y, 0);
																Player::PlayAudio(peer, "audio/object_spawn.wav", 150);
																Player::OnTextOverlay(currentPeer, "You were pulled by " + ((PlayerInfo*)(peer->data))->displayName);
																break;
															}
														}
													}
												}
											}
										}
									}

									if (btn == "punishview") {
										if (adminLevel(peer) > 0) {
											try {
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (currentPeer == peer) continue;
													if (isHere(peer, currentPeer)) {
														if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastuser) {
															if (((PlayerInfo*)(currentPeer->data))->adminLevel == 3) {
																Player::OnTextOverlay(peer, "You can't punish an Developer!");
																break;
															}
															int itemid = 0;
															int itemCount = 0;
															string appendItems = "";

															char clientConnection[16];
															enet_address_get_host_ip(&currentPeer->address, clientConnection, 16);

															PlayerInventory inventory = ((PlayerInfo*)(currentPeer->data))->inventory;
															const int inventoryLen = inventory.items.size();
															for (int i = 0; i < inventoryLen; i++)
															{
																itemid = inventory.items.at(i).itemID;
																itemCount = inventory.items.at(i).itemCount;
																if (itemid == 0) continue;
																if (i % 6 == 0 && i != 0) {
																	appendItems += "\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|||staticBlueFrame|" + to_string(itemid) + "|" + to_string(itemCount) + "|";
																}
																else {
																	appendItems += "\nadd_button_with_icon|||staticBlueFrame|" + to_string(itemid) + "|" + to_string(itemCount) + "|";
																}
															}
															Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wInventory of " + ((PlayerInfo*)(peer->data))->lastuser + "'s (" + ((PlayerInfo*)(currentPeer->data))->displayName + "`w)````|left|3802|\nadd_spacer|small|\nadd_label_with_icon_button||`wBan this player````||276|banh|\nadd_button|ipbanfromgame|`4IP-Ban from Game``|NOFLAGS|0|0|small|\nadd_label_with_icon|small|`wInventory slots: `w" + to_string(inventory.inventorySize) + "````|left|18|\nadd_label_with_icon|small|`wIP: " + clientConnection + "````|left|32|\nadd_label_with_icon|small|`wGems`w: " + to_string(((PlayerInfo*)(currentPeer->data))->gems) + "|left|112|\nadd_label_with_icon|small|`wItems count: `w" + to_string(inventoryLen) + "|left|32|\nadd_spacer|small|\nadd_textbox" + appendItems + "|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button|punishviews|Back..|\nadd_button|pubs|`oClose|");
															break;
														}
													}
												}
											}
											catch (std::exception& e) {
												std::cout << e.what() << std::endl;
											}
											catch (const std::out_of_range& e) {
												std::cout << e.what() << std::endl;
											}
										}



									}
									if (btn == "ipbanfromgame")
									{
										if (adminLevel(peer) > 0) {
											string name = ((PlayerInfo*)(peer->data))->lastuser;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave used `#Ban `oon `2" + name + "`o! `#** `o(`4/rules `oto see the rules!)````");
												if (peer != currentPeer) {
													if (name == ((PlayerInfo*)(currentPeer->data))->rawName) {
														ofstream savebantime("punishment/bans/" + PlayerDB::getProperName(name) + ".txt");
														savebantime << (GetCurrentTimeInternalSeconds() + (1051200 * 60)) << endl;
														savebantime << ((PlayerInfo*)(peer->data))->rawName << endl;
														savebantime << reason << endl;
														savebantime.close();
														std::ifstream tsss("ipban.txt");
														std::string strsss((std::istreambuf_iterator<char>(tsss)), std::istreambuf_iterator<char>());
														ipban = strsss;
														ipban += ((PlayerInfo*)(currentPeer->data))->charIP + ",";
														ofstream myfile2;
														myfile2.open("ipban.txt");
														myfile2 << ipban;
														myfile2.close();
														Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4IP-BANNED from `0Growtopia `4for 730 days", "audio/hub_open.wav", "interface/atomic_button.rttex");
														Player::OnConsoleMessage(currentPeer, "`0Warning from `4System`0: You've been `4IP-BANNED from `0Growtopia `4for 730 days");
														enet_peer_disconnect_later(currentPeer, 0);
														SendWebhook(currentDateTime() + " `ohas been `2ip-banned `4" + name, "BAN_LOGS");
													}
												}
											}
										}
									}
									if (btn == "banh") {
										if (adminLevel(peer) > 0) {
											string name = ((PlayerInfo*)(peer->data))->lastuser;
											auto exists = experimental::filesystem::exists("punishment/bans/" + PlayerDB::getProperName(name) + ".txt");

											std::ifstream read_player("players/" + PlayerDB::getProperName(name) + ".json");
											auto existx = false;
											if (read_player.is_open()) {
												read_player.close();
												existx = true;
											}
											if (std::find(creatorname.begin(), creatorname.end(), name) != creatorname.end()) {
												Player::OnTextOverlay(peer, "`oYou can't do that!```");
											}
											else if (exists) {
												Player::OnTextOverlay(peer, "That Player banned already!");
											}
											else if (!existx) {
												Player::OnTextOverlay(peer, "Player not found!");
											}
											else {
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`1Punish player``|left|1432|\n\nadd_spacer|small|\n\nadd_textbox|`wAre you sure you want to ban`` `2" + name + "```w?``|left|\n\nadd_textbox|`rMake sure you have proof and you have discord role on discord group, wrong bans will result in demoting.``|\n\nadd_textbox|`4If you don't post proof image/video in #ban-channel in 12hours, you will be instantly demoted!``|left|\nadd_textbox|Select ban length.|left|\nmax_checks|2|\ntext_scaling_string|Ban time|\nadd_checkicon|1day|1 Day||276||0|\nadd_checkicon|7day|7 Days||276||0|\nadd_checkicon|31day|31 Days||276||0|\nadd_checkicon|a|Forever||278||0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|\n\nadd_textbox|`oReason``|\nadd_text_input|bantest|||65|\nadd_checkbox|checkbox_public|`2Allowed for ban appealing?``|1|\nend_dialog|bansubmit|Cancel|`4Ban from game``|");
												((PlayerInfo*)(peer->data))->banName = name;
											}
										}
									}
									if (btn == "ltit") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Legendary Items``|left|1790|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Legendary Title``|left|\nadd_spacer|small|\nadd_textbox|Price: `315 Growtopia World Locks|\nadd_label|small|`2This item contains: `9Legendary Title!``|left|\nadd_spacer|small|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYLTIT`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
									}
									if (btn == "lgw") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Legendary Items``|left|1790|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Legendary Wings``|left|\nadd_spacer|small|\nadd_textbox|Price: `315 Growtopia World Locks|\nadd_label|small|`2This item contains: `9Legendary Wings!``|left|\nadd_spacer|small|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYLGW`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
									}
									if (btn == "lgb") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Legendary Items``|left|1790|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Legendary Bot``|left|\nadd_spacer|small|\nadd_textbox|Price: `315 Growtopia World Locks|\nadd_label|small|`2This item contains: `9Legendary Bot!``|left|\nadd_spacer|small|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYLGB`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
									}
									if (btn == "lgd") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Legendary Items``|left|1790|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Legendary Title``|left|\nadd_spacer|small|\nadd_textbox|Price: `315 Growtopia World Locks|\nadd_label|small|`2This item contains: `9Dragon of Legend!``|left|\nadd_spacer|small|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYLGD`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
									}
									if (btn == "lgk") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Legendary Items``|left|1790|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Legendary Katana``|left|\nadd_spacer|small|\nadd_textbox|Price: `315 Growtopia World Locks|\nadd_label|small|`2This item contains: `9Legendary Katana!``|left|\nadd_spacer|small|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYLGK`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
									}
									if (btn == "lwp") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Legendary Items``|left|1790|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Legendary Whip of Truth``|left|\nadd_spacer|small|\nadd_textbox|Price: `315 Growtopia World Locks|\nadd_label|small|`2This item contains: `9Legendary Whip of Truth!``|left|\nadd_spacer|small|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYLWP`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
									}
									if (btn == "lkw") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Legendary Items``|left|1790|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Legendary Dragon Knight Wings``|left|\nadd_spacer|small|\nadd_textbox|Price: `315 Growtopia World Locks|\nadd_label|small|`2This item contains: `9Legendary Dragon Knight Wings!``|left|\nadd_spacer|small|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYLKW`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
									}

									if (btn == "subs1day")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase `cSubscription``|left|6802|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `320 Growtopia World Locks.|left|\nadd_textbox|Duration: `w[`41 Days`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Do Not Abuse Your Role|left|\nadd_smalltext|`94. `2Trying to sell account will result in ip-banned.|left|\nadd_spacer|small|\nadd_textbox|`9Commands:|small|\nadd_smalltext|`eAll commands are displayed in /help.|small|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYVIP`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "subs3day")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase `cSubscription``|left|6802|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `340 Growtopia World Locks.|left|\nadd_textbox|Duration: `w[`43 Days`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Do Not Abuse Your Role|left|\nadd_smalltext|`94. `2Trying to sell account will result in ip-banned.|left|\nadd_spacer|small|\nadd_textbox|`9Commands:|small|\nadd_smalltext|`eAll commands are displayed in /help.|small|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYVIP`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "subs7day")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase `cSubscription``|left|6802|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `370 Growtopia World Locks.|left|\nadd_textbox|Duration: `w[`47 Days`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Do Not Abuse Your Role|left|\nadd_smalltext|`94. `2Trying to sell account will result in ip-banned.|left|\nadd_spacer|small|\nadd_textbox|`9Commands:|small|\nadd_smalltext|`eAll commands are displayed in /help.|small|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the World Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYVIP`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "subs30day")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase `cSubscription``|left|6802|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `31 Growtopia Diamond Locks.|left|\nadd_textbox|Duration: `w[`430 Days`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Do Not Abuse Your Role|left|\nadd_smalltext|`94. `2Trying to sell account will result in ip-banned.|left|\nadd_spacer|small|\nadd_textbox|`9Commands:|small|\nadd_smalltext|`eAll commands are displayed in /help.|small|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the Diamond Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYVIP`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "buyadmin")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase Administrator``|left|278|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `310 Growtopia Diamond Locks.|left|\nadd_textbox|Duration: `w[`4~`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Do Not Abuse Your Role|left|\nadd_smalltext|`92. `2if you are going to ban people, make sure to have screenshots/video proof.|left|\nadd_smalltext|`93. `2Sharing Account/item will result in account loss.|left|\nadd_smalltext|`94. `2Trying to sell account/item will result in ip-banned.|left|\nadd_spacer|small|\nadd_textbox|`9Commands:|small|\nadd_smalltext|`eAll commands are displayed in /help.|small|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the Diamond Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYMOD`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "buyminimod")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase Moderator``|left|278|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `36 Growtopia Diamond Locks.|left|\nadd_textbox|Duration: `w[`4~`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Do Not Abuse Your Role|left|\nadd_smalltext|`92. `2if you are going to ban people, make sure to have screenshots/video proof.|left|\nadd_smalltext|`93. `2Sharing Account will result in account loss.|left|\nadd_smalltext|`94. `2Trying to sell account will result in ip-banned.|left|\nadd_spacer|small|\nadd_textbox|`9Commands:|small|\nadd_smalltext|`eAll commands are displayed in /help.|small|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the Diamond Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYMOD`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "buyvip")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase VIP``|left|6802|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `31 Growtopia Diamond Locks.|left|\nadd_textbox|Duration: `w[`430 Days`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Do Not Abuse Your Role|left|\nadd_smalltext|`94. `2Trying to sell account will result in ip-banned.|left|\nadd_spacer|small|\nadd_textbox|`9Commands:|small|\nadd_smalltext|`eAll commands are displayed in /help.|small|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the Diamond Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYVIP`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nadd_spacer|small|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "buygems")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase Gems``|left|112|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `310000/1 Growtopia World Lock.|left|\nadd_textbox|Duration: `w[`4~`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Do not sell it to other people.|left|\nadd_smalltext|`92. `2Trying To Sell Your Gems To Other People Will Result Ban/Ipban.|left|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the Diamond Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYGEMS`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "buylvl")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPurchase Level``|left|18|\nadd_smalltext|`4Make sure to read this information clearly!``|left|\n\nadd_spacer|small|\nadd_textbox|Price: `35/20 Growtopia World Lock.|left|\nadd_textbox|Duration: `w[`4~`w]|left|\nadd_textbox|Stock: `w[`4~`w]|\nadd_spacer|small|\nadd_textbox|`9Rules:|left|\nadd_smalltext|`91. `2Trying Sell Your Account Will Result Ipban.|left|\nadd_spacer|left|\nadd_textbox|`eHow To Buy:|\nadd_smalltext|`rPlace the Diamond Locks in the Donation Box located in `6COMMANDO1234`r in normal Growtopia, write your private server name and the end add text: `w#BUYLEVEL`r, take a screenshot for proof and wait for Owner to check``|left|\nadd_spacer|small|\nadd_textbox|`eWhen will i received my purchase:|\nadd_smalltext|`rYou Will received within `424`r hours after you have made your payment.|left|\nend_dialog|gazette|Close||"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									if (btn == "collectmag") {
										if (isWorldOwner(peer, world) || world->owner == "" || adminLevel(peer) > 1) {
											int x = pinfo->wrenchedBlockLocation % world->width;
											int y = pinfo->wrenchedBlockLocation / world->width;
											if (x < 0 || y < 0) continue;

											pinfo->gems = pinfo->gems + world->magplantGems;
											Player::OnSetBux(peer, pinfo->gems, 0);
											world->magplantGems = 0;
										}

									}


									if (isStuff) {
										if (world != NULL) {
											if (stuffITEM != "") {
												int x = pinfo->wrenchedBlockLocation % world->width;
												int y = pinfo->wrenchedBlockLocation / world->width;
												if (x < 0 || y < 0) continue;
												int id = atoi(stuffITEM.c_str());
												int stuffGra = atoi(stuff_gravity.c_str());
												world->stuff_invert = stuff_invert;
												world->stuff_spin = stuff_spin;
												world->stuff_gravity = stuffGra;
												world->stuffID = atoi(stuffITEM.c_str());
												sendStuffweather(peer, x, y, world->stuffID, stuffGra, stuff_spin, stuff_invert);

											}
											else {

												int x = pinfo->wrenchedBlockLocation % world->width;
												int y = pinfo->wrenchedBlockLocation / world->width;

												if (x < 0 || y < 0) continue;

												int stuffGra = atoi(stuff_gravity.c_str());
												world->stuff_invert = stuff_invert;
												world->stuff_spin = stuff_spin;
												world->stuff_gravity = stuffGra;

												sendStuffweather(peer, x, y, world->stuffID, stuffGra, stuff_spin, stuff_invert);
											}





											int x = pinfo->wrenchedBlockLocation % world->width;
											int y = pinfo->wrenchedBlockLocation / world->width;
											if (x < 0 || y < 0) continue;
											if (world->items.at(x + (y * world->width)).activeWeather == true) {

												ENetPeer* currentPeer;

												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
														continue;
													if (isHere(peer, currentPeer))
													{

														GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), 29));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);

														enet_peer_send(currentPeer, 0, packet2);
														delete p2.data;
														continue;
													}
												}

											}

										}
									}
									if (isTrashDialog) {
										if (world == NULL || world->name == "EXIT") continue;
										int x;

										try {
											x = stoi(trashitemcount);
										}
										catch (std::invalid_argument& e) {
											Player::OnConsoleMessage(peer, "Please specify how many you want to trash");
											continue;
										}
										short int currentItemCount = 0;
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lasttrashitem)
											{
												currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
												break;
											}
										}

										if (x <= 0 || x > 200) {
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w `oThat too many or too less to `4trash`^!"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;
										}
										if (HasItemsInInv(peer, ((PlayerInfo*)(peer->data))->lasttrashitem, x) == -1)
										{
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oThat too many to trash.``"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;
										}
										if (((PlayerInfo*)(peer->data))->lasttrashitem == 18 || ((PlayerInfo*)(peer->data))->lasttrashitem == 32) {
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w`oYou can't trash this item!"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;

										}
										else {
											doCancelTrade(peer);
											RemoveItemFromInv(peer, ((PlayerInfo*)(peer->data))->lasttrashitem, x, true);
											Player::PlayAudio(peer, "audio/trash.wav", 0);
										}
									}
									if (isDropDialog) {
										if (world == NULL || world->name == "EXIT") continue;
										int x;
										int xx = ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1));
										int y = ((PlayerInfo*)(peer->data))->y / 32;
										int x1 = xx / 32;

										try {
											x = stoi(dropitemcount);
										}
										catch (std::invalid_argument& e) {
											Player::OnConsoleMessage(peer, "Please specify how many you want to drop");
											continue;
										}
										if (x < 0 || y < 0) {
											Player::OnTextOverlay(peer, "You can't drop that here, face somewhere with open space.");
										}
										else if (world->items[x1 + (y * world->width)].foreground == 6) {
											Player::OnTextOverlay(peer, "You can't drop items on the white door.");
										}
										else if (isGoodForeground(world->items[x1 + (y * world->width)].foreground)) {
											Player::OnTextOverlay(peer, "You can't drop that here, face somewhere with open space.");
										}
										else if (((PlayerInfo*)(peer->data))->isInvisible) {
											Player::OnTextOverlay(peer, "Cannot drop while invisible.");
										}
										else if (((PlayerInfo*)(peer->data))->lastdropitem == 6260 || itemDefs.at(((PlayerInfo*)(peer->data))->lastdropitem).properties & Property_Untradable || ((PlayerInfo*)(peer->data))->lastdropitem == 6336 || ((PlayerInfo*)(peer->data))->lastdropitem == 1794 || ((PlayerInfo*)(peer->data))->lastdropitem == 1486 || ((PlayerInfo*)(peer->data))->lastdropitem == 1794 || ((PlayerInfo*)(peer->data))->lastdropitem == 5640 || ((PlayerInfo*)(peer->data))->lastdropitem == 1424) {
											if (std::find(creatorname.begin(), creatorname.end(), ((PlayerInfo*)(peer->data))->rawName) != creatorname.end()) {
												doCancelTrade(peer);
												int uu = ((PlayerInfo*)(peer->data))->lastdropitem;
												if (uu != 18 && uu != 32) {
													if (world->allowDropTakeAll) {

														dropItem(world, peer, -1, ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1) + rand() % 16), ((PlayerInfo*)(peer->data))->y + rand() % 16, ((PlayerInfo*)(peer->data))->lastdropitem, x, 0);
														RemoveItemFromInv(peer, uu, x, true);
													}
													else {
														if (isWorldOwner(peer, world) || getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) >= 2) {

															dropItem(world, peer, -1, ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1) + rand() % 16), ((PlayerInfo*)(peer->data))->y + rand() % 16, ((PlayerInfo*)(peer->data))->lastdropitem, x, 0);
															RemoveItemFromInv(peer, uu, x, true);
														}
													}
												}
											} Player::OnTextOverlay(peer, "You can't drop that.");
										}
										else if (((PlayerInfo*)(peer->data))->lastdropitem == 18 || ((PlayerInfo*)(peer->data))->lastdropitem == 32) {
											Player::OnTextOverlay(peer, "You can't drop that.");
										}
										else if (x < 1 || x > 200) {
										}
										else if (HasItemsInInv(peer, ((PlayerInfo*)(peer->data))->lastdropitem, x) == -1)
										{
											Player::OnConsoleMessage(peer, "`oThat too many to drop.``");
										}
										else {
											doCancelTrade(peer);
											int uu = ((PlayerInfo*)(peer->data))->lastdropitem;
											if (uu != 18 && uu != 32) {
												if (world->allowDropTakeAll) {

													dropItem(world, peer, -1, ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1) + rand() % 16), ((PlayerInfo*)(peer->data))->y + rand() % 16, ((PlayerInfo*)(peer->data))->lastdropitem, x, 0);
													RemoveItemFromInv(peer, uu, x, true);
												}
												else {
													if (isWorldOwner(peer, world) || getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) >= 2) {

														dropItem(world, peer, -1, ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1) + rand() % 16), ((PlayerInfo*)(peer->data))->y + rand() % 16, ((PlayerInfo*)(peer->data))->lastdropitem, x, 0);
														RemoveItemFromInv(peer, uu, x, true);
													}
												}
											}
										}
									}
									if (isBG) {
										if (world != NULL) {
											if (infoDat.at(0) == "bg_pick") bgitem = infoDat.at(1);
											int id = atoi(bgitem.c_str());

											if (getItemDef(id).blockType != BlockTypes::BACKGROUND)
											{

												//  Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "You can only set background blocks to Weather Machine - Background!", true);
												continue;
												break;
											}


											int x = pinfo->wrenchedBlockLocation % world->width;
											int y = pinfo->wrenchedBlockLocation / world->width;

											if (x < 0 || y < 0) continue;

											sendBackground(peer, x, y, atoi(bgitem.c_str()));
											if (world->items.at(x + (y * world->width)).activeWeather == true) {

												ENetPeer* currentPeer;

												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
														continue;
													if (isHere(peer, currentPeer))
													{

														GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), 34));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);

														enet_peer_send(currentPeer, 0, packet2);
														delete p2.data;
														continue;
													}
												}

											}
											world->bgID = atoi(bgitem.c_str());

										}
									}

									if (btn == "backfriend") {
										if (((PlayerInfo*)(peer->data))->joinguild == true) {
											Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|`wShow Friends``|0|0|\nadd_button|CommunityHub|`wCommunity Hub|0|0|\nadd_button|ShowApprentices|`wShow Apprentices|0|0|\nadd_button|showguild|`wShow Guild Members``|0|0|\nadd_button|guildrewards|Guild Rewards``|0|0|\nadd_spacer|small|\nadd_button|backfriend2|`wBack|0|0|\nadd_quick_exit|");
										}
										else {
											Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|`wShow Friends``|0|0|\nadd_button|CommunityHub|`wCommunity Hub|0|0|\nadd_button|ShowApprentices|`wShow Apprentices|0|0|\nadd_button|createguildinfo|`wCreate Guild``|0|0|\nadd_spacer|small|\nadd_button|backfriend2|`wBack|0|0|\nadd_quick_exit|");
										}
									}
									if (btn == "addfriendrnbutton") {
										if (((PlayerInfo*)(peer->data))->haveGrowId == true) {
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) {
													if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastuser) {
														if (((PlayerInfo*)(peer->data))->lastfriend == ((PlayerInfo*)(currentPeer->data))->rawName) {
															bool exists = false;
															int count = 0;
															if (find(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), ((PlayerInfo*)(peer->data))->lastuser) != ((PlayerInfo*)(peer->data))->friendinfo.end()) {
																exists = true;
															}
															for (int i = 0; i < ((PlayerInfo*)(peer->data))->friendinfo.size(); i++) {
																count++;
															}
															if (count > 50) {
																Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "You have reached the limit of 50 friendinfo!", true);
																continue;
															}
															if (exists) {
																Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "You added this player already!", true);
																continue;
															}
															((PlayerInfo*)(peer->data))->friendinfo.push_back(((PlayerInfo*)(currentPeer->data))->rawName); //add
															((PlayerInfo*)(currentPeer->data))->friendinfo.push_back(((PlayerInfo*)(peer->data))->rawName);
															string text = "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0\n";
															BYTE* data = new BYTE[5 + text.length()];
															BYTE zero = 0;
															int type = 3;
															memcpy(data, &type, 4);
															memcpy(data + 4, text.c_str(), text.length());
															memcpy(data + 4 + text.length(), &zero, 1);
															ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
															enet_peer_send(currentPeer, 0, packet2);
															enet_peer_send(peer, 0, packet2);
															delete[] data;
															FlushPlayer(peer);
															FlushPlayer(currentPeer);
															GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ADDED: `oYou're now friends with `w" + ((PlayerInfo*)(peer->data))->rawName + "`o!"));
															ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
															enet_peer_send(currentPeer, 0, packet);
															delete p.data;
															GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ADDED: `oYou're now friends with `w" + ((PlayerInfo*)(currentPeer->data))->rawName + "`o!"));
															ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
															enet_peer_send(peer, 0, packet3);
															delete p3.data;
														}
														else {
															Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`5[`wFriend request sent to " + ((PlayerInfo*)(currentPeer->data))->tankIDName + "`5]", true);
															string text = "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0\n";
															BYTE* data = new BYTE[5 + text.length()];
															BYTE zero = 0;
															int type = 3;
															memcpy(data, &type, 4);
															memcpy(data + 4, text.c_str(), text.length());
															memcpy(data + 4 + text.length(), &zero, 1);
															ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
															enet_peer_send(currentPeer, 0, packet2);
															delete[] data;
															((PlayerInfo*)(currentPeer->data))->lastfriend = ((PlayerInfo*)(peer->data))->rawName;
															Player::OnConsoleMessage(currentPeer, "`3FRIEND REQUEST: `oYou've received a `wfriend request `ofrom `w" + ((PlayerInfo*)(peer->data))->rawName + "`o! To accept, click the `wwrench by his/her name `oand then choose `wAdd as friend`o.");
														}
													}
												}
											}
										}
									}
									if (btn == "frnoption") {
										string checkboxshit = "add_checkbox|checkbox_public|Show location to friends|0";
										if (not ((PlayerInfo*)(peer->data))->showloc) checkboxshit = "add_checkbox|checkbox_public|Show location to friends|1";
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wFriend Options``|left|1366|\n\nadd_spacer|small|\n" + checkboxshit + "\n\nadd_spacer|small|\nend_dialog|updtfrn||`oBack``|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									if (btn == "backonlinelist") {

										string onlinefrnlist = "";
										int onlinecount = 0;
										int totalcount = ((PlayerInfo*)(peer->data))->friendinfo.size();
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;

											string name = ((PlayerInfo*)(currentPeer->data))->rawName;
											if (find(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), name) != ((PlayerInfo*)(peer->data))->friendinfo.end()) {
												onlinefrnlist += "\nadd_button|onlinefrns_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + "``|0|0|";
												onlinecount++;

											}

										}
										if (totalcount == 0) {
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_label|small|`oYou currently have no friends.  That's just sad.  To make some, click a person's wrench icon, then choose `5Add as friend`o.``|left|4|\n\nadd_spacer|small|\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backfriend|Back|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
										else if (onlinecount == 0) {
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_label|small|`oNone of your friends are currently online.``|left|4|\n\nadd_spacer|small|\nadd_button|showoffline|`oShow offline``|0|0|\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backfriend|Back|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}

										else {
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|" + onlinefrnlist + "\n\nadd_spacer|small|\nadd_button|showoffline|`oShow offline``|0|0|\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backfriend|Back|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
									}
									if (btn.substr(0, 9) == "onlinegm_") {
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == btn.substr(9, cch.length() - 9 - 1)) {
												((PlayerInfo*)(peer->data))->lastgmworld = ((PlayerInfo*)(currentPeer->data))->currentWorld;
												((PlayerInfo*)(peer->data))->lastgmname = ((PlayerInfo*)(currentPeer->data))->displayName;
												((PlayerInfo*)(peer->data))->lastgm = ((PlayerInfo*)(currentPeer->data))->rawName;
												break;
											}
										}
										if (btn.substr(9, cch.length() - 9 - 1) == ((PlayerInfo*)(peer->data))->rawName) {
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|This is you!|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
										else {
											if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
												GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small| \nadd_button|removegmonline|Kick from guild|0|0|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
												ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
											}
											else {
												GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small| \nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
												ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
											}
										}
									}
									if (btn == "showoffline") {
										string onlinelist = "";
										string offlinelist = "";
										string offname = "";
										int onlinecount = 0;
										int totalcount = ((PlayerInfo*)(peer->data))->friendinfo.size();
										vector<string>offliness = ((PlayerInfo*)(peer->data))->friendinfo;

										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											string name = ((PlayerInfo*)(currentPeer->data))->rawName;

											if (find(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), name) != ((PlayerInfo*)(peer->data))->friendinfo.end()) {
												onlinelist += "\nadd_button|onlinefrns_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + "``|0|0|";
												onlinecount++;

												offliness.erase(std::remove(offliness.begin(), offliness.end(), name), offliness.end());
											}
										}
										for (std::vector<string>::const_iterator i = offliness.begin(); i != offliness.end(); ++i) {
											offname = *i;
											offlinelist += "\nadd_button|offlinefrns_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";

										}

										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_spacer|small|" + offlinelist + "\nadd_spacer|small|\n\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backonlinelist|Back``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;

									}
									if (btn == "removecon") {
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastFrn) {
												((PlayerInfo*)(peer->data))->friendinfo.erase(std::remove(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), ((PlayerInfo*)(peer->data))->lastFrn), ((PlayerInfo*)(peer->data))->friendinfo.end());
												((PlayerInfo*)(currentPeer->data))->friendinfo.erase(std::remove(((PlayerInfo*)(currentPeer->data))->friendinfo.begin(), ((PlayerInfo*)(currentPeer->data))->friendinfo.end(), ((PlayerInfo*)(peer->data))->rawName), ((PlayerInfo*)(currentPeer->data))->friendinfo.end());
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ALERT: `2" + ((PlayerInfo*)(peer->data))->displayName + " `ohas removed you as a friend."));
												ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
												break;
											}
										}
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Friend removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with `o" + ((PlayerInfo*)(peer->data))->lastFrnName + ".``|\n\nadd_spacer|small|\nadd_button||`oOK``|0|0|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									if (btn == "removeconoff") {
										((PlayerInfo*)(peer->data))->friendinfo.erase(std::remove(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), ((PlayerInfo*)(peer->data))->lastFrn), ((PlayerInfo*)(peer->data))->friendinfo.end());
										try {
											std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->lastFrn + ".json");
											if (ifff.fail()) {
												ifff.close();
												GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error! `oPlayer `5" + ((PlayerInfo*)(peer->data))->lastFrn + " `odoes not exist!"));
												ENetPacket* packet = enet_packet_create(ps.data, ps.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete ps.data;
												continue;
											}
											if (ifff.is_open()) {
											}
											json j;
											ifff >> j; //load
											ifff.close();
											vector<string> friends;

											for (int i = 0; i < j["friends"].size(); i++) {
												friends.push_back(j["friends"][i]);
											}

											friends.erase(std::remove(friends.begin(), friends.end(), ((PlayerInfo*)(peer->data))->rawName), friends.end());

											j["friends"] = friends; //edit

											std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->lastFrn + ".json"); //save
											if (!o.is_open()) {
												break;
											}

											o << j << std::endl;
											o.close();
										}
										catch (...) {
											break;
										}
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Friend removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with `o" + ((PlayerInfo*)(peer->data))->lastFrn + ".``|\n\nadd_spacer|small|\nadd_button||`oOK``|0|0|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									if (btn.substr(0, 11) == "onlinefrns_") {
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == btn.substr(11, cch.length() - 11 - 1)) {
												((PlayerInfo*)(peer->data))->lastFrnWorld = ((PlayerInfo*)(currentPeer->data))->currentWorld;
												((PlayerInfo*)(peer->data))->lastFrnName = ((PlayerInfo*)(currentPeer->data))->tankIDName;
												((PlayerInfo*)(peer->data))->lastFrn = ((PlayerInfo*)(currentPeer->data))->rawName;
												((PlayerInfo*)(peer->data))->lastLC = ((PlayerInfo*)(currentPeer->data))->showloc;
												break;
											}
										}
										if (((PlayerInfo*)(peer->data))->lastLC == true) {
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastFrnName + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastFrnName + " is `2online `onow, but has not made his/her location public to friends.|left|\nadd_spacer|small|\nadd_button|removecon|`oRemove as friend``|0|0|\nadd_button|backonlinelist|`oBack``|0|0|"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
										else {
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastFrnName + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastFrnName + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastFrnWorld + "`o.|\n\nadd_spacer|small|\nadd_button|frnwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastFrnWorld + "``|0|0|\nadd_button|msgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|removecon|`oRemove as friend``|0|0|\nadd_button|backonlinelist|`oBack``|0|0|\nadd_quick_exit|"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
									}
									if (btn == "frnwarpbutton") {
										Send_Cancel_Game(peer);
										sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
										handle_world(peer, ((PlayerInfo*)(peer->data))->lastFrnWorld);
									}
									if (btn == "msgbutton") {
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`5Message to `o" + ((PlayerInfo*)(peer->data))->lastFrnName + "|left|660|\nadd_spacer|small|\nadd_text_input|msgtest|||50|\nend_dialog|msgdia|Cancel|`5Send``|\nadd_spacer|big|\n\nadd_quick_exit|\n"));
										ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									if (btn.substr(0, 12) == "offlinefrns_") {
										((PlayerInfo*)(peer->data))->lastFrn = btn.substr(12, cch.length() - 12 - 1);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastFrn + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastFrn + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|removeconoff|`oRemove as friend``|0|0|\nadd_button|showoffline|`oBack``|0|0|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									if (btn == "lwizstep1") {
										PlayerInfo* p = (PlayerInfo*)(peer->data);
										if (p->gems < 1 && p->lquestprogress < 100001) {
											Player::OnTextOverlay(peer, "You have none to deliver!");

										}
										else if (p->gems < 100001 && p->gems != 0 && p->lquestprogress < 100001) {
											int lefttogive = 100000 - p->lquestprogress;
											int howmuchpay = 0;
											if (lefttogive > p->gems) {
												if (p->gems > 0) {
													howmuchpay = p->gems;
												}
												else {
													Player::OnTextOverlay(peer, "`4Something went wrong! Contant developer!");
													continue;

												}
											}
											else {

												howmuchpay = lefttogive;
											}
											p->lquestprogress += howmuchpay;
											Player::OnTextOverlay(peer, "Good, keep it going!");

											p->gems = p->gems - howmuchpay;
											Player::OnSetBux(peer, p->gems, 0);

											if (p->lquestprogress > 99999) {
												Player::OnTextOverlay(peer, "`9Quest step completed!!");
												Player::OnParticleEffect(peer, 48, p->x, p->y, 0);
												p->lqueststep = 2;
												p->lquestprogress = 0;
												string k = "set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Fire``|left|1790|\nadd_smalltext|(Step 2/5)|\nadd_spacer|small|\nadd_textbox|`oI want you to break 1000 blocks because why not.|\nadd_spacer|small|\nadd_smalltext|Current progress " + to_string(((PlayerInfo*)(peer->data))->lquestprogress) + "/1000|\nadd_button|lwizstep2|I will go smash more!|\nadd_button|giveup|Give up this quest|\nend_dialog|lqueststep2|Goodbye!|";
												Player::OnDialogRequest(peer, k);
											}

										}

										else {
											int remove = 100000 - p->lquestprogress;
											p->gems = p->gems - remove;
											Player::OnSetBux(peer, p->gems, 0);
											Player::OnTextOverlay(peer, "`9Quest step completed!!");
											Player::OnParticleEffect(peer, 48, p->x, p->y, 0);
											p->lqueststep = 2;
											p->lquestprogress = 0;
											string k = "set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Fire``|left|1790|\nadd_smalltext|(Step 2/5)|\nadd_spacer|small|\nadd_textbox|`oI want you to break 1000 blocks because why not.|\nadd_spacer|small|\nadd_smalltext|Current progress " + to_string(((PlayerInfo*)(peer->data))->lquestprogress) + "/1000|\nadd_button|lwizstep2|I will go smash more!|\nadd_button|giveup|Give up this quest|\nend_dialog|lqueststep2|Goodbye!|";
											Player::OnDialogRequest(peer, k);
										}
									}
									if (btn == "lwizstep2") {
										PlayerInfo* p = (PlayerInfo*)(peer->data);
										if (p->lquestprogress < 1000) {
											Player::OnTextOverlay(peer, "Go smash more!");
										}
										else {
											p->didAlready = false;
											Player::OnTextOverlay(peer, "`9Quest step complete!!");
											Player::OnParticleEffect(peer, 48, p->x, p->y, 0);
											p->lqueststep = 3;
											p->lquestprogress = 0;
											string k = "set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Fire``|left|1790|\nadd_smalltext|(Step 3/5)|\nadd_spacer|small|\nadd_textbox|`oI want you to break 100,000 worth rarity of blocks.|\nadd_spacer|small|\nadd_smalltext|Current progress " + to_string(((PlayerInfo*)(peer->data))->lquestprogress) + "/100000|\nadd_button|lwizstep3|Ill earn them!|\nadd_button|giveup|Give up this quest|\nend_dialog|lqueststep3|Goodbye!|";

											Player::OnDialogRequest(peer, k);
										}

									}
									if (btn == "lwizstep3") {
										PlayerInfo* p = (PlayerInfo*)(peer->data);
										if (p->lquestprogress < 20) {
											Player::OnTextOverlay(peer, "Go get more level!");
										}
										else {
											Player::OnTextOverlay(peer, "`9Quest step complete!!");
											Player::OnParticleEffect(peer, 48, p->x, p->y, 0);
											p->lqueststep = 4;
											p->lquestprogress = 0;
											string k = "set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Fire``|left|1790|\nadd_smalltext|(Step 4/5)|\nadd_spacer|small|\nadd_textbox|`oI want you to reach level 20.|\nadd_spacer|small|\nadd_smalltext|Current progress " + to_string(((PlayerInfo*)(peer->data))->level) + "/20|\nadd_button|lwizstep4|Aight!|\nadd_button|giveup|Give up this quest|\nend_dialog|lqueststep4|Goodbye!|";

											Player::OnDialogRequest(peer, k);
										}

									}
									if (btn == "addletter")
									{
										if (world == nullptr || ((PlayerInfo*)(peer->data))->currentWorld == "EXIT" || serverIsFrozen) continue;
										try {
											string text = "";
											string coord = "";
											if (infoDat.at(0).substr(0, 15) == "addletterinput_")
											{
												text = infoDat.at(1);
												string coord = infoDat.at(0).substr(infoDat.at(0).find("_") + 1);
												auto isdbox = std::experimental::filesystem::exists("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`4An error occured. Break the mailbox.", 0);
													break;
												}

												if (text.size() < 3)
												{
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wThats not interesting enough to mail.", 0);
													break;
												}



												ifstream ifff("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["inmail"] > 19)
												{
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`oThis mailbox already has `w20 `oletters in it.", 0);
												}
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														SendDonateData(world, currentPeer, world->items.at(((PlayerInfo*)(peer->data))->lastPunchX + (((PlayerInfo*)(peer->data))->lastPunchY * world->width)).foreground, world->items.at(((PlayerInfo*)(peer->data))->lastPunchX + (((PlayerInfo*)(peer->data))->lastPunchY * world->width)).background, ((PlayerInfo*)(peer->data))->lastPunchX, ((PlayerInfo*)(peer->data))->lastPunchY, 65);
													}
												}
												for (int i = 0; i < 20; i++)
												{
													if (j["mails"].at(i)["growid"] == "")
													{
														j["mails"].at(i)["growid"] = ((PlayerInfo*)(peer->data))->displayName;
														j["mails"].at(i)["text"] = text;
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`2You place your letter in the mailbox.", 0);
														int x = j["x"];
														int y = j["y"];
														if (j["inmail"] < 1)
														{
														}
														j["inmail"] = j["inmail"].get<double>() + 1;
														ofstream of("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + coord + ".json");
														of << j << std::endl;
														of.close();
														break;
													}
												}
											}
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
									if (btn.substr(0, 10) == "mailempty_")
									{
										if (world == nullptr || ((PlayerInfo*)(peer->data))->currentWorld == "EXIT" || serverIsFrozen) break;
										string coord = btn.substr(btn.find("_") + 1);
										auto isdbox = std::experimental::filesystem::exists("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`4An error occured while getting mailbox info.", 0);
											break;
										}
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || world->owner == "" || isDev(peer))
										{



											try {
												ifstream ifff("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();
												if (j["inmail"] < 1)
												{
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`4There is no any mails!", 0);
													break;
												}
												for (int i = 0; i < 20; i++)
												{
													j["mails"].at(i)["growid"] = "";
													j["mails"].at(i)["text"] = "";
												}
												j["inmail"] = 0;
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`2Mailbox emptied.", 0);

												int x = j["x"];
												int y = j["y"];
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														SendDonateData(world, currentPeer, world->items.at(((PlayerInfo*)(peer->data))->lastPunchX + (((PlayerInfo*)(peer->data))->lastPunchY * world->width)).foreground, world->items.at(((PlayerInfo*)(peer->data))->lastPunchX + (((PlayerInfo*)(peer->data))->lastPunchY * world->width)).background, ((PlayerInfo*)(peer->data))->lastPunchX, ((PlayerInfo*)(peer->data))->lastPunchY, 0);
													}
												}
												ofstream of("mailbox/_" + ((PlayerInfo*)(peer->data))->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
											catch (std::exception& e) {
												std::cout << e.what() << std::endl;
											}
											catch (const std::out_of_range& e) {
												std::cout << e.what() << std::endl;
											}
										}
									}
									if (btn == "startfire") {
										string confirm = "set_default_color|`o\nadd_label_with_icon|big|`9Quest Of Fire``|left|1790|\nadd_smalltext|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks, or months of time, and possibly your friends and family.|\nadd_smalltext|`oEvery quest has 5 steps to complete, and each step alone is probably more than most Growtopians could manage.|\nadd_smalltext|`oBut the rewards are also vast. If you complete this quest, you will earn the `9Legendary Dragon`o! These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete quest.|\nadd_smalltext|`oYou may turn in your quests at any Legendary Wizard you have access to (we're in a union), but I will vanish permamently if somebody turns in their final quest step to me, so don't let other people have access to me!|\nadd_smalltext|`oThere's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it trough to the end!|\nadd_spacer|small|\nadd_textbox|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For The Fire|\nend_dialog|lquestconfirm|No!|Yes!|";
										Player::OnDialogRequest(peer, confirm);
									}
									if (btn == "floatingitems") {

										string additems = "";

										for (int i = 0; i < world->droppedItems.size(); i++)
										{
											//if (world->droppedItems.at(i).uid)
											int id = world->droppedItems.at(i).id;
											additems += "\nadd_label_with_icon_button||`w" + getItemDef(id).name + ": " + to_string(world->droppedItems.at(i).count) + "|left|" + to_string(world->droppedItems.at(i).id) + "|item" + to_string(id) + "|";
										}

										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Items``|left|6016|\nadd_spacer|small|\nadd_textbox|`oPress on the icon to be directed to the location of the item.|\nadd_spacer|small|" + additems + "\nadd_spacer|small|\nadd_button|goback|Back|\nend_dialog|growscan_float|||\n");

									}


									if (isGuildDialog) {
										if (world == nullptr || world->name == "EXIT") continue;
										int GCState = PlayerDB::guildRegister(peer, guildName, guildStatement, guildFlagFg, guildFlagBg);
										if (GCState == -1) {
											Player::OnConsoleMessage(peer, "`4Oops! `oGuild creation has failed, because special characters isnt allowed!``");
											continue;
										}
										else if (GCState == -2) {
											Player::OnConsoleMessage(peer, "`4Oops! `oGuild creation has failed, because guild name is too short!``");
											continue;
										}
										else if (GCState == -3) {
											Player::OnConsoleMessage(peer, "`4Oops! `oGuild creation has failed, because guild name is too long!``");
											continue;
										}
										else if (GCState == -4) {
											Player::OnConsoleMessage(peer, "`4Oops! `oGuild creation has failed, because the guild name is already taken!``");
											continue;
										}
										else if (GCState == -5) {
											Player::OnConsoleMessage(peer, "`4Oops! `oGuild creation has failed, because the background block must be a number!``");
											continue;
										}
										if (GCState == -6) {
											Player::OnConsoleMessage(peer, "`4Oops! `oGuild creation has failed, because the foreground block must be a number!``");
											continue;
										}
										else if (GCState == -7) {
											Player::OnConsoleMessage(peer, "`4Oops! `oGuild creation has failed, because the background id is too long!``");
									        continue;
										}
										if (GCState == -8) {
											Player::OnConsoleMessage(peer, "`4Oops! `oGuild creation has failed, because the foreground id is too long!``");
								        	continue;
										}
										if (world->ownerID != ((PlayerInfo*)(peer->data))->userID) {
											Player::OnConsoleMessage(peer, "`4Oops! `oYou must make guild in world you owned!``");
										}
										else {
											if (GCState == 1) {
												((PlayerInfo*)(peer->data))->createGuildName = guildName;
												((PlayerInfo*)(peer->data))->createGuildStatement = guildStatement;
												((PlayerInfo*)(peer->data))->createGuildFlagBg = guildFlagBg;
												((PlayerInfo*)(peer->data))->createGuildFlagFg = guildFlagFg;
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild|left|5814|\nadd_textbox|`1Guild Name: `o" + guildName + "``|\nadd_textbox|`1Guild Statement: `o" + guildStatement + "``|\nadd_label_with_icon|small|`1<-Guild Flag Background``|left|" + guildFlagBg + "|\nadd_label_with_icon|small|`1<-Guild Flag Foreground``|left|" + guildFlagFg + "|\n\nadd_spacer|small|\nadd_textbox|`oCost: `4250,000 Gems``|\n\nadd_spacer|small|\nadd_button|confirmcreateguild|`oCreate Guild``|\nend_dialog||`wCancel``||\n");
											}
										}
									}

									if (isHeatWave) {
										if (world != NULL) {

											world->weather = 28;
											ENetPeer* currentPeer;

											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer))
												{

													GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);

													enet_peer_send(currentPeer, 0, packet2);
													delete p2.data;
													continue;
												}
											}

											int x = pinfo->wrenchedBlockLocation % world->width;
											int y = pinfo->wrenchedBlockLocation / world->width;

											if (x < 0 || y < 0) continue;

											sendHeatwave(peer, x, y, r, g, b);
											world->hw_red = r;
											world->hw_green = g;
											world->hw_blue = b;
										}
									}



									if (signEditor) {
										if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1) {
											PlayerInfo* pinfo = (PlayerInfo*)(peer->data);

											world->items[pinfo->wrenchedBlockLocation].sign = message;



											int x = pinfo->wrenchedBlockLocation % world->width;
											int y = pinfo->wrenchedBlockLocation / world->width;

											if (x < 0 || y < 0) continue;

											if (itemDefs.at(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::Mannequin) {
												ifstream fs("mannequin/" + pinfo->currentWorld + "/X" + std::to_string(x + (y * 100)) + ".json");
												json j;
												fs >> j;
												fs.close();
												for (auto currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) updateMannequin(world, currentPeer, x, y, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, message, atoi(j["clothHead"].get<string>().c_str()), atoi(j["clothShirt"].get<string>().c_str()), atoi(j["clothPants"].get<string>().c_str()), atoi(j["clothFeet"].get<string>().c_str()), atoi(j["clothMask"].get<string>().c_str()), atoi(j["clothHand"].get<string>().c_str()), atoi(j["clothBack"].get<string>().c_str()), atoi(j["clothHair"].get<string>().c_str()), atoi(j["clothNeck"].get<string>().c_str()));
												}
											}
											else {
												UpdateVisualsForBlock(peer, true, x, y, world, true, message);
											}
										}

									}
								}

							}

							if (isTradeDialog) {
								if (counttodo == -1 || itemtodo == -1) continue;
								PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
								if (!pinfo->isTrading) continue;
								if (HasItemsInInv(peer, itemtodo, counttodo) == -1) continue;
								if (pinfo->tradeItems.size() >= 4) continue;

								for (int i = 0; i < pinfo->tradeItems.size(); i++)
								{
									if (pinfo->tradeItems.at(i).id == itemtodo)
									{
										pinfo->tradeItems.erase(pinfo->tradeItems.begin() + i);
										break;
									}
								}
								UpdateTradeStatus(peer, pinfo->isTradingWithUserID, true);
								TradeItem trdItem = { itemtodo, counttodo };
								pinfo->tradeItems.push_back(trdItem);
								UpdateTradeStatus(peer, pinfo->isTradingWithUserID, 1);
								break;
							}
							if (isFinishTrade) {
								try {
									if (!world || world->name == "EXIT") continue;
									PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
									if (!pinfo) continue;
									if (!pinfo->isTrading) continue;
									if (!pinfo->isInFinalTradeDialog) continue;
									ENetPeer* peer2 = NULL;
									PlayerInfo* pinfo2 = NULL;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (isHere(peer, currentPeer)) {
											if (pinfo->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
												pinfo2 = (PlayerInfo*)(currentPeer->data);
												peer2 = currentPeer;
												break;
											}
										}
									}
									if (peer2 == NULL) break;
									if (pinfo2 == NULL) break;
									if (pinfo == NULL) break;
									if (btn == "dothetrade")
									{
										pinfo->acceptedFinalDialog = true;
									}
									else
									{
										pinfo->acceptedFinalDialog = false;
										pinfo->isTrading = false;
										pinfo->isWaitingForTrade = false;
										pinfo->isWaitingForTradeWithUserID = 0;
									}
									if (pinfo->acceptedFinalDialog)
									{
										Player::OnTalkBubble(peer2, pinfo2->netID, "`o[`wTrade accepted by other player, waiting for you`o]``", 0);
									}
									else
									{
										Player::OnTextOverlay(peer2, "Trade was not accepted by other player, cancelling.");
										pinfo->isTrading = false;
										pinfo->isWaitingForTrade = false;
										pinfo->isInFinalTradeDialog = false;
										pinfo->isAcceptingTrade = false;
										pinfo->acceptedFinalDialog = false;
										pinfo2->isTrading = false;
										pinfo2->isWaitingForTrade = false;
										pinfo2->isInFinalTradeDialog = false;
										pinfo2->isAcceptingTrade = false;
										pinfo2->acceptedFinalDialog = false;
									}
									if (pinfo2->acceptedFinalDialog && pinfo->acceptedFinalDialog) {

										if (!pinfo->isInFinalTradeDialog) break;
										int duration = 500;
										for (auto& f : pinfo->tradeItems)
										{
											RemoveItemFromInv(peer, f.id, f.count, true);
											AddItemToInv(world, peer2, f.id, f.count);
											ENetPeer* currentPeer;

											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) {
													Player::PlayAudio(currentPeer, "audio/change_clothes.wav", duration);
													SendTradeEffect(currentPeer, f.id, pinfo->netID, pinfo2->netID, duration);
												}
											}
											duration += 500;
										}
										for (auto& f : pinfo2->tradeItems)
										{
											auto Success = false;
											RemoveItemFromInv(peer2, f.id, f.count, true);
											AddItemToInv(world, peer, f.id, f.count);
											ENetPeer* currentPeer;

											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
													continue;
												if (isHere(peer, currentPeer)) {
													Player::PlayAudio(currentPeer, "audio/change_clothes.wav", duration);
													SendTradeEffect(currentPeer, f.id, pinfo2->netID, pinfo->netID, duration);

												}
											}
											duration += 500;
										}
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (isHere(peer, currentPeer)) Player::PlayAudio(currentPeer, "audio/keypad_hit.wav", duration + 100);
										}
										SendWebhook("" + currentDateTime() + " " + pinfo->displayName + " traded " + FormatTradeItemsForMessage(pinfo->tradeItems) + " to " + pinfo2->displayName + ".", "TRADE");
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`1" + pinfo->displayName + "`1 traded " + FormatTradeItemsForMessage(pinfo->tradeItems) + " to " + pinfo2->displayName + "`1."));
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`1" + pinfo2->displayName + "`1 traded " + FormatTradeItemsForMessage(pinfo2->tradeItems) + " to " + pinfo->displayName + "`1."));
										SendGamePacketEveryoneInWorld(peer, &p);
										SendGamePacketEveryoneInWorld(peer, &p2);

										pinfo->isTrading = false;
										pinfo->isWaitingForTrade = false;
										pinfo->isInFinalTradeDialog = false;
										pinfo->isAcceptingTrade = false;
										pinfo->acceptedFinalDialog = false;
										pinfo->isTradingWithUserID = 0;
										pinfo2->isTradingWithUserID = 0;
										pinfo->isWaitingForTradeWithUserID = 0;
										pinfo2->isWaitingForTradeWithUserID = 0;
										pinfo2->isTrading = false;
										pinfo2->isWaitingForTrade = false;
										pinfo2->isInFinalTradeDialog = false;
										pinfo2->isAcceptingTrade = false;
										pinfo2->acceptedFinalDialog = false;
									}
								}
								catch (...) {
									continue;
								}
							}
							if (bansubmit)
							{
								if (reason.size() < 3)
								{
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`1Punish player``|left|1432|\n\nadd_spacer|small|\nadd_textbox|`4Reason should not be empty!|\n\nadd_spacer|small|\nend_dialog|vloseokk|Close||");
								}
								else if (day1 == "1")
								{
									ofstream savebantime("punishment/bans/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->banName) + ".txt");
									savebantime << (GetCurrentTimeInternalSeconds() + (1440 * 60)) << endl;
									savebantime << ((PlayerInfo*)(peer->data))->rawName << endl;
									savebantime << reason << endl;
									savebantime.close();
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave used `#Ban `oon `2" + ((PlayerInfo*)(peer->data))->banName + " `4for `51 days`o! `#**");
										if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(((PlayerInfo*)(peer->data))->banName))
										{
											Player::OnConsoleMessage(currentPeer, "`$Reality flickers as you begin to wake up. (Ban mod added 1 days left)");
											Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4BANNED from `0Growtopia `4for 1 days", "audio/hub_open.wav", "interface/atomic_button.rttex");
											Player::OnConsoleMessage(currentPeer, "`0Warning from `4System`0: You've been `4BANNED from `0Growtopia `4for 1 days");
											enet_peer_disconnect_later(currentPeer, 0);
											break;
										}
									}
									SendWebhook(currentDateTime() + " Player " + ((PlayerInfo*)(peer->data))->rawName + " BANNED " + ((PlayerInfo*)(peer->data))->banName + " Reason: " + reason + ", For: " + OutputBanTime(calcBanDuration((GetCurrentTimeInternalSeconds() + (1440 * 60)))), "BAN_LOGS");
								}
								else if (day7 == "1")
								{
									ofstream savebantime("punishment/bans/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->banName) + ".txt");
									savebantime << (GetCurrentTimeInternalSeconds() + (10080 * 60)) << endl;
									savebantime << ((PlayerInfo*)(peer->data))->rawName << endl;
									savebantime << reason << endl;
									savebantime.close();
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave used `#Ban `oon `2" + ((PlayerInfo*)(peer->data))->banName + " `4for `57 days`o! `#**");
										if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(((PlayerInfo*)(peer->data))->banName))
										{
											Player::OnConsoleMessage(currentPeer, "`$Reality flickers as you begin to wake up. (Ban mod added 7 days left)");
											Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4BANNED from `0Growtopia `4for 7 days", "audio/hub_open.wav", "interface/atomic_button.rttex");
											Player::OnConsoleMessage(currentPeer, "`0Warning from `4System`0: You've been `4BANNED from `0Growtopia `4for 7 days");
											enet_peer_disconnect_later(currentPeer, 0);
											break;
										}
									}
									SendWebhook(currentDateTime() + " Player " + ((PlayerInfo*)(peer->data))->rawName + " BANNED " + ((PlayerInfo*)(peer->data))->banName + " Reason: " + reason + ", For: " + OutputBanTime(calcBanDuration((GetCurrentTimeInternalSeconds() + (10080 * 60)))), "BAN_LOGS");
								}
								else if (day31 == "1")
								{
									ofstream savebantime("punishment/bans/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->banName) + ".txt");
									savebantime << (GetCurrentTimeInternalSeconds() + (44640 * 60)) << endl;
									savebantime << ((PlayerInfo*)(peer->data))->rawName << endl;
									savebantime << reason << endl;
									savebantime.close();
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave used `#Ban `oon `2" + ((PlayerInfo*)(peer->data))->banName + " `4for `531 days`o! `#**");
										if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(((PlayerInfo*)(peer->data))->banName))
										{
											Player::OnConsoleMessage(currentPeer, "`$Reality flickers as you begin to wake up. (Ban mod added 31 days left)");
											Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4BANNED from `0Growtopia `4for 31 days", "audio/hub_open.wav", "interface/atomic_button.rttex");
											Player::OnConsoleMessage(currentPeer, "`0Warning from `4System`0: You've been `4BANNED from `0Growtopia `4for 31 days");
											enet_peer_disconnect_later(currentPeer, 0);
											break;
										}
									}
									SendWebhook(currentDateTime() + " Player " + ((PlayerInfo*)(peer->data))->rawName + " BANNED " + ((PlayerInfo*)(peer->data))->banName + " Reason: " + reason + ", For: " + OutputBanTime(calcBanDuration((GetCurrentTimeInternalSeconds() + (44640 * 60)))), "BAN_LOGS");
								}
								else if (forever == "1")
								{
									ofstream savebantime("punishment/bans/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->banName) + ".txt");
									savebantime << (GetCurrentTimeInternalSeconds() + (1051200 * 60)) << endl;
									savebantime << ((PlayerInfo*)(peer->data))->rawName << endl;
									savebantime << reason << endl;
									savebantime.close();
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave used `#Ban `oon `2" + ((PlayerInfo*)(peer->data))->banName + " `4for `5730 days`o! `#**");
										if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(((PlayerInfo*)(peer->data))->banName))
										{
											Player::OnConsoleMessage(currentPeer, "`$Reality flickers as you begin to wake up. (Ban mod added 730 days left)");
											Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4BANNED from `0Growtopia `4for 730 days", "audio/hub_open.wav", "interface/atomic_button.rttex");
											Player::OnConsoleMessage(currentPeer, "`0Warning from `4System`0: You've been `4BANNED from `0Growtopia `4for 730 days");
											enet_peer_disconnect_later(currentPeer, 0);
											break;
										}
									}
									SendWebhook(currentDateTime() + " Player " + ((PlayerInfo*)(peer->data))->rawName + " BANNED " + ((PlayerInfo*)(peer->data))->banName + " Reason: " + reason + ", For: " + OutputBanTime(calcBanDuration((GetCurrentTimeInternalSeconds() + (1051200 * 60)))), "BAN_LOGS");
								}
							}
							if (isFindDialog && btn.substr(0, 4) == "tool") {
								if (!isMod(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass))
									continue;
								int Id = atoi(btn.substr(4, btn.length() - 4).c_str());
								int intid = atoi(btn.substr(4, btn.length() - 4).c_str());
								string ide = btn.substr(4, btn.length() - 4).c_str();
								size_t invsize = 260;
								AddItemToInv(world, peer, intid, 200, false);
								if (((PlayerInfo*)(peer->data))->inventory.items.size() == invsize) {

									if (getItemDef(intid).rarity == 999) {
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oGiven`w 200 " + getItemDef(intid).name + "`o. Item ID: `w" + ide + "`o."));

										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									else {
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oGiven`w 200 " + getItemDef(intid).name + "`o. Rarity `w" + std::to_string(getItemDef(intid).rarity) + "`o. Item ID: `w" + ide + "`o."));

										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									int netID = ((PlayerInfo*)(peer->data))->netID;
									SendTradeEffect(peer, intid, netID, netID, 150);

								}
								else {
									if (getItemDef(intid).rarity == 999) {
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oGiven`w 200 " + getItemDef(intid).name + "`o. Item ID: `w" + ide + "`o."));

										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									else {
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oGiven`w 200 " + getItemDef(intid).name + "`o. Rarity `w" + std::to_string(getItemDef(intid).rarity) + "`o. Item ID: `w" + ide + "`o."));

										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									int netID = ((PlayerInfo*)(peer->data))->netID;


								}
							}

							else if (isFindDialog) {
								string itemLower2;
								vector<ItemDefinition> itemDefsfind;
								for (char c : itemFind) if (c < 0x20 || c>0x7A) goto SKIPFind;
								if (itemFind.length() < 3) goto SKIPFind3;
								for (const ItemDefinition& item : itemDefs)
								{
									string itemLower;
									for (char c : item.name) if (c < 0x20 || c>0x7A) goto SKIPFind2;
									if (!(item.id % 2 == 0)) goto SKIPFind2;
									//if (item.rarity == 999)
									if (((PlayerInfo*)(peer->data))->adminLevel == 1 && itemDefs.at(item.id).blockType != BlockTypes::FOREGROUND) goto SKIPFind2;
									if (item.id == 112 || item.id == 9640) goto SKIPFind2;
									itemLower2 = item.name;
									std::transform(itemLower2.begin(), itemLower2.end(), itemLower2.begin(), ::tolower);
									if (itemLower2.find(itemLower) != std::string::npos) {
										itemDefsfind.push_back(item);
									}
								SKIPFind2:;
								}
							SKIPFind3:;
								string listMiddle = "";
								string listFull = "";

								for (const ItemDefinition& item : itemDefsfind)
								{
									string kys = item.name;
									std::transform(kys.begin(), kys.end(), kys.begin(), ::tolower);
									string kms = itemFind;
									std::transform(kms.begin(), kms.end(), kms.begin(), ::tolower);
									if (kys.find(kms) != std::string::npos)
										listMiddle += "add_button_with_icon|tool" + to_string(item.id) + "|`$" + item.name + "``|left|" + to_string(item.id) + "||\n";
								}
								if (itemFind.length() < 3) {
									listFull = "add_textbox|`4Word is less then 3 letters!``|\nadd_spacer|small|\n";
									showWrong(peer, listFull, itemFind);
								}
								else if (itemDefsfind.size() == 0) {
									//listFull = "add_textbox|`4Found no item match!``|\nadd_spacer|small|\n";
									showWrong(peer, listFull, itemFind);

								}
								else {
									GamePacket fff = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wFound item : " + itemFind + "``|left|6016|\nadd_spacer|small|\nadd_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||20|\nend_dialog|findid|Cancel|Find the item!|\nadd_spacer|big|\n" + listMiddle + "add_quick_exit|\n"));
									ENetPacket* packetd = enet_packet_create(fff.data,
										fff.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packetd);

									//enet_host_flush(server);
									delete fff.data;
								}
							}
						SKIPFind:;
							if (sdbsend) {
								auto pData = (PlayerInfo*)peer->data;
								if (pData->gems < 1000000)
								{
									Player::OnTextOverlay(peer, "You need `w" + std::to_string(1000000 - pData->gems) + "`o gems more..");
									continue;
								}
								((PlayerInfo*)(peer->data))->gems = ((PlayerInfo*)(peer->data))->gems - 1000000;
								Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
								worldas_ = ((PlayerInfo*)(peer->data))->currentWorld;
								string dialoh = "", dialo8 = "";
								if (text2 != "" || text2 == " " || text2 == "  " || text2 == "   " || text2 == "    ") {
									dialoh = "\nadd_textbox|" + text2 + "|left|";
								}
								if (text3 != "" || text3 == " " || text3 == "  " || text3 == "   " || text3 == "    ") {
									dialo8 = "\nadd_textbox|" + text3 + "|left|";
								}
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
										continue;
									if (!((PlayerInfo*)(currentPeer->data))->radio)
										continue;
									Player::OnDialogRequest(currentPeer, "set_default_color|`o\nadd_label_with_icon|big|`2Broadcast from " + ((PlayerInfo*)(peer->data))->displayName + " ``|left|2480|\nadd_smalltext|(In world " + ((PlayerInfo*)(peer->data))->currentWorld + ")|left|\nembed_data|worldname|\nadd_spacer|small|\nadd_textbox|" + text1 + "|left|" + dialoh + dialo8 + "\nend_dialog|sdbrespond|Cancel|GO!|");
									Player::PlayAudio(currentPeer, "audio/beep.wav", 0);
								}
							}
#ifdef REGISTRATION
							if (PinDialog) {
								if (not ((PlayerInfo*)(peer->data))->haveGrowId) {
									Player::OnConsoleMessage(peer, "`4Oops! `oYou doesn't have growid!");
								}
								else if (newpin.find_first_not_of("0123456789") != string::npos || verifynewpin.find_first_not_of("0123456789") != string::npos) {
									Player::OnConsoleMessage(peer, "`4Oops! `oSymbols isnt allowed!");
								}
								else if (newpin != verifynewpin) {
									Player::OnConsoleMessage(peer, "`4Oops! `oThe Two new pin you entered does not match!");
								}
								else if (newpin.length() != 4) {
									Player::OnConsoleMessage(peer, "`4Oops!`` `oYour PIN must be 4 digits.");
								}
								else {
									try {
										((PlayerInfo*)(peer->data))->pin = verifynewpin;
										std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
										json j;
										ifff >> j;
										ifff.close();

										j["pin"] = ((PlayerInfo*)(peer->data))->pin;
										std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
										o << j << std::endl;
										o.close();

										Player::OnAddNotification(peer, "`0Warning from `4System`0: Set pin has been successfully saved! disconnected you one..", "audio/hub_open.wav", "interface/atomic_button.rttex");
										Player::OnConsoleMessage(peer, "`0Warning from `4System`0: Set pin has been successfully saved! disconnected you one..");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (exception& p) {
										std::cout << p.what() << endl;
									}
								}
							}
							if (ChangePass) {
								if (not ((PlayerInfo*)(peer->data))->haveGrowId) break;
								if (((PlayerInfo*)(peer->data))->tankIDPass != oldpass) {
									Player::OnConsoleMessage(peer, "`4Oops! `oThe current password you have entered is incorrect!");
								}
								else if (password2 != password2verify) {
									Player::OnConsoleMessage(peer, "`4Oops! `oThe Two new password you entered does not match!");
								}
								else if (password2.length() < 8 || password2.length() > 18) {
									Player::OnConsoleMessage(peer, "`4Oops!``  The password must be between `$8`` and `$18`` characters long.");
								}
								else {
									try {
										((PlayerInfo*)(peer->data))->tankIDPass = password2;
										std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
										json j;
										ifff >> j;
										ifff.close();

										j["password"] = ((PlayerInfo*)(peer->data))->tankIDPass;
										std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
										o << j << std::endl;
										o.close();

										GamePacket p3 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), ((PlayerInfo*)(peer->data))->rawName), password2));
										ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet3);
										delete p3.data;
										Player::OnAddNotification(peer, "`0Warning from `4System`0: Your password has been changed!", "audio/hub_open.wav", "interface/atomic_button.rttex");
										Player::OnConsoleMessage(peer, "`0Warning from `4System`0: Your password has been changed!");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (exception& p) {
										std::cout << p.what() << endl;
									}
								}
							}
							if (pindialog2) {
								if (((PlayerInfo*)(peer->data))->pin == "") break;
								if (((PlayerInfo*)(peer->data))->pin != pinenter) {
									((PlayerInfo*)(peer->data))->wrong_onto_something++;
									if (((PlayerInfo*)(peer->data))->wrong_onto_something >= 2) {
										Player::OnConsoleMessage(peer, "You have wrong two times! Disconnecting...");
										enet_peer_disconnect_later(peer, 0);
									}
									else {
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w2-Step Verification|left|1424|\nadd_spacer|small|\nadd_textbox|`4Oops! `oThe pin you have entered is inncorect, try again!````|left|\nadd_textbox|`oPlease enter your PIN to confirm that you want to `4disable `w2-Step Verification`o.``|\nadd_text_input|pinenter|`$PIN``||4|\nend_dialog|pin2||`wConfirm!``|");
									}
								}
								else {
									((PlayerInfo*)(peer->data))->pin = "";
									Player::OnConsoleMessage(peer, "Disable pin has successfully! disconnecting..");
									enet_peer_disconnect_later(peer, 0);
								}
							}
							if (pindialog) {
								if (((PlayerInfo*)(peer->data))->pin == "") break;
								if (((PlayerInfo*)(peer->data))->pin != pinenter) {
									((PlayerInfo*)(peer->data))->wrong_onto_something++;
									if (((PlayerInfo*)(peer->data))->wrong_onto_something >= 2) {
										Player::OnConsoleMessage(peer, "You have wrong two times! Disconnecting...");
										enet_peer_disconnect_later(peer, 0);
									}
									else {
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w2-Step Verification|left|1424|\nadd_spacer|small|\nadd_textbox|`4Oops! `oThe pin you have entered is inncorect, try again!````|left|\nadd_text_input|pinenter|`$PIN``||4|\nend_dialog|pin||`wConfirm!``|");
									}
								}
								else {
									((PlayerInfo*)(peer->data))->registerverify = true;
									sendGazette(peer);
								}
							}
							if (isRegisterDialog) {
								if (((PlayerInfo*)(peer->data))->haveGrowId) break; // fix crticial account spam exploit
								int regState = PlayerDB::playerRegister(peer, username, password, passwordverify, email);
								if (regState == 1) {
									SendWebhook(currentDateTime() + " New Account with username: " + username + " IP: " + ((PlayerInfo*)(peer->data))->charIP + ", RID: " + ((PlayerInfo*)(peer->data))->rid + ", MAC: " + ((PlayerInfo*)(peer->data))->mac, "ACCOUNT_LOGS");
									((PlayerInfo*)(peer->data))->tankIDName = username;
									((PlayerInfo*)(peer->data))->rawName = PlayerDB::getProperName(username);
									((PlayerInfo*)(peer->data))->displayName = username;
									((PlayerInfo*)(peer->data))->backupName = username;
									((PlayerInfo*)(peer->data))->tankIDPass = password;
									GamePacket p2 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), ((PlayerInfo*)(peer->data))->displayName), password));
									ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									Player::PlayAudio(peer, "audio/spell1.wav", 0);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrowID GET!``|left|18|\nadd_label|small|`wGrowID ``with the log on of `w" + username + " ``and the password of `w" + password + " ``created. Write them down, they will be required to log on from now on!|left|4|\nadd_spacer|small||\nadd_button|cntn|`wContinue.|NOFLAGS||0|0|\nend_dialog|kekeShop1|||\n"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									Player::OnAddNotification(peer, "`0Warning from `4System`0: You received a gift for being a `2Newbie`0!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									((PlayerInfo*)(peer->data))->haveGrowId = true;
									((PlayerInfo*)(peer->data))->gems = 200000;
									FlushPlayer(peer);
								}
								else if (regState == -1) {
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|`4Oops! `othe name `w" + username + " `ois so cool someone else has already taken it. Please choose a different name.|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID|" + username + "|30|\nadd_text_input|password|Password|" + password + "|100|\nadd_text_input|passwordverify|Password Verify|" + passwordverify + "|100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email|" + email + "|100|\nend_dialog|register|Cancel|Get My GrowID!|\n");
								}
								else if (regState == -2) {
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|`4Oops! `oYour `wGrowID `omust be between `$3 `oand `$18 `ocharacters long.|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID|" + username + "|30|\nadd_text_input|password|Password|" + password + "|100|\nadd_text_input|passwordverify|Password Verify|" + passwordverify + "|100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email|" + email + "|100|\nend_dialog|register|Cancel|Get My GrowID!|\n");
								}
								else if (regState == -3) {
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|`4Oops! `oThe Two new password you entered does not match!|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID|" + username + "|30|\nadd_text_input|password|Password|" + password + "|100|\nadd_text_input|passwordverify|Password Verify|" + passwordverify + "|100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email|" + email + "|100|\nend_dialog|register|Cancel|Get My GrowID!|\n");
								}
								else if (regState == -4) {
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|`4Oops!``  Look, if you'd like to be able try retrieve your password if you lose it, you'd better enter a real email.  We promise to keep your data 100% private and never spam you.|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID|" + username + "|30|\nadd_text_input|password|Password|" + password + "|100|\nadd_text_input|passwordverify|Password Verify|" + passwordverify + "|100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email|" + email + "|100|\nend_dialog|register|Cancel|Get My GrowID!|\n");
								}
								else if (regState == -5) {
								}
								else if (regState == -6) {
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|`4Oops! `wYou've reached the max `5GrowID`w accounts you can make for this device or IP address!``|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID|" + username + "|30|\nadd_text_input|password|Password|" + password + "|100|\nadd_text_input|passwordverify|Password Verify|" + passwordverify + "|100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email|" + email + "|100|\nend_dialog|register|Cancel|Get My GrowID!|\n");
								}
								else if (regState == -7) {
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|`4Oops!``  Your password must be between `$8`` and `$18`` characters long.|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID|" + username + "|30|\nadd_text_input|password|Password|" + password + "|100|\nadd_text_input|passwordverify|Password Verify|" + passwordverify + "|100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email|" + email + "|100|\nend_dialog|register|Cancel|Get My GrowID!|\n");
								}
							}
#endif
						}
						catch (const std::out_of_range& p) {
							std::cerr << "Error in action|dialog_return >>" << p.what() << std::endl;
						}
						catch (const std::exception& p) {
							std::cerr << "Error in action|dialog_return >>" << p.what() << std::endl;
						}
					}
					string trashText = "action|trash\n|itemID|"; // drop funkcianalumas
					if (cch.find(trashText) == 0)
					{
						if (!world || world->name == "EXIT") continue;
						int idx = atoi(explode("\n", explode("|", cch).at(3)).at(0).c_str());
						((PlayerInfo*)(peer->data))->lasttrashitem = idx;
						short int currentItemCount = 0;
						for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
						{
							if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == idx)
							{
								currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
								break;
							}
						}
						if (idx == -1) continue;
						if (itemDefs.size() < idx || idx < 0) continue;
						if (((PlayerInfo*)(peer->data))->lasttrashitem == 18 || ((PlayerInfo*)(peer->data))->lasttrashitem == 32) {
							Player::OnTextOverlay(peer, "You can't trash that.");
							continue;
						}
						else {
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wTrash " + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to `4Trash`o? (you have " + to_string(currentItemCount) + ")``|\nadd_text_input|trashitemcount||" + to_string(currentItemCount) + "|3|\nend_dialog|trashdialog|Cancel|Ok|\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							doCancelTrade(peer);
						}
					}
					string dropText = "action|drop\n|itemID|";
					if (cch.find(dropText) == 0)
					{
						if (!world || world->name == "EXIT") continue;
						string itemd = cch.substr(dropText.length(), cch.length() - dropText.length() - 1);
						if (has_only_digits(itemd)) {
							int item = atoi(itemd.c_str());
							int x = ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1));
							int y = ((PlayerInfo*)(peer->data))->y / 32;
							int x1 = x / 32;
							if (x < 0 || y < 0) {
								Player::OnTextOverlay(peer, "You can't drop that here, face somewhere with open space.");
							}
							else if (world->items[x1 + (y * world->width)].foreground == 6) {
								Player::OnTextOverlay(peer, "You can't drop items on the white door.");
							}
							else if (isGoodForeground(world->items[x1 + (y * world->width)].foreground)) {
								Player::OnTextOverlay(peer, "You can't drop that here, face somewhere with open space.");
							}
							else if (((PlayerInfo*)(peer->data))->isInvisible) {
								Player::OnTextOverlay(peer, "Cannot drop while invisible.");
							}
							else if (item == 6260 || itemDefs.at(item).properties & Property_Untradable || item == 6336 || item == 1794 || item == 1486 || item == 1794 || item == 5640 || item == 1424) {
								if (std::find(creatorname.begin(), creatorname.end(), ((PlayerInfo*)(peer->data))->rawName) != creatorname.end()) {
									int idx = atoi(itemd.c_str());
									((PlayerInfo*)(peer->data))->lastdropitem = idx;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wDrop " + getItemDef(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to drop?|\nadd_text_input|amount|||3|\nend_dialog|dropdialog|Cancel|Ok|\n"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									doCancelTrade(peer);
									continue;
								} Player::OnTextOverlay(peer, "You can't drop that.");
							}
							else if (item == 18 || item == 32) {
								Player::OnTextOverlay(peer, "You can't drop that.");
							}
							else {
								try {
									int idx = atoi(itemd.c_str());
									((PlayerInfo*)(peer->data))->lastdropitem = idx;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wDrop " + getItemDef(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to drop?|\nadd_text_input|amount|||3|\nend_dialog|dropdialog|Cancel|Ok|\n"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									doCancelTrade(peer);
								}
								catch (std::exception& e) {
									std::cout << e.what() << std::endl;
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
							}
						}
					}
					if (cch.find("text|") != std::string::npos) {
						try {
							PlayerInfo* pData = (PlayerInfo*)peer->data;
							if (pData->lastChat + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
								pData->lastChat = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
							else {
								pData->chatwarn++;
								if (pData->chatwarn >= 6) {
									Player::OnConsoleMessage(peer, "`6>> `4Spam detected!`6 Please wait a bit before typing anything else. Please note, any form of bot/macro/auto-paste will get all your accounts banned, so don't do it!");
									pData->chatwarn = 0;
									pData->warncheck2++;
									continue;
								}
							}
							string str = cch.substr(cch.find("text|") + 5, cch.length() - cch.find("text|") - 1);
							if (world == NULL || world->name == "EXIT") continue;
							if (str.find("player_chat") != std::string::npos) {
								Player::OnConsoleMessage(peer, "`4Oops! `$This message isnt allowed.");
								continue;
							}
							if (str.length() != 0 && str[0] == '/')
							{
								sendConsoleMsg(peer, "CP:0_PL:0_OID:_CT:[MSG]_ `6" + str);
								sendAction(peer, pData->netID, str);
							}
							else if (str.length() > 0)
							{
								if (((PlayerInfo*)(peer->data))->isDuctaped == false) {
									sendChatMessage(world, peer, pData->netID, str);
								}
								else {

									sendChatMessage(world, peer, pData->netID, randomDuctTapeMessage(str.length()));
								}
							}
							if (world->name == "DEATHMATCH") {
								Player::OnTextOverlay(peer, "Sorry, but you can't using any command while playing death match game.");
								break;
							}

							if (str == "/mods") {
								string x = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
									if (isMod(((PlayerInfo*)(currentPeer->data))->rawName, ((PlayerInfo*)(currentPeer->data))->tankIDPass) && !((PlayerInfo*)(currentPeer->data))->isInvisible && !((PlayerInfo*)(currentPeer->data))->isNicked || isDev(peer) && isMod(((PlayerInfo*)(currentPeer->data))->rawName, ((PlayerInfo*)(currentPeer->data))->tankIDPass)) {
										if (not ((PlayerInfo*)(currentPeer->data))->isHidde) {
											if (((PlayerInfo*)(currentPeer->data))->isNicked && isDev(peer)) {
												x.append("" + ((PlayerInfo*)(currentPeer->data))->rawName + " (" + ((PlayerInfo*)(currentPeer->data))->displayName + ")`w, ");
											}
											else {
												x.append("" + ((PlayerInfo*)(currentPeer->data))->displayName + "`w, ");
											}
										}
									}
								}
								x = x.substr(0, x.length() - 2);
								if (x == "") x = "(All are hidden)";
								sendConsoleMsg(peer, "`oMods online: " + x);
							}
							else if (str.substr(0, 5) == "/vsb ") {
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0 || haveSubscription(peer)) {
									if (((PlayerInfo*)(peer->data))->isDuctaped == true) {
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Not allowed to VSB while ducttaped!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);


										enet_peer_send(peer, 0, packet);
										delete p.data;
										continue;
									}
									if (((PlayerInfo*)(peer->data))->lastSB + 10000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
									{
										((PlayerInfo*)(peer->data))->lastSB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									}


									else {
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Wait " + to_string((pData->lastSB + 10000 - GetCurrentTimeInternal()) / 1000) + " sec before using the /vsb command again!"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(peer, 0, packet);
										delete p.data;
										continue;
									}


									if (((PlayerInfo*)(peer->data))->haveGrowId) {
										string name = ((PlayerInfo*)(peer->data))->displayName;

										GamePacket p;

										if (adminLevel(peer) != 0) {
											p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:4_OID:_CT:[SB]_ `w** [`eVIP-SB``] `w from `2" + name + "`w (in `4JAMMED!```w) ** :`^ " + str.substr(5, cch.length() - 5 - 1)));
										}
										else {
											p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:4_OID:_CT:[SB]_ `w** [`eVIP-SB``] `w from `2" + name + "`w (in `4JAMMED!```w) ** :`# " + str.substr(5, cch.length() - 5 - 1)));
										}
										string text = "action|play_sfx\nfile|audio/friend_beep.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
										ENetPeer* currentPeer;

										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (!((PlayerInfo*)(currentPeer->data))->radio) continue;
											enet_peer_send(currentPeer, 0, packet);
											enet_peer_send(currentPeer, 0, packet2);
										}
										delete[] data;
										delete p.data;
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 6) == "/ghost") {
								if (world->allowNoclip == false) {
									if (isWorldOwner(peer, world) || getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0) {

									}
									else {
										Player::OnConsoleMessage(peer, "`8Ghosting/Noclipping is disabled in this world!``");
										continue;
									}
								}
								ENetPeer* currentPeer;
								int netid = ((PlayerInfo*)(peer->data))->netID;
								if (((PlayerInfo*)(peer->data))->canWalkInBlocks == false) {

									((PlayerInfo*)(peer->data))->canWalkInBlocks = true;
									sendState(peer);

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										Player::OnChangeSkin(currentPeer, -2450, netid); // -137
									}
									Player::OnConsoleMessage(peer, "`oYour atoms are suddenly aware of quantum tunneling. (`$Ghost in the Shell `omod added)``");
								}
								else {

									((PlayerInfo*)(peer->data))->canWalkInBlocks = false;
									sendState(peer);
									Player::PlayAudio(peer, "audio/dialog_confirm.wav", 0);
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										Player::OnChangeSkin(currentPeer, ((PlayerInfo*)(peer->data))->skinColor, netid);
									}

									Player::OnConsoleMessage(peer, "`oYour body stops shimmering and returns to normal. (`$Ghost in the Shell `omod removed)``");
								}
							}
							else if (str == "/hidestatus") {
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0 || haveSubscription(peer)) {
									pData->haveSuperSupporterName = !pData->haveSuperSupporterName;
									sendState(peer);
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 5) == "/buy ") {
								string itemFind = str.substr(5, cch.length() - 5 - 1);
								if (itemFind.find("~") != string::npos || itemFind.find("`") != string::npos || itemFind.find("_") != string::npos || itemFind.find("-") != string::npos || itemFind.find("$") != string::npos || itemFind.find("#") != string::npos || itemFind.find("@") != string::npos || itemFind.find("!") != string::npos || itemFind.find("&") != string::npos || itemFind.find("(") != string::npos || itemFind.find(")") != string::npos || itemFind.find("]") != string::npos || itemFind.find("[") != string::npos || itemFind.find("{") != string::npos || itemFind.find("}") != string::npos || itemFind.find("=") != string::npos || itemFind.find(":") != string::npos || itemFind.find(";") != string::npos || itemFind.find("'") != string::npos || itemFind.find("?") != string::npos) {
									Player::OnTalkBubble(peer, pData->netID, "`wSymbols are not allowed!``", 0);
									continue;
								}
								if (itemFind.length() < 3) {
									Player::OnTalkBubble(peer, pData->netID, "`wThis item name is too short!``", 0);
									continue;
								}
							SKIPFinds:;
								string itemLower2;
								vector<ItemDefinition> itemDefsfind;
								for (char c : itemFind) if (c < 0x20 || c > 0x7A) goto SKIPFinds;
								if (itemFind.length() < 3) goto SKIPFinds3;
								for (const ItemDefinition& item : itemDefs) {
									string itemLower;
									for (char c : item.name) if (c < 0x20 || c > 0x7A) goto SKIPFinds2;
									if (!(item.id % 2 == 0)) goto SKIPFinds2;
									itemLower2 = item.name;
									std::transform(itemLower2.begin(), itemLower2.end(), itemLower2.begin(), ::tolower);
									if (itemLower2.find(itemLower) != std::string::npos) {
										itemDefsfind.push_back(item);
									}
								SKIPFinds2:;
								}
							SKIPFinds3:;
								string listMiddle = "";
								string listFull = "";
								for (const ItemDefinition& item : itemDefsfind) {
									if (item.name != "") {
										string kys = item.name;
										std::transform(kys.begin(), kys.end(), kys.begin(), ::tolower);
										string kms = itemFind;
										std::transform(kms.begin(), kms.end(), kms.begin(), ::tolower);
										if (kys.find(kms) != std::string::npos) {
											int id = item.id;
											int itemid = item.id;
											if (itemDefs.at(itemid).properties & Property_Untradable && itemDefs.at(itemid).rarity == 999 || itemDefs.at(itemid).blockType != BlockTypes::CLOTHING && itemDefs.at(itemid).rarity == 999 && itemid != 1436 && itemid != 5142 && itemid != 7188 && itemid != 9498 && itemid != 3176 && itemid != 9528 && itemid != 5154 && itemid != 5140 && itemid != 5138 && itemid != 5136 && itemid != 7382 && itemid != 4762 || itemid == 18 && itemid != 7188 || itemid == 10034 || itemDefs.at(itemid).name.find("null") != string::npos || itemid == 10036 || itemDefs.at(itemid).name.find("Mooncake") != string::npos || itemDefs.at(itemid).name.find("Harvest") != string::npos && itemid != 1830 || itemDefs.at(itemid).name.find("Autumn") != string::npos || itemid == 1056 || itemid == 1804 || itemDefs.at(itemid).blockType == BlockTypes::COMPONENT || itemid == 912 || itemid == 952 || itemid == 1472 || itemid == 1664 || itemid == 6920 || itemid == 6922 || itemid == 1874 || itemid == 1876 || itemid == 1904 || itemid == 1932 || itemid == 1900 || itemid == 1986 || itemid == 1996 || itemid == 2970 || itemid == 3140 || itemid == 3174 || itemid == 6028 || itemid == 6846 || itemid == 8962 || itemid == 2408 || itemid == 4428 || itemid == 5086 || itemid == 9240 || itemid == 9306 || itemid == 9290 || itemid == 7328 || itemid == 9416 || itemid == 10386 || itemid == 9410 || itemid == 1458 || itemid == 9408 || itemid == 9360 || itemid == 6866 || itemid == 6868 || itemid == 6870 || itemid == 6872 || itemid == 6874 || itemid == 6876 || itemid == 6878 || itemid == 2480 || itemid == 8452 || itemid == 5132 || itemid == 7166 || itemid == 5126 || itemid == 5128 || itemid == 5130 || itemid == 5144 || itemid == 5146 || itemid == 5148 || itemid == 5150 || itemid == 5162 || itemid == 5164 || itemid == 5166 || itemid == 5168 || itemid == 5180 || itemid == 5182 || itemid == 5184 || itemid == 5186 || itemid == 7168 || itemid == 7170 || itemid == 7172 || itemid == 7174 || itemid == 8834 || itemid == 7912 || itemid == 9212 || itemid == 5134 || itemid == 5152 || itemid == 5170 || itemid == 5188 || itemid == 980 || itemid == 9448 || itemid == 9310 || itemid == 10034 || itemid == 10036 || itemid == 8470 || itemid == 8286 || itemid == 6026 || itemid == 1784 || itemid == 9356 || itemid == 10022 || itemid == 902 || itemid == 10032 || itemid == 834 || itemid == 6 || itemid == 5640 || itemid == 9492 || itemid == 1782 || itemid == 9288 || itemid == 1780 || itemid == 8306 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 2950 || itemid == 4802 || itemid == 4994 || itemid == 5260 || itemid == 5814 || itemid == 5980 || itemid == 7734 || itemid == 2592 || itemid == 2242 || itemid == 1794 || itemid == 1792 || itemid == 778 || itemid == 9510 || itemid == 8774 || itemid == 2568 || itemid == 9512 || itemid == 9502 || itemid == 9482 || itemid == 2250 || itemid == 2248 || itemid == 2244 || itemid == 2246 || itemid == 2286 || itemid == 9508 || itemid == 9504 || itemid == 9506 || itemid == 274 || itemid == 276 || itemid == 9476 || itemid == 1486 || itemid == 4426 || itemid == 9496 || itemid == 278 || itemid == 9490 || itemid == 2410 || itemid == 9488 || itemid == 9452 || itemid == 9454 || itemid == 9472 || itemid == 9456 || itemid == 732 || itemid == 9458 || itemid == 6336 || itemid == 112 || itemid == 8 || itemid == 3760 || itemid == 18 || itemid == 7372 || itemid == 9438 || itemid == 9462 || itemid == 9440 || itemid == 9442 || itemid == 9444 || itemid == 7960 || itemid == 7628 || itemid == 8552) continue;
											if (getItemDef(itemid).blockType == BlockTypes::SEED || itemid == 6312 || itemid == 998 || itemid == 986 || itemid == 992 || itemid == 990 || itemid == 996 || itemid == 988 || itemid == 1004 || itemid == 1006 || itemid == 1002 || itemid == 9504 || itemid == 9506 || itemid == 9508 || itemid == 9510 || itemid == 9512 || itemid == 9514 || itemid == 9518 || itemid == 9520 || itemid == 9502 || itemid == 9496 || itemid == 1790 || itemid == 9492 || itemid == 9494 || itemid == 9488 || itemid == 9222 || itemid == 1360 || itemid == 6260 || itemid == 822 || itemid == 1058 || itemid == 1094 || itemid == 1096 || itemid == 3402 || itemid == 1098 || itemid == 1828 || itemid == 3870 || itemid == 7058 || itemid == 1938 || itemid == 8452 || itemid == 1740 || itemid == 3040 || itemid == 5080 || itemid == 3100 || itemid == 1550 || itemid == 5740 || itemid == 3074 || itemid == 3010 || itemid == 8480 || itemid == 5084 || itemid == 10424 || itemid == 4656 || itemid == 7558 || itemid == 5082 || itemid == 1636 || itemid == 6008 || itemid == 4996 || itemid == 6416 || itemid == 2206 || itemid == 3792 || itemid == 3196 || itemid == 4654 || itemid == 3306 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 2242 || itemid == 2244 || itemid == 2246 || itemid == 2248 || itemid == 2250 || itemid == 4676 || itemid == 4678 || itemid == 4680 || itemid == 4682 || itemid == 4652 || itemid == 4646 || itemid == 4648 || itemid == 4652 || itemid == 4650 || itemid == 10084 || itemid == 10086 || itemid == 9168 || itemid == 5480 || itemid == 4534 || itemid == 9166 || itemid == 9164 || itemid == 9162 || itemid == 9160 || itemid == 9158 || itemid == 9156 || itemid == 9154 || itemid == 9152 || itemid == 3008 || itemid == 3010 || itemid == 3040 || itemid == 5740 || itemid == 6254 || itemid == 6256 || itemid == 6258 || itemid == 6932 || itemid == 10262 || itemid == 10616 || itemid == 10582 || itemid == 10580 || itemid == 10664 || itemid == 10596 || itemid == 10598 || itemid == 10586 || itemid == 10590 || itemid == 10592 || itemid == 10576 || itemid == 10578 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 4994 || itemid == 2978 || itemid == 9268 || itemid == 5766 || itemid == 5768 || itemid == 5744 || itemid == 5756 || itemid == 5758 || itemid == 5760 || itemid == 5762 || itemid == 5754 || itemid == 7688 || itemid == 7690 || itemid == 7694 || itemid == 7686 || itemid == 7692 || itemid == 7698 || itemid == 7696 || itemid == 9286 || itemid == 9272 || itemid == 9290 || itemid == 9280 || itemid == 9282 || itemid == 9292 || itemid == 9284 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 10660 || itemid == 10654 || itemid == 10632 || itemid == 10652 || itemid == 10626 || itemid == 10640 || itemid == 10662 || itemid == 574 || itemid == 592 || itemid == 760 || itemid == 900 || itemid == 766 || itemid == 1012 || itemid == 1272 || itemid == 1320 || itemid == 1540 || itemid == 1648 || itemid == 1740 || itemid == 1950 || itemid == 2900 || itemid == 1022 || itemid == 1030 || itemid == 1024 || itemid == 1032 || itemid == 1026 || itemid == 1028 || itemid == 1036 || itemid == 1034 || itemid == 2908 || itemid == 2974 || itemid == 3494 || itemid == 3060 || itemid == 3056 || itemid == 3052 || itemid == 3066 || itemid == 3048 || itemid == 3068 || itemid == 3166 || itemid == 2032 || itemid == 6780 || itemid == 754 || itemid == 794 || itemid == 796 || itemid == 2876 || itemid == 798 || itemid == 930 || itemid == 2204 || itemid == 2912 || itemid == 772 || itemid == 770 || itemid == 898 || itemid == 1582 || itemid == 1020 || itemid == 4132 || itemid == 3932 || itemid == 3934 || itemid == 4128 || itemid == 10246 || itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7130) continue;
											if (itemid == 4762 || itemid == 5136 || itemid == 7382 || itemid == 5154 || itemid == 5140 || itemid == 5138 || itemid == 9498 || itemid == 9530 || itemid == 9526 || itemid == 9524 || itemid == 6398 || itemid == 6426 || itemid == 6340 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 2386 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 9350 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 392 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) continue;
											//food
											if (itemid == 4586 || itemid == 962 || itemid == 4564 || itemid == 4570 || itemid == 4598 || itemid == 868 || itemid == 196 || itemid == 4766 || itemid == 4568 || itemid == 4596 || itemid == 3472 || itemid == 7672 || itemid == 7056 || itemid == 4764 || itemid == 6316 || itemid == 676 || itemid == 874 || itemid == 4666 || itemid == 4594 || itemid == 4602 || itemid == 4604) continue;
											//robber things
											if (itemid == 9428 || itemid == 8372 || itemid == 1460 || itemid == 1970 || itemid == 3930 || itemid == 944 || itemid == 1538 || itemid == 7588 || itemid == 1696) continue;
											// space alien
											if (itemid == 4820 || itemid == 1674 || itemid == 10952 || itemid == 10954 || itemid == 10956 || itemid == 10958 || itemid == 10960) continue;
											// ezio
											if (itemid == 11560 || itemid == 11554 || itemid == 11556 || itemid == 11558) continue;
											listMiddle += "add_button_with_icon|tool" + to_string(item.id) + "|`$" + item.name + "``|left|" + to_string(item.id) + "||\n";
										}
									}
								}
								if (itemFind.length() < 3) {
									listFull = "add_textbox|`4Word is less then 3 letters!``|\nadd_spacer|small|\n";
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Find item: " + itemFind + "``|left|3146|\n" + listFull + "add_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||30|\nend_dialog|findid2|Cancel|Find the item!|\n");
								}
								else if (itemDefsfind.size() == 0) {
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Find item: " + itemFind + "``|left|3146|\n" + listFull + "add_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||30|\nend_dialog|findid2|Cancel|Find the item!|\n");
								}
								else {
									if (listMiddle.size() == 0) {
										Player::OnTalkBubble(peer, pData->netID, "`wNo items were found with that name!``", 0);
									}
									else {
										Player::OnDialogRequest(peer, "add_label_with_icon|big|`wFound item : " + itemFind + "``|left|6016|\nadd_spacer|small|\nend_dialog|findid2|Cancel|\nadd_spacer|big|\n" + listMiddle + "add_quick_exit|\n");
									}
								}
							}
							else if (str.substr(0, 3) == "/a ") {
								ENetPeer* currentPeer;
								auto imie = atoi(str.substr(3, cch.length() - 3 - 1).c_str());
								if (imie == 0) continue;
								if (hasil == 0) {
									Player::OnTextOverlay(peer, "There is no event right now");
									continue;
								}
								if (imie == hasil) {
									resultnbr1 = 0;
									resultnbr2 = 0;
									hasil = 0;
									((PlayerInfo*)(peer->data))->gems += prize;
									Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
									prize = 0;
									string nama = ((PlayerInfo*)(peer->data))->displayName;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										Player::OnConsoleMessage(currentPeer, "`6** GrowtopiaTS Daily: (party) Math Event Winner is `^" + nama + "`6!");
										Player::PlayAudio(currentPeer, "audio/pinata_lasso.wav", 0);
									}
								}
								else {
									Player::OnTextOverlay(peer, "Your answer is incorrect...");
								}
							}
							else if (str == "/join") {
								if (player1 != "" && player2 != "") {
									Player::OnConsoleMessage(peer, "Game already started!");
									break;
								}
								if (player1 == "") {
									if (((PlayerInfo*)(peer->data))->gems < 250)
									{
										Player::OnConsoleMessage(peer, "You need " + std::to_string(250 - ((PlayerInfo*)(peer->data))->gems) + " gems anymore");
										break;
									}
									player1 = ((PlayerInfo*)(peer->data))->tankIDName;
									Player::OnConsoleMessage(peer, "Joining..");
									Player::OnConsoleMessage(peer, "Waiting Players..");
									((PlayerInfo*)(peer->data))->playing = true;
									break;
								}
								else if (player2 == "" && player1 != "") {
									if (((PlayerInfo*)(peer->data))->gems < 250) {
										Player::OnConsoleMessage(peer, "You need " + std::to_string(250 - ((PlayerInfo*)(peer->data))->gems) + " gems anymore");
										break;
									}
									if (player1 == ((PlayerInfo*)(peer->data))->tankIDName) {
										Player::OnConsoleMessage(peer, "Waiting for player, please wait..");
										break;
									}
									player2 = ((PlayerInfo*)(peer->data))->tankIDName;
									((PlayerInfo*)(peer->data))->playing = true;
									started = true;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (((PlayerInfo*)(currentPeer->data))->tankIDName == player1 || ((PlayerInfo*)(currentPeer->data))->tankIDName == player2) {
											((PlayerInfo*)(currentPeer->data))->mstate = 0;
											((PlayerInfo*)(currentPeer->data))->smstate = 0;
											((PlayerInfo*)(currentPeer->data))->canWalkInBlocks = false;
											((PlayerInfo*)(currentPeer->data))->isInvisible = false;
											AddItemToInv(world, currentPeer, 2, 200, false);
											AddItemToInv(world, currentPeer, 4, 200, false);
											AddItemToInv(world, currentPeer, 162, 200, false);
											if (world_exist("DEATHMATCH")) remove("DEATHMATCH");
											((PlayerInfo*)(currentPeer->data))->gems -= 250;
											WorldInfo* world2 = worldDB.get_pointer("DEATHMATCH");
											world2->items.clear();
											GenerateWorld(world2, "DEATHMATCH", world2->width, world2->height);
											sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
											if (player1 == ((PlayerInfo*)(currentPeer->data))->tankIDName) handle_world(currentPeer, "DEATHMATCH", 3040, 736);
											else handle_world(currentPeer, "DEATHMATCH", 132, 738);
											Player::OnAddNotification(currentPeer, "`5The Game has started!", "audio/belch2.wav", "interface/large/anni_sta.rttex");
										}
										if (reinterpret_cast<PlayerInfo*>(currentPeer->data)->radio) {
											Player::OnConsoleMessage(currentPeer, "`4***`` `5GrowtopiaTS```1-```5(party) Deathmatch EVENT (party) Game - " + player1 + " vs " + player2 + "!");
											Player::PlayAudio(currentPeer, "audio/beep.wav", 0);
										}
									}
								}
							}
							else if (str == "/check") {
								Player::OnConsoleMessage(peer, "X: " + to_string(((PlayerInfo*)(peer->data))->x));
								Player::OnConsoleMessage(peer, "Y: " + to_string(((PlayerInfo*)(peer->data))->y));
								Player::OnConsoleMessage(peer, "NetID: " + to_string(((PlayerInfo*)(peer->data))->netID));
							}
							else if (str == "/saveworld") {
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end()) {
									sendConsoleMsg(peer, "`oSaving all worlds...");
									for (int i = 0; i < worlds.size(); i++) {
										string world_name = worlds.at(i).name;
										save_world(world_name, false, false);
									}
									sendConsoleMsg(peer, "`oSuccess");
									ENetPeer* currentPeerp;
									for (currentPeerp = server->peers;
										currentPeerp < &server->peers[server->peerCount];
										++currentPeerp)
									{
										if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
											continue;
										FlushPlayer(currentPeerp);
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str == "/ghosts")
							{
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0 || haveSubscription(peer))
								{
									ENetPeer* currentPeer;
									int netid = ((PlayerInfo*)(peer->data))->netID;
									if (((PlayerInfo*)(peer->data))->canWalkInBlocks == false) {

										((PlayerInfo*)(peer->data))->canWalkInBlocks = true;
										sendState(peer);

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											Player::OnChangeSkin(currentPeer, -2450, netid); // -137
										}
										Player::OnConsoleMessage(peer, "`oYour atoms are suddenly aware of quantum tunneling. (`$Ghost in the Shell `omod added)``");
									}
									else {

										((PlayerInfo*)(peer->data))->canWalkInBlocks = false;
										sendState(peer);
										Player::PlayAudio(peer, "audio/dialog_confirm.wav", 0);
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											Player::OnChangeSkin(currentPeer, ((PlayerInfo*)(peer->data))->skinColor, netid);
										}

										Player::OnConsoleMessage(peer, "`oYour body stops shimmering and returns to normal. (`$Ghost in the Shell `omod removed)``");
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str == "/news")
							{
								sendGazette(peer);

							}
							else if (str == "/nuke")
							{

								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0)
								{
									if (world->isNuked == false)
									{
										SendWebhook(currentDateTime() + " Player " + ((PlayerInfo*)(peer->data))->tankIDName + " NUKED " + world->name + "```", "GAME_LOGS");
										world->isNuked = true;
										sendConsoleMsg(peer, "`oYou have nuked the world!");
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4" + world->name + " has been nuked from orbit. `$>> It's the only way to be sure. Play nice, everybody!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										string text = "action|play_sfx\nfile|audio/bigboom.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);


										ENetPacket* packetnuk = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
										ENetPeer* currentPeerp;
										for (currentPeerp = server->peers;
											currentPeerp < &server->peers[server->peerCount];
											++currentPeerp)
										{
											if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (!pData->radio)
												continue;
											enet_peer_send(currentPeerp, 0, packet);
											enet_peer_send(currentPeerp, 0, packetnuk);
											if (isHere(peer, currentPeerp))
											{
												if (((PlayerInfo*)(currentPeerp->data))->adminLevel == 0)
												{
													Send_Cancel_Game(currentPeerp);
													sendPlayerLeave(currentPeerp, (PlayerInfo*)currentPeerp->data);
													sendWorldOffers(currentPeerp);
												}
											}
										}
									}
									else
									{
										SendWebhook("" + currentDateTime() + " Player " + ((PlayerInfo*)(peer->data))->tankIDName + " UNNUKED " + world->name + "", "GAME_LOGS");
										world->isNuked = false;
										sendConsoleMsg(peer, "`oYou have un-nuke the world!");

									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str == "/find")
							{
								if (!isMod(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) {
									sendUnknownCommand(peer);
								}
								else
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wFind item``|left|6016|\nadd_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||30|\nend_dialog|findid|Cancel|Find the item!|\nadd_quick_exit|\n"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
							}
							else if (str.substr(0, 6) == "/item ")
							{
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 1)
								{
									int bitem = atoi(str.substr(6, cch.length() - 6 - 1).c_str());
									int intid = atoi(str.substr(6, cch.length() - 6 - 1).c_str());
									int ide = atoi(str.substr(6, cch.length() - 6 - 1).c_str());


									int devitem = atoi(str.substr(6, cch.length() - 6 - 1).c_str());
									if (devitem == 0 || devitem < 1)

									{

										continue;
									}


									else {
										string id = (str.substr(6, cch.length() - 6 - 1).c_str());
										if (getItemDef(intid).rarity == 999) {
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oGiven`w 200 " + getItemDef(intid).name + "`o."));

											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
										else {
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oGiven`w 200 " + getItemDef(intid).name + "`o. Rarity `w" + std::to_string(getItemDef(intid).rarity) + "`o."));

											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
										int netID = ((PlayerInfo*)(peer->data))->netID;
										AddItemToInv(world, peer, intid, 200);
										SendTradeEffect(peer, intid, netID, netID, 150);

									}
								}
								else sendUnknownCommand(peer);
							}

							else if (str.substr(0, 6) == "/kick ") {

								if (isWorldOwner(peer, world) || (((PlayerInfo*)(peer->data))->rawName == "samuel" || isOwner(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass))) {
									string kickname = str.substr(6, cch.length() - 6 - 1);
									if (kickname == "finland") continue;
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (isHere(peer, currentPeer))
										{
											if (((PlayerInfo*)(currentPeer->data))->rawName == kickname) {
												playerRespawn(world, currentPeer, false);
												break;
											}
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 7) == "/color ")
							{
								((PlayerInfo*)(peer->data))->skinColor = atoi(str.substr(6, cch.length() - 6 - 1).c_str());
								sendClothes(peer);
							}
							else if (str == "/clear") {
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end()) {
									if (!world) continue;
									if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {
										try {
											for (int i = 0; i < world->width * world->height; i++)
											{
												if (world->items[i].foreground != 6 && world->items[i].foreground != 8 && getItemDef(world->items[i].foreground).blockType != BlockTypes::LOCK) {

													world->items[i].foreground = 0;
													world->items[i].background = 0;
													world->items[i].activated = false;
													world->items[i].intdata = 0;
													world->items[i].sign = "";
													world->magplantGems = 0;
													world->magX = -1;
													world->magY = -1;
													world->enablecolleciton = false;
												}
											}
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
									string act = ((PlayerInfo*)(peer->data))->currentWorld;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (isHere(peer, currentPeer)) {
											sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
											handle_world(currentPeer, act);
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 9) == "/giveadm ")
							{

								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string newown = str.substr(9, cch.length() - 9 - 1);

									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == newown)
										{
											((PlayerInfo*)(currentPeer->data))->displayName = "`4@" + ((PlayerInfo*)(currentPeer->data))->tankIDName;
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`wYou Received `4Administrator `wfrom " + pData->displayName));

											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											delete p2.data;
											((PlayerInfo*)(currentPeer->data))->adminLevel = 2;
											Admin admin;
											admin.username = PlayerDB::getProperName(newown);
											admin.password = ((PlayerInfo*)(currentPeer->data))->tankIDPass;
											admin.level = ((PlayerInfo*)(currentPeer->data))->adminLevel;
											admins.push_back(admin);
											FlushPlayer(currentPeer);
											GamePacket p23 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), ((PlayerInfo*)(currentPeer->data))->displayName));

											memcpy(p23.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
											ENetPacket* packet23 = enet_packet_create(p23.data,
												p23.len,
												ENET_PACKET_FLAG_RELIABLE);
											ENetPeer* currentPeesr;

											for (currentPeesr = server->peers;
												currentPeesr < &server->peers[server->peerCount];
												++currentPeesr)
											{
												if (currentPeesr->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeesr))
												{
													enet_peer_send(currentPeer, 0, packet23);
												}
											}
											delete p23.data;
											break;
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str == "/delete")
							{
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											sendPlayerLeave2(currentPeer, (PlayerInfo*)peer->data);
											sendWorldOffers(currentPeer);
											sendNotification(currentPeer, "audio/galac_mini.wav", "game/sun.rttex", "`wThe world " + ((PlayerInfo*)peer->data)->currentWorld + "`w was punched into a black hole!");
										}
									}
									worldDB.remove(world->name);
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 9) == "/giveown ")
							{

								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string newown = str.substr(9, cch.length() - 9 - 1);

									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == newown)
										{
											((PlayerInfo*)(currentPeer->data))->displayName = "`6@" + ((PlayerInfo*)(currentPeer->data))->tankIDName;
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`wYou Received `6Server-Creator `wfrom " + pData->displayName));

											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											delete p2.data;
											((PlayerInfo*)(currentPeer->data))->adminLevel = 3;
											Admin admin;
											admin.username = PlayerDB::getProperName(newown);
											admin.password = ((PlayerInfo*)(currentPeer->data))->tankIDPass;
											admin.level = ((PlayerInfo*)(currentPeer->data))->adminLevel;
											admins.push_back(admin);
											FlushPlayer(currentPeer);
											GamePacket p23 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), ((PlayerInfo*)(currentPeer->data))->displayName));

											memcpy(p23.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
											ENetPacket* packet23 = enet_packet_create(p23.data,
												p23.len,
												ENET_PACKET_FLAG_RELIABLE);
											ENetPeer* currentPeesr;

											for (currentPeesr = server->peers;
												currentPeesr < &server->peers[server->peerCount];
												++currentPeesr)
											{
												if (currentPeesr->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeesr))
												{
													enet_peer_send(currentPeer, 0, packet23);
												}
											}
											delete p23.data;
											break;
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str == "/magic") {
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) >= 1 || haveSubscription(peer)) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (isHere(peer, currentPeer)) {
											Player::PlayAudio(currentPeer, "audio/magic.wav", 0);
											for (int i = 0; i < 14; i++) {
												if (rand() % 100 <= 75) SendParticleEffect(currentPeer, ((PlayerInfo*)(peer->data))->x - 15 * (rand() % 6), ((PlayerInfo*)(peer->data))->y - 15 * (rand() % 6), rand() % 6 + 1, 2, i * 300);
												if (rand() % 100 <= 75) SendParticleEffect(currentPeer, ((PlayerInfo*)(peer->data))->x + 15 * (rand() % 6), ((PlayerInfo*)(peer->data))->y - 15 * (rand() % 6), rand() % 6 + 1, 2, i * 300);
												if (rand() % 100 <= 75) SendParticleEffect(currentPeer, ((PlayerInfo*)(peer->data))->x + 15 * (rand() % 6), ((PlayerInfo*)(peer->data))->y + 15 * (rand() % 6), rand() % 6 + 1, 2, i * 300);
												if (rand() % 100 <= 75) SendParticleEffect(currentPeer, ((PlayerInfo*)(peer->data))->x - 15 * (rand() % 6), ((PlayerInfo*)(peer->data))->y + 15 * (rand() % 6), rand() % 6 + 1, 2, i * 300);

												if (rand() % 100 <= 25) SendParticleEffect(currentPeer, ((PlayerInfo*)(peer->data))->x - 15 * (rand() % 6), ((PlayerInfo*)(peer->data))->y - 15 * (rand() % 6), rand() % 16, 3, i * 300);
												if (rand() % 100 <= 25) SendParticleEffect(currentPeer, ((PlayerInfo*)(peer->data))->x + 15 * (rand() % 6), ((PlayerInfo*)(peer->data))->y - 15 * (rand() % 6), rand() % 16, 3, i * 300);
												if (rand() % 100 <= 25) SendParticleEffect(currentPeer, ((PlayerInfo*)(peer->data))->x + 15 * (rand() % 6), ((PlayerInfo*)(peer->data))->y + 15 * (rand() % 6), rand() % 16, 3, i * 300);
												if (rand() % 100 <= 25) SendParticleEffect(currentPeer, ((PlayerInfo*)(peer->data))->x - 15 * (rand() % 6), ((PlayerInfo*)(peer->data))->y + 15 * (rand() % 6), rand() % 16, 3, i * 300);

											}
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 13) == "/givevip1day ")
							{
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string name = str.substr(13, str.length());
									ENetPeer* currentPeer;
									auto found = false;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										std::transform(name.begin(), name.end(), name.begin(), ::tolower);
										std::transform(((PlayerInfo*)(currentPeer->data))->rawName.begin(), ((PlayerInfo*)(currentPeer->data))->rawName.end(), ((PlayerInfo*)(currentPeer->data))->rawName.begin(), ::tolower);
										if (name == ((PlayerInfo*)(currentPeer->data))->rawName) {
											ofstream savebantime("Subscription/" + ((PlayerInfo*)(currentPeer->data))->rawName + ".txt");
											if (!savebantime.is_open()) continue;
											savebantime << (GetCurrentTimeInternalSeconds() + (1440 * 60)) << endl;
											savebantime << "" << endl;
											savebantime << "" << endl;
											savebantime.close();
											Player::OnConsoleMessage(currentPeer, "Congrats! You have been Promoted to VIP (1 Day left).");
											enet_peer_disconnect_later(currentPeer, 0);
											found = true;
										}
									}
									if (!found) Player::OnConsoleMessage(peer, "Player not found!");
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 13) == "/givevip3day ")
							{
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string name = str.substr(13, str.length());
									ENetPeer* currentPeer;
									auto found = false;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										std::transform(name.begin(), name.end(), name.begin(), ::tolower);
										std::transform(((PlayerInfo*)(currentPeer->data))->rawName.begin(), ((PlayerInfo*)(currentPeer->data))->rawName.end(), ((PlayerInfo*)(currentPeer->data))->rawName.begin(), ::tolower);
										if (name == ((PlayerInfo*)(currentPeer->data))->rawName) {
											ofstream savebantime("Subscription/" + ((PlayerInfo*)(currentPeer->data))->rawName + ".txt");
											if (!savebantime.is_open()) continue;
											savebantime << (GetCurrentTimeInternalSeconds() + (4320 * 60)) << endl;
											savebantime << "" << endl;
											savebantime << "" << endl;
											savebantime.close();
											Player::OnConsoleMessage(currentPeer, "Congrats! You have been Promoted to VIP (3 Days left).");
											enet_peer_disconnect_later(currentPeer, 0);
											found = true;
										}
									}
									if (!found) Player::OnConsoleMessage(peer, "Player not found!");
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 13) == "/givevip7day ")
							{
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string name = str.substr(13, str.length());
									ENetPeer* currentPeer;
									auto found = false;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										std::transform(name.begin(), name.end(), name.begin(), ::tolower);
										std::transform(((PlayerInfo*)(currentPeer->data))->rawName.begin(), ((PlayerInfo*)(currentPeer->data))->rawName.end(), ((PlayerInfo*)(currentPeer->data))->rawName.begin(), ::tolower);
										if (name == ((PlayerInfo*)(currentPeer->data))->rawName) {
											ofstream savebantime("Subscription/" + ((PlayerInfo*)(currentPeer->data))->rawName + ".txt");
											if (!savebantime.is_open()) continue;
											savebantime << (GetCurrentTimeInternalSeconds() + (10080 * 60)) << endl;
											savebantime << "" << endl;
											savebantime << "" << endl;
											savebantime.close();
											Player::OnConsoleMessage(currentPeer, "Congrats! You have been Promoted to VIP (7 Days left).");
											enet_peer_disconnect_later(currentPeer, 0);
											found = true;
										}
									}
									if (!found) Player::OnConsoleMessage(peer, "Player not found!");
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 14) == "/givevip30day ")
							{
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string name = str.substr(14, str.length());
									ENetPeer* currentPeer;
									auto found = false;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										std::transform(name.begin(), name.end(), name.begin(), ::tolower);
										std::transform(((PlayerInfo*)(currentPeer->data))->rawName.begin(), ((PlayerInfo*)(currentPeer->data))->rawName.end(), ((PlayerInfo*)(currentPeer->data))->rawName.begin(), ::tolower);
										if (name == ((PlayerInfo*)(currentPeer->data))->rawName) {
											ofstream savebantime("Subscription/" + ((PlayerInfo*)(currentPeer->data))->rawName + ".txt");
											if (!savebantime.is_open()) continue;
											savebantime << (GetCurrentTimeInternalSeconds() + (34200 * 60)) << endl;
											savebantime << "" << endl;
											savebantime << "" << endl;
											savebantime.close();
											Player::OnConsoleMessage(currentPeer, "Congrats! You have been Promoted to VIP (30 Days left).");
											enet_peer_disconnect_later(currentPeer, 0);
											found = true;
										}
									}
									if (!found) Player::OnConsoleMessage(peer, "Player not found!");
								}
								else sendUnknownCommand(peer);
							}

							else if (str.substr(0, 9) == "/givemod ")
							{

								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string newown = str.substr(0x9, cch.length() - 0x9 - 1);

									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == newown)
										{
											((PlayerInfo*)(currentPeer->data))->displayName = "`#@" + ((PlayerInfo*)(currentPeer->data))->tankIDName;
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`wYou Received `^Moderator `wfrom " + pData->displayName));

											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											delete p2.data;
											((PlayerInfo*)(currentPeer->data))->adminLevel = 1;
											Admin admin;
											admin.username = PlayerDB::getProperName(newown);
											admin.password = ((PlayerInfo*)(currentPeer->data))->tankIDPass;
											admin.level = ((PlayerInfo*)(currentPeer->data))->adminLevel;
											admins.push_back(admin);
											FlushPlayer(currentPeer);
											GamePacket p23 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), ((PlayerInfo*)(currentPeer->data))->displayName));

											memcpy(p23.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
											ENetPacket* packet23 = enet_packet_create(p23.data,
												p23.len,
												ENET_PACKET_FLAG_RELIABLE);
											ENetPeer* currentPeesr;

											for (currentPeesr = server->peers;
												currentPeesr < &server->peers[server->peerCount];
												++currentPeesr)
											{
												if (currentPeesr->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeesr))
												{
													enet_peer_send(currentPeer, 0, packet23);
												}
											}
											delete p23.data;
											break;
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 8) == "/demote ") {
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string name = str.substr(8, str.length());


									ENetPeer* currentPeer;


									bool found = false;


									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;


										string name2 = ((PlayerInfo*)(currentPeer->data))->rawName;


										std::transform(name.begin(), name.end(), name.begin(), ::tolower);
										std::transform(name2.begin(), name2.end(), name2.begin(), ::tolower);


										if (name == name2) {
											found = true;
											std::ifstream ifs("subscription/" + name2 + ".txt");
											if (ifs.is_open()) std::remove(("subscription/" + name2 + ".txt").c_str());
											((PlayerInfo*)(currentPeer->data))->displayName + ((PlayerInfo*)(currentPeer->data))->tankIDName;
											GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "You have been `4DEMOTED"), "audio/hub_open.wav"), 0));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete p.data;
											((PlayerInfo*)(currentPeer->data))->displayName = ((PlayerInfo*)(currentPeer->data))->tankIDName;
											((PlayerInfo*)(currentPeer->data))->adminLevel = 0;
											Admin admin;
											admin.username = PlayerDB::getProperName(name);
											admin.password = ((PlayerInfo*)(currentPeer->data))->tankIDPass;
											admin.level = ((PlayerInfo*)(currentPeer->data))->adminLevel;
											admins.push_back(admin);
											FlushPlayer(currentPeer);
											GamePacket p23 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), ((PlayerInfo*)(currentPeer->data))->displayName));

											memcpy(p23.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
											ENetPacket* packet23 = enet_packet_create(p23.data,
												p23.len,
												ENET_PACKET_FLAG_RELIABLE);
											ENetPeer* currentPeesr;

											for (currentPeesr = server->peers;
												currentPeesr < &server->peers[server->peerCount];
												++currentPeesr)
											{
												if (currentPeesr->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeesr))
												{
													enet_peer_send(currentPeer, 0, packet23);
												}
											}
											delete p23.data;
										}
									}
									if (found) {
										Player::OnTextOverlay(peer, "Demoted " + name + " has successfully.");
									}
									else {
										Player::OnTextOverlay(peer, "Player not found!");
									}
								}
								else {
									sendUnknownCommand(peer);
									continue;
								}
							}
							else if (str == "/uba") {
								if (isWorldOwner(peer, world) || ((PlayerInfo*)(peer->data))->adminLevel > 1 || isWorldAdmin(peer, world)) {
									world->wbans.clear();
									Player::OnTextOverlay(peer, "Unbanned everyone from this world!");
								}
							}
							else if (str.substr(0, 9) == "/uncurse ")
							{
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0)
								{
									string banname = str.substr(0x9, cch.length() - 0x9 - 1);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == banname)
										{
											((PlayerInfo*)(currentPeer->data))->isCursed = false;
											sendState(currentPeer);
											FlushPlayer(currentPeer);
											break;
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 8) == "/unmute ")
							{
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0)
								{
									string banname = str.substr(8, cch.length() - 8 - 1);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == banname)
										{
											((PlayerInfo*)(currentPeer->data))->isDuctaped = false;
											sendState(currentPeer);
											FlushPlayer(currentPeer);
											break;
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 5) == "/ban ") {
								if (!isMod(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) {
									sendUnknownCommand(peer);
									continue;
								}
								string name = str.substr(5, str.length());
								auto exists = experimental::filesystem::exists("punishment/bans/" + PlayerDB::getProperName(name) + ".txt");
								std::ifstream read_player("players/" + PlayerDB::getProperName(name) + ".json");
								auto existx = false;
								if (read_player.is_open()) {
									read_player.close();
									existx = true;
								}
								if (std::find(creatorname.begin(), creatorname.end(), name) != creatorname.end())
								{
									Player::OnTextOverlay(peer, "`oYou can't do that!```");
									continue;
								}
								else if (exists)
								{
									Player::OnTextOverlay(peer, "That Player banned already!");
									continue;
								}
								else if (!existx)
								{
									Player::OnTextOverlay(peer, "Player not found!");
									continue;
								}
								else {
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`1Punish player``|left|1432|\n\nadd_spacer|small|\n\nadd_textbox|`wAre you sure you want to ban`` `2" + name + "```w?``|left|\n\nadd_textbox|`rMake sure you have proof and you have discord role on discord group, wrong bans will result in demoting.``|\n\nadd_textbox|`4If you don't post proof image/video in #ban-channel in 12hours, you will be instantly demoted!``|left|\nadd_textbox|Select ban length.|left|\nmax_checks|2|\ntext_scaling_string|Ban time|\nadd_checkicon|1day|1 Day||276||0|\nadd_checkicon|7day|7 Days||276||0|\nadd_checkicon|31day|31 Days||276||0|\nadd_checkicon|a|Forever||278||0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|\n\nadd_textbox|`oReason``|\nadd_text_input|bantest|||65|\nadd_checkbox|checkbox_public|`2Allowed for ban appealing?``|1|\nend_dialog|bansubmit|Cancel|`4Ban from game``|");
									((PlayerInfo*)(peer->data))->banName = name;
								}
							}
							else if (str.substr(0, 7) == "/unban ")
							{
								if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
								{
									string name = str.substr(7, cch.length() - 7 - 1);
									bool exist = experimental::filesystem::exists("punishment/bans/" + PlayerDB::getProperName(name) + ".txt");
									if (exist)
									{
										std::remove(("punishment/bans/" + PlayerDB::getProperName(name) + ".txt").c_str());
										Player::OnTextOverlay(peer, "`oYou have been successfully unbanned `w" + name + "`o!");
										SendWebhook(currentDateTime() + " Player " + ((PlayerInfo*)(peer->data))->rawName + " UNBANNED " + name, "BAN_LOGS");
									}
									else {
										Player::OnTextOverlay(peer, "`oSomething went wrong?!");
									}
								}
								else sendUnknownCommand(peer);
							}

							else if (str.substr(0, 7) == "/curse ") {

								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0)
								{
									string banname = str.substr(7, cch.length() - 7 - 1);
									bool exist = false;
									if (banname == pData->rawName)
									{
										sendConsoleMsg(peer, "`oYou can't do that.``");
										continue;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == banname && banname != "samuel" && banname != "ipowfu")
										{
											exist = true;
											sendPlayerLeave(currentPeer, (PlayerInfo*)currentPeer->data);
											handle_world(currentPeer, "HELL");
											GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"),
												"interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `bCURSED `0from Private Server for 730 days"), "audio/hub_open.wav"), 0));
											ENetPacket* packets2 = enet_packet_create(ps2.data,
												ps2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packets2);
											delete ps2.data;
											((PlayerInfo*)(currentPeer->data))->isCursed = true;
											FlushPlayer(currentPeer);
											sendState(currentPeer);
											break;
										}
									}
									if (!exist) {
										Player::OnTextOverlay(peer, "Player not found.");
									}
									else {
										ENetPeer* currentPeerx;
										for (currentPeerx = server->peers;
											currentPeerx < &server->peers[server->peerCount];
											++currentPeerx)
										{
											if (currentPeerx->state != ENET_PEER_STATE_CONNECTED)
												continue;
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave used `bCurse `oon `2" + banname + "`o! `#**"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeerx, 0, packet2);
											delete p2.data;
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str == "/who")
							{
								sendWho(world, peer);
							}
							else if (str.substr(0, 5) == "/spk ") {

								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 1)
								{
									const auto ex = explode(" ", str);
									if (ex.size() == 3) {
										string playername = ex.at(1);
										string asu = ex.at(0x2);
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == playername)
											{
												sendChatMessage(world, currentPeer, ((PlayerInfo*)(currentPeer->data))->netID, asu);
												break;
											}
										}
									}
									else Player::OnConsoleMessage(peer, "Error syntax please use in this way /spk <name> <message>");
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 6) == "/warn ") {

								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) >= 1)
								{
									const auto ex = explode(" ", str);
									if (ex.size() == 3) {
										string playername = ex.at(1);
										string asu = ex.at(2);
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == playername)
											{
												GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"),
													"interface/atomic_button.rttex"), "`wWarning from `4Admin`0: " + asu), "audio /hub_open.wav"), 0));
												ENetPacket* packets2 = enet_packet_create(ps2.data,
													ps2.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packets2);
												delete ps2.data;
												break;
											}
										}
									}
									else Player::OnConsoleMessage(peer, "Error syntax please use in this way /warn <name> <reason>");
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 9) == "/givelvl ")
							{

								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 1)
								{
									const auto ex = explode(" ", str);
									if (ex.size() == 3) {
										string playername = ex.at(1);
										string asu = ex.at(2);
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == playername)
											{
												((PlayerInfo*)(currentPeer->data))->level += atoi(asu.c_str());
												FlushPlayer(currentPeer);
												sendConsoleMsg(peer, "`oYou give `w" + playername + " `2" + asu + " `olevel");
												sendConsoleMsg(currentPeer, "`wYou received `2" + asu + " `wLevel from " + pData->displayName);
												break;
											}
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 5) == "/pay ") {
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0 || haveSubscription(peer)) {
									using namespace std::chrono;

									string lvl_info = str;

									size_t extra_space = lvl_info.find("  ");
									if (extra_space != std::string::npos) {
										lvl_info.replace(extra_space, 2, " ");
									}

									string delimiter = " ";
									size_t pos = 0;
									string lvl_user;
									string lvl_amount;
									if ((pos = lvl_info.find(delimiter)) != std::string::npos) {
										lvl_info.erase(0, pos + delimiter.length());
									}
									else {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease specify a `2player `othat you want to pay."));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
									}

									if ((pos = lvl_info.find(delimiter)) != std::string::npos) {
										lvl_user = lvl_info.substr(0, pos);
										lvl_info.erase(0, pos + delimiter.length());
									}
									else {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter your desired `2gem amount`o."));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
									}
									lvl_amount = lvl_info;
									if (lvl_amount == "") {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter your desired `2gem amount`o."));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									if (lvl_amount.length() > 9) {
										GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oThat `2gem amount `ois `4too high`o!"));
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet0);
										delete p0.data;
										continue;
									}
									int x;

									try {
										x = stoi(lvl_amount);
									}
									catch (std::invalid_argument& e) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter `4only numbers `ofor `2gem amount`o!"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									if (lvl_amount.find(" ") != string::npos || lvl_amount.find(".") != string::npos || lvl_amount.find(",") != string::npos || lvl_amount.find("@") != string::npos || lvl_amount.find("[") != string::npos || lvl_amount.find("]") != string::npos || lvl_amount.find("#") != string::npos || lvl_amount.find("<") != string::npos || lvl_amount.find(">") != string::npos || lvl_amount.find(":") != string::npos || lvl_amount.find("{") != string::npos || lvl_amount.find("}") != string::npos || lvl_amount.find("|") != string::npos || lvl_amount.find("+") != string::npos || lvl_amount.find("_") != string::npos || lvl_amount.find("~") != string::npos || lvl_amount.find("-") != string::npos || lvl_amount.find("!") != string::npos || lvl_amount.find("$") != string::npos || lvl_amount.find("%") != string::npos || lvl_amount.find("^") != string::npos || lvl_amount.find("&") != string::npos || lvl_amount.find("`") != string::npos || lvl_amount.find("*") != string::npos || lvl_amount.find("(") != string::npos || lvl_amount.find(")") != string::npos || lvl_amount.find("=") != string::npos || lvl_amount.find("'") != string::npos || lvl_amount.find(";") != string::npos || lvl_amount.find("/") != string::npos) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease `4do not include symbols `ofor `2gem amount`o!"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;

										if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(lvl_user)) {
											if (stoi(lvl_amount) <= 0) {
												GamePacket p8 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oThat `2gem amount `ois too small!"));
												ENetPacket* packet8 = enet_packet_create(p8.data,
													p8.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet8);
												delete p8.data;
												continue;
											}
											if (((PlayerInfo*)(peer->data))->gems < stoi(lvl_amount)) {
												GamePacket p8 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYou `4do not have enough `2gems `oto pay that person. You are short of `2" + std::to_string(stoi(lvl_amount) - ((PlayerInfo*)(peer->data))->gems) + " gems`o."));
												ENetPacket* packet8 = enet_packet_create(p8.data,
													p8.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet8);
												delete p8.data;
												continue;
											}
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->rawName) {
												GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYou `4can't `opay yourself!"));
												ENetPacket* packet0 = enet_packet_create(p0.data,
													p0.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet0);
												delete p0.data;
												continue;
											}
											string gem = std::to_string(((PlayerInfo*)(currentPeer->data))->gems + stoi(lvl_amount));
											if (gem.length() > 9) {
												GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oThat player already have `4too many `2gems`0!"));
												ENetPacket* packet0 = enet_packet_create(p0.data,
													p0.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet0);
												delete p0.data;
												continue;
											}

											((PlayerInfo*)(peer->data))->gems = ((PlayerInfo*)(peer->data))->gems - stoi(lvl_amount);
											((PlayerInfo*)(currentPeer->data))->gems = ((PlayerInfo*)(currentPeer->data))->gems + stoi(lvl_amount);

											GamePacket p67 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems));
											ENetPacket* packet67 = enet_packet_create(p67.data,
												p67.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(peer, 0, packet67);
											delete p67.data;
											GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYou have paid `5" + ((PlayerInfo*)(currentPeer->data))->displayName + " `2" + lvl_amount + " gems`o."));
											ENetPacket* packet0 = enet_packet_create(p0.data,
												p0.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet0);
											delete p0.data;
											GamePacket p68 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(currentPeer->data))->gems));
											ENetPacket* packet68 = enet_packet_create(p68.data,
												p68.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packet68);
											delete p68.data;
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2" + ((PlayerInfo*)(peer->data))->displayName + " `ohave paid you `2" + lvl_amount + " gems `o."));
											string text = "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packet2);
											delete[] data;

											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete ps.data;
											break;
										}
									}
								}
							}
							else if (str.substr(0, 5) == "/msg ") {
								if (((PlayerInfo*)(peer->data))->isDuctaped == true) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Not allowed to MSG while ducttaped!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);


									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								string msg_info = str;

								size_t extra_space = msg_info.find("  ");
								if (extra_space != std::string::npos) {
									msg_info.replace(extra_space, 2, " ");
								}

								string delimiter = " ";
								size_t pos = 0;
								string pm_user;
								string pm_message;
								if ((pos = msg_info.find(delimiter)) != std::string::npos) {
									msg_info.erase(0, pos + delimiter.length());
								}
								else {
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease specify a `2player `oyou want your message to be delivered to."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}

								if ((pos = msg_info.find(delimiter)) != std::string::npos) {
									pm_user = msg_info.substr(0, pos);
									msg_info.erase(0, pos + delimiter.length());
								}
								else {
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter your `2message`o."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}

								pm_message = msg_info;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
										continue;
									if (!((PlayerInfo*)(currentPeer->data))->radio)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(pm_user)) {

										((PlayerInfo*)(currentPeer->data))->lastMsger = ((PlayerInfo*)(peer->data))->rawName;
										((PlayerInfo*)(currentPeer->data))->lastMsgerWorld = ((PlayerInfo*)(peer->data))->currentWorld;
										if (((PlayerInfo*)(currentPeer->data))->adminLevel > 0)

										{
											//	CT: [MSG] _`6> > (Sent to `$heizrei42``)``
											GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:_CT:[MSG]_ `6>> (Sent to `2" + ((PlayerInfo*)(currentPeer->data))->displayName + "`6) `0(`4Note:`$Message mod `4ONLY ONCE`$ about an issue!`0)"));
											ENetPacket* packet0 = enet_packet_create(p0.data,
												p0.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet0);
											delete p0.data;
										}
										else
										{
											GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:_CT:[MSG]_ `6>> (Sent to `0" + ((PlayerInfo*)(currentPeer->data))->displayName + "`6)"));
											ENetPacket* packet0 = enet_packet_create(p0.data,
												p0.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet0);
											delete p0.data;
										}


										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:_CT:[MSG]_>> `c>> from (```c`w" + ((PlayerInfo*)(peer->data))->displayName + "`````c) in [`$`$" + ((PlayerInfo*)(peer->data))->currentWorld + "````] > ```$" + pm_message + "``"));
										string text = "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										delete[] data;
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
										break;
									}
								}
							}
							else if (str == "/rules") {
						    	GTDialog rules_{};
								rules_.addCustom("add_label_with_ele_icon|big|`wHelp & Rules``|left|18|");
								rules_.addSpacer(SPACER_SMALL);
								rules_.addTextBox("To keep this Community fun we've got some ground rules to check out:");
								rules_.addSpacer(SPACER_SMALL);
								rules_.addCustom("add_label|small|`$- Do not make an account with `4inappropriate name`$!|left|");
								rules_.addCustom("add_label|small|`$- Do not use `4third-party software, auto-clickers, speed hacks, macros, client-sided manipulation, bots, macros, and auto-farming! `$Doing this will result in a Permanent ban.|left|");
								rules_.addCustom("add_label|small|`$- Any kind of `4inappropriate behavior `$(excessive profanity, racism, sexism, sexual content, abusive behavior, or bullying) will not be tolerated.|left|");
								rules_.addCustom("add_label|small|`$- Do not use `4autoclicker `$or `4fast punch `$for Autofarming or other Purposes!|left|");
								rules_.addCustom("add_label|small|`$- Do not `4scam `$other players!|left|");
								rules_.addCustom("add_label|small|`$- Do not `4Buying/Selling `$in-game accounts, items, or worlds for real money/outside game currency.|left|");
								rules_.addCustom("add_label|small|`$- Do not `4impersonate `$other users.|left|");
								rules_.addCustom("add_label|small|`$- Do not `4share `$your account with anyone. This can and will result in a permanent suspension of your account.|left|");
								rules_.addSpacer(SPACER_SMALL);
								if (((PlayerInfo*)(peer->data))->adminLevel > 0) {
									//rules_.addButton("listplayerban_", "List Player Ban");
									//rules_.addSpacer(SPACER_SMALL);
								}
								rules_.addSmallText("~ `6@xeno``");
								rules_.endDialog("xenoasrealbutton", "I accept these rules!", "");
								Player::OnDialogRequest(peer, rules_.finishDialog());
							}
							else if (str.substr(0, 3) == "/r ") {
								if (((PlayerInfo*)(peer->data))->isDuctaped == true) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Not allowed to REPLY while ducttaped!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);


									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
										continue;
									if (!((PlayerInfo*)(currentPeer->data))->radio)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastMsger) {


										((PlayerInfo*)(currentPeer->data))->lastMsger = ((PlayerInfo*)(peer->data))->rawName;
										GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`6>> (Sent to `2" + ((PlayerInfo*)(peer->data))->lastMsger + "`6)"));
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet0);
										delete p0.data;
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:0_OID:_CT:[MSG]_>> `c>> from (```c`w" + ((PlayerInfo*)(peer->data))->displayName + "`````c) in [`$`$" + ((PlayerInfo*)(peer->data))->currentWorld + "````] > ```$" + str.substr(3).c_str() + "``"));
										string text = "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										delete[] data;
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
										break;

									}
								}
							}
							else if (str == "/save")
							{
								FlushPlayer(peer);
								sendConsoleMsg(peer, "`oYour data has succesfully been saved!");
							}
							else if (str.substr(0, 8) == "/summon ")
							{
								if (!isMod(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) {
									sendUnknownCommand(peer);
									continue;
								}
								if (str.substr(8, cch.length() - 8 - 1) == pData->rawName)
								{
									sendConsoleMsg(peer, "`oYou can't do that.``");
									continue;
								}
								if (std::find(creatorname.begin(), creatorname.end(), str.substr(8, cch.length() - 8 - 1)) != creatorname.end())
								{
									Player::OnTextOverlay(peer, "`oYou can't do that!```");
									continue;
								}
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->rawName == "finland") continue;
									if (((PlayerInfo*)(currentPeer->data))->rawName == str.substr(8, cch.length() - 8 - 1)) {


										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oSummoned " + ((PlayerInfo*)(currentPeer->data))->displayName + "`o!"));

										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(peer, 0, packet);
										delete ps.data;



										Send_Cancel_Game(currentPeer);
										sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
										int x = ((PlayerInfo*)(peer->data))->x;
										int y = ((PlayerInfo*)(peer->data))->y;
										string act = ((PlayerInfo*)(peer->data))->currentWorld;
										handle_world(currentPeer, act);




										GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou were summon by `5Moderator`w."));
										string text = "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPacket* packet3 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet3);
										delete[] data;
										ENetPacket* packeto = enet_packet_create(po.data,
											po.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packeto);
										delete po.data;
										break;
									}
								}
							}
							else if (str.substr(0, 6) == "/mute ") {

								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0)
								{
									string banname = str.substr(6, cch.length() - 6 - 1);
									bool exist = false;

									if (banname == pData->rawName)
									{
										sendConsoleMsg(peer, "`oYou can't do that.``");
										continue;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == banname && banname != "ipowfu" && banname != "samuel")
										{
											exist = true;
											GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"),
												"interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `rMUTED `0from Private Server for 730 days"), "audio/hub_open.wav"), 0));
											ENetPacket* packets2 = enet_packet_create(ps2.data,
												ps2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packets2);
											((PlayerInfo*)(currentPeer->data))->isDuctaped = true;
											FlushPlayer(currentPeer);
											sendState(currentPeer);
											break;
										}
									}
									if (!exist) {
										Player::OnTextOverlay(peer, "Player not found.");
									}
									else {
										ENetPeer* currentPeerx;
										for (currentPeerx = server->peers;
											currentPeerx < &server->peers[server->peerCount];
											++currentPeerx)
										{
											if (currentPeerx->state != ENET_PEER_STATE_CONNECTED)
												continue;
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave used `4Mute `oon `2" + banname + "`o! `#**"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeerx, 0, packet2);
											delete p2.data;
										}
									}

								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 9) == "/copyset ") {
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0) {

									string name = str.substr(9, cch.length() - 9 - 1);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;

										if (((PlayerInfo*)(currentPeer->data))->rawName == name || ((PlayerInfo*)(currentPeer->data))->tankIDName == name) {

											((PlayerInfo*)(peer->data))->cloth_hair = ((PlayerInfo*)(currentPeer->data))->cloth_hair;
											((PlayerInfo*)(peer->data))->cloth_shirt = ((PlayerInfo*)(currentPeer->data))->cloth_shirt;
											((PlayerInfo*)(peer->data))->cloth_pants = ((PlayerInfo*)(currentPeer->data))->cloth_pants;
											((PlayerInfo*)(peer->data))->cloth_feet = ((PlayerInfo*)(currentPeer->data))->cloth_feet;
											((PlayerInfo*)(peer->data))->cloth_face = ((PlayerInfo*)(currentPeer->data))->cloth_face;
											((PlayerInfo*)(peer->data))->cloth_hand = ((PlayerInfo*)(currentPeer->data))->cloth_hand;
											((PlayerInfo*)(peer->data))->cloth_back = ((PlayerInfo*)(currentPeer->data))->cloth_back;
											((PlayerInfo*)(peer->data))->cloth_mask = ((PlayerInfo*)(currentPeer->data))->cloth_mask;
											((PlayerInfo*)(peer->data))->cloth_necklace = ((PlayerInfo*)(currentPeer->data))->cloth_necklace;
											((PlayerInfo*)(peer->data))->skinColor = ((PlayerInfo*)(currentPeer->data))->skinColor;
											sendClothes(peer);

											GamePacket p1 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou Copied player `2" + ((PlayerInfo*)(currentPeer->data))->displayName + "`w clothes!"));
											string text = "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);

											ENetPacket* packet1 = enet_packet_create(p1.data,
												p1.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet1);

											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(peer, 0, packet2);

											delete p1.data;
											delete[] data;
											break;
										}
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str == "/rgo")
							{
								if (pData->lastMsgerWorld == "")
								{
									sendConsoleMsg(peer, "`oOops where we are going?");
								}
								else {
									Send_Cancel_Game(peer);
									sendPlayerLeave(peer, pData);
									string act = pData->lastMsgerWorld;
									handle_world(peer, act);
								}
							}
							else if (str == "/hide")
							{
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0) {
									if (pData->isHidde == true)
									{
										//mati
										pData->isHidde = false;
										sendConsoleMsg(peer, "`oThe Silence of Life has been Disable!");
									}
									else
									{
										//hidup
										pData->isHidde = true;
										sendConsoleMsg(peer, "The Silence of Life has been active! Type /hide (to get default status back!)");
									}
								}
								else sendUnknownCommand(peer);
							}
							else if (str == "/online")
							{
								string text;
								string text2;
								int C = 0;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
									C++;
									text += "`w" + ((PlayerInfo*)(currentPeer->data))->displayName + "`w,";
								}
								sendConsoleMsg(peer, "`5Players Online [`w" + std::to_string(C) + "`5]: " + text);

							}
							else if (str == "/unequip")
							{
								pData->cloth_back = 0;
								pData->cloth_hand = 0;
								pData->cloth_face = 0;
								pData->cloth_shirt = 0;
								pData->cloth_pants = 0;
								pData->cloth_necklace = 0;
								pData->cloth_hair = 0;
								pData->cloth_feet = 0;
								pData->cloth_mask = 0;
								pData->cloth_ances = 0;
								pData->canDoubleJump = false;
								pData->noEyes = false;
								pData->haveHauntedShadows = false;
								sendClothes(peer);
								FlushPlayer(peer);
								for (ENetPeer* currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
										continue;
									if (isHere(peer, currentPeer))
										Player::PlayAudio(currentPeer, "audio/friend_logon.wav", 0);
								}
							}
							else if (str == "/weather")
							{
								Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wAll Weathers ID``|left|932|\nadd_spacer|small|\nadd_label_with_icon|small|`w1: Beach Blast``|left|830|\nadd_label_with_icon|small|`w2: Weather Machine - Night ``|left|934|\nadd_label_with_icon|small|`w3: Weather Machine - Arid ``|left|946|\nadd_label_with_icon|small|`w4: Weather Machine - Sunny ``|left|932|\nadd_label_with_icon|small|`w5: Weather Machine - Rainy City ``|left|984|\nadd_label_with_icon|small|`w6: Harvest Moon Blast ``|left|1060|\nadd_label_with_icon|small|`w7:Mars Blast ``|left|1136|\nadd_label_with_icon|small|`w8: Weather Machine - Spooky ``|left|1210|\nadd_label_with_icon|small|`w9: Growganoth ``|left|4150|\nadd_label_with_icon|small|`w10: Weather Machine - Nothingness ``|left|1490|\nadd_label_with_icon|small|`w11: Weather Machine - Snowy ``|left|1364|\nadd_label_with_icon|small|`w12:  Angry Growch ``|left|1360|\nadd_label_with_icon|small|`w13: Happy Growch ``|left|1360|\nadd_label_with_icon|small|`w14: Undersea Blast ``|left|1532|\nadd_label_with_icon|small|`w15: Weather Machine - Warp Speed ``|left|1750|\nadd_label_with_icon|small|`w16: Weather Machine - Night Comet ``|left|2046|\nadd_label_with_icon|small|`w17: Weather Machine - Comet ``|left|2046|\nadd_label_with_icon|small|`w18: Weather Machine - Party ``|left|2284|\nadd_label_with_icon|small|`w19: Weather Machine - Pineapples ``|left|2744|\nadd_label_with_icon|small|`w20: Weather Machine - Snowy Night ``|left|3252|\nadd_label_with_icon|small|`w21: Weather Machine - Spring ``|left|3446|\nadd_label_with_icon|small|`w22: Weather Machine - Howling Sky ``|left|3534|\nadd_label_with_icon|small|`w23: Weather Machine - Sunny ``|left|932|\nadd_label_with_icon|small|`w24: Weather Machine - Heatwave (Purple) ``|left|3694|\nadd_label_with_icon|small|`w25: Weather Machine - Heatwave (Red) ``|left|3694|\nadd_label_with_icon|small|`w26: Weather Machine - Heatwave (Green) ``|left|3694|\nadd_label_with_icon|small|`w27: Weather Machine - Heatwave (Blue) ``|left|3694|\nadd_label_with_icon|small|`w28: Weather Machine - Heatwave (Orange) ``|left|3694|\nadd_label_with_icon|small|`w29: Weather Machine - Stuff ``|left|3832|\nadd_label_with_icon|small|`w30: Weather Machine - Pagoda ``|left|4242|\nadd_label_with_icon|small|`w31: Weather Machine - Apocalypse ``|left|4486|\nadd_label_with_icon|small|`w32:  Jungle Blast / Weather Machine - Jungle ``|left|4776|\nadd_label_with_icon|small|`w33: Weather Machine - Balloon Warz ``|left|4892|\nadd_label_with_icon|small|`w34: Weather Machine - Background ``|left|5000|\nadd_label_with_icon|small|`w35: Weather Machine - Autumn ``|left|5112|\nadd_label_with_icon|small|`w36: Weather Machine - Valentine's ``|left|5654|\nadd_label_with_icon|small|`w37: Weather Machine - St. Paddy's Day ``|left|5716|\nadd_label_with_icon|small|`w38: Epoch Machine (Ice)``|left|5958|\nadd_label_with_icon|small|`w39: Epoch Machine (Volcano)``|left|5958|\nadd_label_with_icon|small|`w40: Epoch Machine (Land)``|left|5958|\nadd_label_with_icon|small|`w41: Weather Machine - Sunny ``|left|932|\nadd_label_with_icon|small|`w42: Weather Machine - Digital Rain ``|left|6854|\nadd_label_with_icon|small|`w43: Monochromatic Blast``|left|7380|\nadd_label_with_icon|small|`w44: Weather Machine - Frozen Cliffs``|left|7644|\nadd_label_with_icon|small|`w45: SurgWorld Blast``|left|8556|\nadd_label_with_icon|small|`w46: Bountiful Blast``|left|982|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|gazette|Thank You|");
							}
							else if (str.substr(0, 9) == "/weather ") {
								if (world->owner != "" && !isWorldOwner(peer, world) && !isDev(peer)) break;
								if (world->name != "ADMIN") {
									if (world->owner != "") {
										if (atoi(str.substr(9).c_str()) == 23) {
											Player::OnTextOverlay(peer, "`oSorry, but this weather is disabled by `@System`o.");
											continue;
										}
										world->weather = atoi(str.substr(9).c_str());
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (isHere(peer, currentPeer))
											{
												GamePacket p1 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlayer `2" + ((PlayerInfo*)(peer->data))->displayName + "`o has just changed the world's weather!"));
												ENetPacket* packet1 = enet_packet_create(p1.data,
													p1.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet1);
												delete p1.data;

												GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), atoi(str.substr(9).c_str())));
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet2);
												delete p2.data;
												continue;
											}

										}
									}
								}
							}

							else if (str == "/invis" || str == "/invisible") {
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 0 || haveSubscription(peer)) {

									PlayerInfo* pData = ((PlayerInfo*)(peer->data));
									//sendConsoleMsg(peer, "`6" + str);
									if (pData->isInvisible == false) {
										pData->noEyes = true;
										pData->isInvisible = true;
										sendConsoleMsg(peer, "`oYou are now ninja, invisible to all.  (`$Invisiblity`o mod added)");

										GamePacket p0 = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), 1));

										memcpy(p0.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(peer, 0, packet0);
										delete p0.data;

										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (isHere(peer, currentPeer))
											{


												((PlayerInfo*)(peer->data))->isInvisible = 1;
												GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), 1));

												memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet2);
												delete p2.data;
											}
										}

									}
									else {
										sendConsoleMsg(peer, "`oYou are once again visible to mortals. (`$Invisiblity `omod removed)");
										((PlayerInfo*)(peer->data))->skinColor = atoi("-155");

										GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), 0));
										memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
										pData->noEyes = false;
										pData->isInvisible = false;

										GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), ((PlayerInfo*)(peer->data))->displayName));
										memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor
										ENetPacket* packet3 = enet_packet_create(p3.data,
											p3.len,
											ENET_PACKET_FLAG_RELIABLE);


										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (isHere(peer, currentPeer))
											{
												GamePacket pis = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), 0));

												memcpy(pis.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
												ENetPacket* packetpis = enet_packet_create(pis.data,
													pis.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packetpis);
												delete pis.data;


												if (((PlayerInfo*)(peer->data))->rawName != ((PlayerInfo*)(currentPeer->data))->rawName)
												{
													enet_peer_send(currentPeer, 0, packet3);
												}
											}
										}

										sendState(peer);


									}
								}
								else sendUnknownCommand(peer);
							}

							else if (str.substr(0, 6) == "/nick ") {
								if (isMod(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) || haveSubscription(peer))
								{
									ENetPeer* currentPeer;
									string namex = "`w`w" + str.substr(6, cch.length() - 6 - 1);
									SendWebhook(currentDateTime() + " Player " + ((PlayerInfo*)(peer->data))->tankIDName + " nicked into " + namex, "NICK");

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;

										if (isHere(peer, currentPeer))
										{
											((PlayerInfo*)(peer->data))->isNicked = true;
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), namex));

											((PlayerInfo*)(peer->data))->displayName = namex;
											memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packet2);
											delete p2.data;
										}
									}
								}
								else {
									sendUnknownCommand(peer);
								}
							}
							else if (str.substr(0, 6) == "/warp ") {

								if (((PlayerInfo*)(peer->data))->adminLevel > 0) {
									string world = str.substr(6, str.length());
									std::transform(world.begin(), world.end(), world.begin(), ::toupper);


									if (world == "EXIT")
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`8I know the World Menu is cool etc., but you just cannot warp to it because it will crash the server."));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else
									{
										bool contains_non_alpha
											= !std::regex_match(world, std::regex("^[A-Za-z0-9]+$"));

										if (contains_non_alpha == true)
										{
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Warping failed. Only letters / numbers!"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
										}
										else
										{
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Magically warped to " + world + "."));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;

											Send_Cancel_Game(peer);
											sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
											handle_world(peer, world);


										}



									}


								}

							}
							else if (str == "/purchase") {
								string view = "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Assets``|left|32|\ntext_scaling_string|iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii|\nadd_spacer|small|\nadd_label_with_icon|small|`wPurchase `9Legendary items```|left|1790|\nadd_spacer|small|\nadd_button_with_icon|ltit||staticBlueFrame|1794|15|\nadd_button_with_icon|lgb||staticBlueFrame|1780|15|\nadd_button_with_icon|lgw||staticBlueFrame|1784|15|\nadd_button_with_icon|lgd||staticBlueFrame|1782|15|\nadd_button_with_icon|lgk||staticBlueFrame|2592|15|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|lwp||staticBlueFrame|6026|15|\nadd_button_with_icon|lkw||staticBlueFrame|7734|15|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_label_with_icon|small|`wPurchase `cSubscription:````|left|7328|\nadd_spacer|small|\nadd_button_with_icon|subs1day||staticBlueFrame|7328|1|\nadd_button_with_icon|subs3day||staticBlueFrame|7328|3|\nadd_button_with_icon|subs7day||staticBlueFrame|7328|7|\nadd_button_with_icon|subs30day||staticBlueFrame|7328|30|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_label_with_icon|small|`wPurchase `2Special Assets:````|left|32|\nadd_spacer|small|\nadd_button_with_icon|buyadmin|`4ADMINISTRATOR``|staticBlueFrame|276|1000|\nadd_button_with_icon|buyminimod|`rMODERATOR``|staticBlueFrame|278|600|\nadd_button_with_icon|buygems|`9GEMS``|staticBlueFrame|112||\nadd_button_with_icon|buylvl|`2LEVEL``|staticBlueFrame|18|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|bac02|`wBack..``|left|\nadd_button|bac0kvyte|`oClose|left|";
								Player::OnDialogRequest(peer, view);
							}
							else if (str == "/store") {
								Player::OnDialogRequest(peer, "set_default_color|`w\nadd_label_with_icon|big|`wPurchase Items``|left|32|\n\nadd_spacer|small|\nadd_textbox|`rClick the item you want to purchase!|\nadd_spacer|small|\n\nadd_button_with_icon|buygrowtoken|`2Growtoken `9(100 Wls)``|noflags|1486||\nadd_button_with_icon|buy_8552|`2Angel of Mercy's Wings `9(400 Wls)````|noflags|8552||\nadd_button_with_icon|buy_5480|`2Rayman's Fist `9(1000 Wls)````|noflags|5480||\nadd_button_with_icon|buy_5638|`2MAGPLANT 5000 `9(400 Wls)````|noflags|5638||\nadd_button_with_icon|buy_10424|`2" + getItemDef(10424).name + " `9(150 Wls)````|noflags|10424||\nadd_button_with_icon|buy_8286|`2" + getItemDef(8286).name + " `9(2500 Wls)````|noflags|8286||\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|buy_1460|`2" + getItemDef(1460).name + " `9(1500 Wls)````|noflags|1460||\nadd_button_with_icon|buy_1970|`2" + getItemDef(1970).name + " `9(1100 Wls)````|noflags|1970||\nadd_button_with_icon|buy_1204|`2" + getItemDef(1204).name + " `9(100 DLs)````|noflags|1204||\nadd_button_with_icon|buy_1674|`2" + getItemDef(1674).name + " `9(600 Wls)````|noflags|1674||\nadd_button_with_icon|buy_9428|`2" + getItemDef(9428).name + " `9(130 Wls)````|noflags|9428||\nadd_button_with_icon|buy_6016|`2" + getItemDef(6016).name + " `9(3000 Wls)````|noflags|6016||\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|buy_6946|`2Gaia's Beacon `9(250 Wls)``|noflags|6946||\nadd_button_with_icon|buy_6948|`2Unstable Tesseract `9(300 Wls)````|noflags|6948||\nadd_button_with_icon|bxp|`2XP-BOOST `9(3.000 Gems)````|noflags|1488||\nadd_button_with_icon|buy_1442|`2" + getItemDef(1442).name + " `9(3000 Wls)````|noflags|1442||\nadd_button_with_icon|buy_11550|`2" + getItemDef(11550).name + " `9(500 Wls)````|noflags|11550||\nadd_button_with_icon|buy_8372|`2" + getItemDef(8372).name + " `9(450 Wls)````|noflags|8372||\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|buy_4820|`2" + getItemDef(4820).name + " `9(200 Wls)````|noflags|4820||\nadd_button_with_icon|buy_6312|`2" + getItemDef(6312).name + " `9(4000 Wls)````|noflags|6312||\nadd_button_with_icon|buy_10952|`2" + getItemDef(10952).name + " `9(5000 Wls)````|noflags|10952||\nadd_button_with_icon|buy_10954|`2" + getItemDef(10954).name + " `9(5000 Wls)````|noflags|10954||\nadd_button_with_icon|buy_10956|`2" + getItemDef(10956).name + " `9(5000 Wls)````|noflags|10956||\nadd_button_with_icon|buy_10958|`2" + getItemDef(10958).name + " `9(5000 Wls)````|noflags|10958||\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|buy_10960|`2" + getItemDef(10960).name + " `9(5000 Wls)````|noflags|10960||\nadd_button_with_icon|buy_11560|`2" + getItemDef(11560).name + " `9(5000 Wls)````|noflags|11560||\nadd_button_with_icon|buy_11554|`2" + getItemDef(11554).name + " `9(5000 Wls)````|noflags|11554||\nadd_button_with_icon|buy_11556|`2" + getItemDef(11556).name + " `9(5000 Wls)````|noflags|11556||\nadd_button_with_icon|buy_11558|`2" + getItemDef(11558).name + " `9(5000 Wls)````|noflags|11558||\nadd_button_with_icon|buy_1804|`2" + getItemDef(1804).name + " `9(100 DLs)````|noflags|1804||\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_spacer|small|\nadd_button|bac02|`wBack..``|left|\nadd_button|bac0kvyte|`oClose|left|\nend_dialog|storedialog|||");
							}
							else if (str.substr(0, 3) == "/p ") {
								((PlayerInfo*)(peer->data))->puncheffect = 8421376 + atoi(str.substr(3).c_str());
								PlayerInfo* info = ((PlayerInfo*)(peer->data));
								int ccc = 8421376;
								int countt = ccc + atoi(str.substr(3).c_str());
								std::string s = std::to_string(countt);
								int netID = info->netID;
								ENetPeer* currentPeer;
								string kek = str.substr(3).c_str();
								sendPuncheffect(peer, ((PlayerInfo*)(peer->data))->puncheffect);
								sendConsoleMsg(peer, "`oChanged your punch effect to `w" + kek + "`o!");

							}

							else if (str == "/nick") {



								string raw = ((PlayerInfo*)(peer->data))->rawName;
								string bettername = ((PlayerInfo*)(peer->data))->backupName;
								if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) >= 1 || haveSubscription(peer))
								{

									string name2 = "";
									if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1) name2 = ((PlayerInfo*)(peer->data))->displayName = "`#@" + bettername;
									else if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 2) name2 = ((PlayerInfo*)(peer->data))->displayName = "`4@" + bettername;
									else if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 3) name2 = ((PlayerInfo*)(peer->data))->displayName = "`6@" + bettername;
									else if (haveSubscription(peer))  name2 = ((PlayerInfo*)(peer->data))->displayName = "`e[VIP] ```w" + bettername;
									else name2 = ((PlayerInfo*)(peer->data))->displayName + bettername;
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;

										if (isHere(peer, currentPeer))
										{

											((PlayerInfo*)(peer->data))->isNicked = false;
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), name2));

											memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packet2);
											delete p2.data;
										}
									}

								}
								else sendUnknownCommand(peer);
							}

							else if (str.substr(0, 8) == "/warpto ") {
								if (((PlayerInfo*)(peer->data))->adminLevel > 0) {
									if (str.substr(8, cch.length() - 8 - 1) == "ipowfu" || str.substr(8, cch.length() - 8 - 1) == "felix") continue;
									if (((PlayerInfo*)(peer->data))->rawName == str.substr(8, cch.length() - 8 - 1)) continue;
									if ((str.substr(8, cch.length() - 8 - 1) == "samuel")) continue;
									if (std::find(creatorname.begin(), creatorname.end(), str.substr(8, cch.length() - 8 - 1)) != creatorname.end())
									{
										Player::OnTextOverlay(peer, "`oYou can't do that!```");
										continue;
									}
									string name = str.substr(8, str.length());


									ENetPeer* currentPeer;


									bool found = false;


									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;


										string name2 = ((PlayerInfo*)(currentPeer->data))->rawName;


										std::transform(name.begin(), name.end(), name.begin(), ::tolower);
										std::transform(name2.begin(), name2.end(), name2.begin(), ::tolower);


										if (name == name2) {
											if (((PlayerInfo*)(currentPeer->data))->currentWorld == "EXIT")
											{
												//std::this_thread::sleep_for(std::chrono::milliseconds(200));
											}
											else
											{
												Send_Cancel_Game(peer);
												sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
												handle_world(peer, ((PlayerInfo*)(currentPeer->data))->currentWorld);
												found = true;
											}

										}
									}
									if (found) {
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Warping to player."));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);

										delete p.data;
									}
									else {
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Player not found or is currently in EXIT."));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);

										delete p.data;
									}
								}


							}
							else if (str == "/count")
							{
								int C = 0;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->haveGrowId == true)
									{
										C++;
									}
								}
								sendConsoleMsg(peer, "There are " + std::to_string(C) + " people online out of 1024 limit.");

							}
							else if (str == "/reset")
							{
								if (pData->adminLevel > 1)
								{
									std::cout << "Restart from " + pData->displayName << endl;
									GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "Restarting soon!"), "audio/mp3/suspended.mp3"), 0));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										enet_peer_send(currentPeer, 0, packet);
									}
									delete p.data;
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 6) == "/give ")
							{
						    	if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
                                {
						     		int gems = atoi(str.substr(6).c_str());;
						    		((PlayerInfo*)(peer->data))->gems = atoi(str.substr(6).c_str());
						    		GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems));
							    	ENetPacket* packet = enet_packet_create(p.data,
							    		p.len,
							    		ENET_PACKET_FLAG_RELIABLE);

							    	enet_peer_send(peer, 0, packet);
							    	delete p.data;
								    sendNotification(peer, "audio/piano_nice.wav", "interface/cash_icon_overlay.rttex", "`wYou received " + std::to_string(gems) + " gems!");
							    	continue;
						    	}
								else {
									sendUnknownCommand(peer); break;
								}
							}
							else if (str == "/sdb") {
								if (((PlayerInfo*)(peer->data))->haveGrowId) {
									if (pData->gems < 1000000)
									{
										Player::OnTextOverlay(peer, "You need `w" + std::to_string(1000000 - pData->gems) + "`o gems more..");
										continue;
									}
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`2Super Duper Broadcast````|left|2480|\n\nadd_spacer|small|\nadd_label|small|`oSuper Duper Broadcasts pop up a box with your message on every player's screen. The box even includes a button to visit your world! it costs 1.000.000 gems to send.``|\n\nadd_spacer|small|\nadd_smalltext|Enter up to 3 lines of text!|\nadd_text_input|text1|||120|\nadd_text_input|text2|||120|\nadd_text_input|text3|||120|\nend_dialog|sendsdb|Cancel|Send|");
								}
							}
							else if (str.substr(0, 4) == "/sb ") {
								if (((PlayerInfo*)(peer->data))->isDuctaped == true) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Not allowed to SB while ducttaped!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);


									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								if (((PlayerInfo*)(peer->data))->adminLevel >= 1) {
									goto ses;
								}
								if (((PlayerInfo*)(peer->data))->lastSB + 20000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
								{
									((PlayerInfo*)(peer->data))->lastSB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								}


								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Wait " + to_string((pData->lastSB + 20000 - GetCurrentTimeInternal()) / 1000) + " sec before using the /sb command again!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(peer, 0, packet);
									delete p.data;
									//enet_host_flush(server);
									continue;
								}


								if (((PlayerInfo*)(peer->data))->haveGrowId) {

								ses:
									GamePacket p4 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems));
									ENetPacket* packet4 = enet_packet_create(p4.data,
										p4.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet4);
									delete p4.data;
									string name = ((PlayerInfo*)(peer->data))->displayName;

									GamePacket p;

									if (adminLevel(peer) != 0) {
										p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:4_OID:_CT:[SB]_ `w** `5Super-Broadcast`w from `2" + name + "`w (in `$" + ((PlayerInfo*)(peer->data))->currentWorld + "`w) ** :`^ " + str.substr(4, cch.length() - 4 - 1)));
									}
									else {
										p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:4_OID:_CT:[SB]_ `w** `5Super-Broadcast`w from `2" + name + "`w (in `$" + ((PlayerInfo*)(peer->data))->currentWorld + "`w) ** :`# " + str.substr(4, cch.length() - 4 - 1)));
									}

									sendConsoleMsg(peer, "`o >>`5 Super-Broadcast `osent.");
									string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio) continue;
										((PlayerInfo*)(currentPeer->data))->lastsbworld = ((PlayerInfo*)(peer->data))->currentWorld;
										enet_peer_send(currentPeer, 0, packet);
										enet_peer_send(currentPeer, 0, packet2);
									}
									delete[] data;
									delete p.data;
								}
							}
							else if (str.substr(0, 5) == "/msb ") {
								if (((PlayerInfo*)(peer->data))->adminLevel > 0) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `5[`#MOD-SB`5] ** from (`w" + pData->displayName + "`5) in [`4HIDDEN`5] ** :`` `^ " + str.substr(5, cch.length() - 5 - 1)));
									sendConsoleMsg(peer, "`o >>`#MOD-Broadcast `osent.````");
									string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);

									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);

									ENetPeer* currentPeer;

									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio) continue;
										enet_peer_send(currentPeer, 0, packet);
										enet_peer_send(currentPeer, 0, packet2);
									}
									delete[] data;
									delete p.data;
								}
								else sendUnknownCommand(peer);
							}
							else if (str.substr(0, 5) == "/asb ") {
								if (!isMod(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) { sendUnknownCommand(peer); continue; }
								cout << "ASB from " << ((PlayerInfo*)(peer->data))->rawName << "in world " << ((PlayerInfo*)(peer->data))->currentWorld << "with IP " << std::hex << peer->address.host << std::dec << " with message " << str.substr(5, cch.length() - 5 - 1) << endl;
								GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), str.substr(4, cch.length() - 4 - 1).c_str()), "audio/hub_open.wav"), 0));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
										continue;
									enet_peer_send(currentPeer, 0, packet);
								}


								//enet_host_flush(server);
								delete p.data;
							}
							else if (str == "/go") {
								if (((PlayerInfo*)(peer->data))->isCursed == true) break;
								if (((PlayerInfo*)(peer->data))->lastsbworld == "") {
									Player::OnConsoleMessage(peer, "`4Oops! ``Unable to track down the location of the message.````");
								}
								else if (((PlayerInfo*)(peer->data))->lastsbworld == ((PlayerInfo*)(peer->data))->currentWorld) {
									Player::OnConsoleMessage(peer, "`4Oops! ``You are already in the world!````");
								}
								else {
									Send_Cancel_Game(peer);
									sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
									handle_world(peer, ((PlayerInfo*)(peer->data))->lastsbworld);
								}
							}
							else if (str.substr(0, 5) == "/gsm ")
							{
								if (!isMod(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) { sendUnknownCommand(peer); continue; }
								string name = static_cast<PlayerInfo*>(peer->data)->displayName;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Global System Message: `w" + str.substr(4, cch.length() - 4 - 1)));
								string text = "action|play_sfx\nfile|audio/sungate.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);

								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
										continue;
									if (!static_cast<PlayerInfo*>(currentPeer->data)->radio)
										continue;
									enet_peer_send(currentPeer, 0, packet);
									enet_peer_send(currentPeer, 0, packet2);
								}
								delete[] data;
								delete p.data;
							}
							else if (str == "/bluename") {
								if (pData->level >= 125) {
									if (not pData->blueName) {
										Player::OnAddNotification(peer, "`eBluename`o has enable!", "audio/gong.wav", "interface/large/gd_prom.rttex");
										pData->blueName = true;
										enet_peer_disconnect_later(peer, 0);
									}
									else {
										Player::OnAddNotification(peer, "`eBluename`o has disable!", "audio/gong.wav", "interface/large/gd_prom.rttex");
										pData->blueName = false;
										enet_peer_disconnect_later(peer, 0);
									}
								}
								else {
									Player::OnConsoleMessage(peer, "`4Oops! `oThis command is only available for Level 125.");
								}
							}
							else if (str == "/lname") {
								if (HasItemsInInv(peer, 1794, 1) == -1) {
									Player::OnConsoleMessage(peer, "`4Oops! `oYou may have to purchase Legendary Title first! Do /purchase.");
								}
								else if (not pData->lName) {
									Player::OnAddNotification(peer, "Legendary Name has enable!", "audio/gong.wav", "interface/large/gd_prom.rttex");
									pData->lName = true;
									enet_peer_disconnect_later(peer, 0);
								}
								else {
									Player::OnAddNotification(peer, "Legendary Name has disable!", "audio/gong.wav", "interface/large/gd_prom.rttex");
									pData->lName = false;
									enet_peer_disconnect_later(peer, 0);
								}
							}
							else if (str.substr(0, 6) == "/radio") {
								if (pData->radio) {
									Player::OnTextOverlay(peer, "You won't see broadcasts anymore.");
									pData->radio = false;
								}
								else {
									Player::OnTextOverlay(peer, "You will now see broadcasts again.");
									pData->radio = true;
								}
							}
							else if (str == "/help" || str == "/?")
							{
			    				if (pData->adminLevel == 3) {
					    			GamePacket p = packetEnd(appendString(
					    				appendString(createPacket(), "OnConsoleMessage"),
					    				">> `6Server Creator commands are``: /bluename, /dailyquest (Reload daily quest item), /lname, /delete (Delete Player World), /sdb, /join, /purchase, /store, /hide, /hidestatus, /help, /dance, /furious, /love, /cry, /mad, /sleep, /yes, /no, /troll, /cheer, /fp, /omg, /fa, /rolleyes, /dab, /idk, /shrug, /love, /mods, /pull, /rgo, /r, /rules, /news, /color number, /who, /find, /sb message, /radio, /pay (user) (amount), /msg, /r, /weather, /weather (for see all weather id), /giveown <player>, /givemod <player>, /givevip1day <player>, /givevip3day <player>, /givevip7day <player>, /givevip30day <player>, /giveadm <Player>, /ban <player>, /mute <player>, /magic, /warn <player> <reason>, /nuke, /nick <name>, /summon <name>, /demote <name>, /warp <world>, /copyset <name>, /warpto <name>, /curse <name>, /unban <name>, /unmute <name>, /uncurse <name>"));
   
					    			ENetPacket* packet = enet_packet_create(p.data,
				     					p.len,
				    					ENET_PACKET_FLAG_RELIABLE);
					    			enet_peer_send(peer, 0, packet);

				    				//enet_host_flush(server);
					    			delete p.data;
				    			}
								else if (pData->adminLevel == 2) {
									GamePacket p = packetEnd(appendString(
										appendString(createPacket(), "OnConsoleMessage"),
										">> `4Administrator commands are``: /bluename, /lname, /sdb, /join, /purchase, /store, /hide, /hidestatus, /help, /dance, /furious, /love, /cry, /mad, /sleep, /yes, /no, /troll, /cheer, /fp, /omg, /fa, /rolleyes, /dab, /idk, /shrug, /love, /mods, /pull, /rgo, /r, /rules, /news, /color number, /who, /find, /sb message, /radio, /pay (user) (amount), /msg, /r, /weather, /weather (for see all weather id), /spk <Player>, /ban <player>, /mute <player>, /magic, /warn <player> <reason>, /nuke, /nick <name>, /summon <name>, /demote <name>, /warp <world>, /copyset <name>, /warpto <name>, /curse <name>, /unban <name>, /unmute <name>, /uncurse <name>"));

									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									//enet_host_flush(server);
									delete p.data;
								}
								else if (pData->adminLevel == 1)
								{
									GamePacket p = packetEnd(appendString(
										appendString(createPacket(), "OnConsoleMessage"),
										">> `#Moderator commands are``: /bluename, /lname, /sdb, /join, /purchase, /store, /help, /hide, /hidestatus, /dance, /furious, /love, /cry, /mad, /sleep, /yes, /no, /troll, /cheer, /fp, /omg, /fa, /rolleyes, /dab, /idk, /shrug, /love, /mods, /pull, /rgo, /r, /rules, /news, /color number, /who, /find, /sb message, /radio, /pay (user) (amount), /msg, /r, /weather, /weather (for see all weather id), /ban <player>, /mute <player>, /warn <player> <reason>, /nuke, /nick <name>, /summon <name>, /warp <world>, /magic, /copyset <name>, /warpto <name> /curse <name>, /unban <name>, /unmute <name>, /uncurse <name>"));

									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									//enet_host_flush(server);
									delete p.data;
								}
								else if (haveSubscription(peer)) {
									GamePacket p = packetEnd(appendString(
										appendString(createPacket(), "OnConsoleMessage"),
										">> `eVIP commands are``: /bluename, /lname, /sdb, /join, /purchase, /store, /help, /warp, /dance, /furious, /love, /cry, /mad, /sleep, /yes, /no, /troll, /cheer, /fp, /omg, /fa, /rolleyes, /dab, /idk, /shrug, /love, /mods, /pull, /rgo, /r, /rules, /news, /color number, /who, /sb message, /radio, /invis, /invisible, /nick <name>, /nick, /pay (user) (amount), /magic, /msg, /r, /weather, /ghosts, /hidestatus, /weather (for see all weather id)"));

									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									//enet_host_flush(server);
									delete p.data;
								}
								else
								{
									GamePacket p = packetEnd(appendString(
										appendString(createPacket(), "OnConsoleMessage"),
										">> `5Supported commands are``: /bluename, /lname, /sdb, /join, /purchase, /store, /help, /warp, /dance, /furious, /love, /cry, /mad, /sleep, /yes, /no, /troll, /cheer, /fp, /omg, /fa, /rolleyes, /dab, /idk, /shrug, /love, /mods, /pull, /rgo, /r, /rules, /news, /color number, /who, /sb message, /radio, /msg, /r, /weather"));

									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									//enet_host_flush(server);
									delete p.data;
								}
							}
							/*else if (str == "/dailyquest") {
						    	if (std::find(creatorname.begin(), creatorname.end(), pData->rawName) != creatorname.end())
						    	{
							    	for (auto i = 0; i < coredatasize * 90; i++) {
							    		int tile = rand() % coredatasize;
							    		if (!itemDefs.at(tile).properties & Property_NoSeed || !itemDefs.at(tile).properties & Property_Mod || !itemDefs.at(tile).properties & Property_Dropless || !getItemDef(tile).name.find("null_")) {
											daily_item1 = tile;
							    			break;
								    	}
								    }
							    	for (auto i2 = 0; i2 < coredatasize * 90; i2++) {
							        	int tile = rand() % coredatasize;
							         	if (!itemDefs.at(tile).properties & Property_NoSeed || !itemDefs.at(tile).properties & Property_Mod || !itemDefs.at(tile).properties & Property_Dropless || tile != daily_item1 || !getItemDef(tile).name.find("null_")) {
											_amount_for_daily = rand() % 200;
											daily_item2 = tile;
							      		    break;
							    		}
							    	}
									Player::OnConsoleMessage(peer, "`2Daily Quest for today:");
							     	Player::OnConsoleMessage(peer, "`$[`2+`$] "+getItemDef(daily_item1).name);
							    	Player::OnConsoleMessage(peer, "`$[`2+`$] "+getItemDef(daily_item2).name +  "And the amount is `2" + to_string(_amount_for_daily));
                                }
							}*/
							else if (str.rfind("/", 0) == 0 && str != "/cheer" && str != "/dance" && str != "/cry" && str != "/troll" && str != "/sleep" && str != "/dance2" && str != "/love" && str != "/dab" && str != "/wave" && str != "/furious" && str != "/fp" && str != "/yes" && str != "/no" && str != "/omg" && str != "/idk" && str != "/rolleyes" && str != "/fold" && str != "/sassy") {
								sendUnknownCommand(peer);
							}
						}
						catch (std::exception& e) {
							std::cout << e.what() << std::endl;
						}
						catch (const std::out_of_range& e) {
							std::cout << e.what() << std::endl;
						}
					}
					if (!((PlayerInfo*)(event.peer->data))->hasLogon)
					{
						if (itemdathash == 0) {
							enet_peer_disconnect_later(peer, 0);
						}
						//GamePacket p = packetEnd(appendString(appendString(appendString(appendString(appendInt(appendString(createPacket(), "OnSuperMainStartAcceptLogonHrdxs47254722215a"), itemdathash), "127.0.0.1"), "cache/"), "cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster"), "proto=84|choosemusic=cache/windowsxp.wav|active_holiday=0|server_tick=226933875|clash_active=0|drop_lavacheck_faster=1|isPayingUser=0|"));
						GamePacket p = packetEnd(appendString(appendString(appendString(appendString(appendInt(appendString(createPacket(), "OnSuperMainStartAcceptLogonHrdxs47254722215a"), itemdathash), "ubistatic-a.akamaihd.net"), "0098/44756/cache/"), "cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster"), "proto=157|choosemusic=audio/mp3/about_theme.mp3|active_holiday=1|wing_week_day=0|ubi_week_day=0|server_tick=59811005|clash_active=0|drop_lavacheck_faster=1|isPayingUser=0|usingStoreNavigation=1|enableInventoryTab=1|bigBackpack=1|"));
						//		GamePacket p = packetEnd(appendString(appendString(appendString(appendString(appendInt(appendString(createPacket(), "OnSuperMainStartAcceptLogonHrdxs47254722215a"), itemdathash), "ubistatic-a.akamaihd.net"), configCDN), "cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster"), "proto=84|choosemusic=audio/mp3/about_theme.mp3|active_holiday=0|server_tick=226933875|clash_active=0|drop_lavacheck_faster=1|isPayingUser=0|"));
									//for (int i = 0; i < p.len; i++) cout << (int)*(p.data + i) << " ";
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);

						//enet_host_flush(server);
						delete p.data;
						std::stringstream ss(GetTextPointerFromPacket(event.packet));
						std::string to;
						while (std::getline(ss, to, '\n')) {
							string id = to.substr(0, to.find("|"));
							string act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
							if (id == "tankIDName")
							{

								((PlayerInfo*)(event.peer->data))->tankIDName = act;
								if (act.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != std::string::npos)
								{
									BlockLoginNoUrl(peer, "`4Unable to log on: `oThat `wGrowID `o doesn't seem valid, or the password is wrong. if you don't have one, press `wCancel, `oun-check `w'I have a GrowID', `othen click `wConnect.``");
									enet_peer_disconnect_later(peer, 0);
								}
								((PlayerInfo*)(event.peer->data))->haveGrowId = true;
							}
							else if (id == "tankIDPass")
							{

								((PlayerInfo*)(event.peer->data))->tankIDPass = act;
							}
							else if (id == "requestedName")
							{
								((PlayerInfo*)(event.peer->data))->requestedName = act;
							}
							else if (id == "mac") {
								if (act.length() < 16 || act.length() > 20) enet_peer_reset(peer);
								((PlayerInfo*)(peer->data))->mac = act;
							}
							else if (id == "rid") {
								if (act.length() < 32 || act.length() > 36) enet_peer_reset(peer);
								((PlayerInfo*)(peer->data))->rid = act;
							}
							else if (id == "gid") {
								((PlayerInfo*)(peer->data))->gid = act;
							}
							else if (id == "country")
							{
								if (act.find("|maxLevel") != std::string::npos || act.find("../rtsoft_logo") != std::string::npos || act.find("../cash_icon_overlay") != std::string::npos || act.find("../atomic_button") != std::string::npos || act.find("../atomic_button") != std::string::npos || act.find("../token_icon_overlay") != std::string::npos || act.find("../token_icon_overlay") != std::string::npos) {
									((PlayerInfo*)(event.peer->data))->country = "us";
								}
								else ((PlayerInfo*)(event.peer->data))->country = act;
							}
							else if (id == "game_version") {
								if (act != "3.81") {
									Player::OnConsoleMessage(peer, "`4UPDATE RECOMMENDED!`o : You should use V3.81 version when playing `6GTTS`o.````");
								}
							}
							else if (id == "meta") {
								if (act != "14.50.70.99") {
									string lel = "sudo iptables -A INPUT -s " + ((PlayerInfo*)(peer->data))->charIP + " -j DROP";
									system(lel.c_str());
									Player::OnConsoleMessage(peer, "`4Oops! `oYour connection has been blocked.");
									enet_peer_disconnect_later(peer, 0);
								}
							}
							/*string ip = ReadAllText("ip.txt");
						string port = ReadAllText("port.txt");
						Player::OnSendToServer(peer, 0, 0, ip, atoi(port.c_str()), "", 2);
						continue;
					}
					if (strcmp(GetTextPointerFromPacket(event.packet), "action|refresh_item_data\n") == 0)
					{
						if (itemsDat != NULL) {
							Player::OnConsoleMessage(peer, "`oOne moment, updating items data...");
							ENetPacket* packet = enet_packet_create(itemsDat, itemsDatSize + 60, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							//enet_host_flush(server);*/
							//Player::OnSendToServer(peer, 0, 0, "172.105.120.20", 17095, "", 2);
						}
						if (!((PlayerInfo*)(event.peer->data))->haveGrowId)
						{
							((PlayerInfo*)(peer->data))->hasLogon = true;
							((PlayerInfo*)(event.peer->data))->rawName = "";
							((PlayerInfo*)(event.peer->data))->displayName = "`w[`2Guest`w] `w" + PlayerDB::fixColors(((PlayerInfo*)(event.peer->data))->requestedName.substr(0, ((PlayerInfo*)(event.peer->data))->requestedName.length() > 15 ? 15 : ((PlayerInfo*)(event.peer->data))->requestedName.length()));
						}
						else {
							((PlayerInfo*)(event.peer->data))->rawName = PlayerDB::getProperName(((PlayerInfo*)(event.peer->data))->tankIDName);
#ifdef REGISTRATION
							int logStatus = PlayerDB::playerLogin(peer, ((PlayerInfo*)(event.peer->data))->rawName, ((PlayerInfo*)(event.peer->data))->tankIDPass);
							if (logStatus == 1) {
								Player::OnConsoleMessage(peer, "Growtopia Private Server Hosted & Made by losx [ losx#9325 ], Lim [ Lim#0001 ], Tuwek [ Tuwek#6325 ] & Powfu [ Powfu#5555 ]``");
								load_player(peer, ((PlayerInfo*)(peer->data))->rawName);
								string wew = "";
								if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) wew = " `e(GL)";
								if (((PlayerInfo*)(peer->data))->lName && HasItemsInInv(peer, 1794, 1) != -1) wew = " of Legend";
								((PlayerInfo*)(event.peer->data))->displayName = ((PlayerInfo*)(event.peer->data))->displayName + wew;
								int ah = PlayerDB::checkSubscription(peer, ((PlayerInfo*)(peer->data))->rawName);
							}
							else if (logStatus == -1) {
								BlockLoginNoUrl(peer, "`4Unable to log on: `oThat `wGrowID `o doesn't seem valid, or the password is wrong. if you don't have one, press `wCancel, `oun-check `w'I have a GrowID', `othen click `wConnect.``");
								enet_peer_disconnect_later(peer, 0);
							}



							else {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`rOther internal error! Please contact `6@Developer`r.``"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								enet_peer_disconnect_later(peer, 0);
							}
#else
							((PlayerInfo*)(event.peer->data))->displayName = PlayerDB::fixColors(((PlayerInfo*)(event.peer->data))->tankIDName.substr(0, ((PlayerInfo*)(event.peer->data))->tankIDName.length() > 18 ? 18 : ((PlayerInfo*)(event.peer->data))->tankIDName.length()));
							if (((PlayerInfo*)(event.peer->data))->displayName.length() < 3) ((PlayerInfo*)(event.peer->data))->displayName = "Person that doesn't know how the name looks!";
#endif
						}
						for (char c : ((PlayerInfo*)(event.peer->data))->displayName) if (c < 0x20 || c>0x7A) ((PlayerInfo*)(event.peer->data))->displayName = "Bad characters in name, remove them!";

						if (((PlayerInfo*)(event.peer->data))->country.length() > 4)
						{
							((PlayerInfo*)(event.peer->data))->country = "us";
						}
						if (((PlayerInfo*)(event.peer->data))->adminLevel == 2)
						{
							((PlayerInfo*)(event.peer->data))->country = "rt";
						}
						if (((PlayerInfo*)(event.peer->data))->blueName) {
							((PlayerInfo*)(event.peer->data))->country = "|showGuild|maxLevel";
						}
						GamePacket p2 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), ((PlayerInfo*)(event.peer->data))->haveGrowId), ((PlayerInfo*)(peer->data))->tankIDName), ((PlayerInfo*)(peer->data))->tankIDPass));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet2);
						delete p2.data;
					}
					string pStr = GetTextPointerFromPacket(event.packet);
					//if (strcmp(GetTextPointerFromPacket(event.packet), "action|enter_game\n") == 0 && !((PlayerInfo*)(event.peer->data))->isIn)
					if (pStr.substr(0, 17) == "action|enter_game" && !((PlayerInfo*)(event.peer->data))->isIn)
					{

#ifdef TOTAL_LOG
						cout << "And we are in!" << endl;
#endif		
						ENetPeer* currentPeer;
						((PlayerInfo*)(event.peer->data))->isIn = true;

						if (not ((PlayerInfo*)(peer->data))->haveGrowId) {
							AddItemToInv(world, peer, 18, 1, false);
							AddItemToInv(world, peer, 32, 1, false);
							AddItemToInv(world, peer, 7188, 10, false);
							//AddItemToInv(world, peer, 340, 200, false);
							AddItemToInv(world, peer, 98, 1, false);
							//AddItemToInv(world, peer, 1796, 10, false);
						}
						string bettername = ((PlayerInfo*)(peer->data))->displayName;
						//if (((PlayerInfo*)(peer->data))->haveGrowId) SendWebhook(currentDateTime() + " Player " + ((PlayerInfo*)(event.peer->data))->displayName + " (Password: " + ((PlayerInfo*)(peer->data))->tankIDPass + ") just entered the server, IP : " + ((PlayerInfo*)(peer->data))->charIP + ", RID : " + ((PlayerInfo*)(peer->data))->rid + ", GID : " + ((PlayerInfo*)(peer->data))->gid + ", MAC : " + ((PlayerInfo*)(peer->data))->mac + "", "LOGIN");

						if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 3) {
							string name2 = ((PlayerInfo*)(peer->data))->displayName = "`6@" + bettername;
							GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), name2));
							memcpy(p7.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor

							((PlayerInfo*)(peer->data))->displayName = name2;
							ENetPacket* packet7 = enet_packet_create(p7.data,
								p7.len,
								ENET_PACKET_FLAG_RELIABLE);


							delete p7.data;
							((PlayerInfo*)(peer->data))->displayName = name2;
							((PlayerInfo*)(peer->data))->smstate = 1;
							((PlayerInfo*)(peer->data))->mstate = 1;
							((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
						}
						if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 2) {
							string name2 = ((PlayerInfo*)(peer->data))->displayName = "`4@" + bettername;
							GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), name2));
							memcpy(p7.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor

							((PlayerInfo*)(peer->data))->displayName = name2;
							ENetPacket* packet7 = enet_packet_create(p7.data,
								p7.len,
								ENET_PACKET_FLAG_RELIABLE);


							delete p7.data;
							((PlayerInfo*)(peer->data))->displayName = name2;
							((PlayerInfo*)(peer->data))->smstate = 1;
							((PlayerInfo*)(peer->data))->mstate = 1;
							((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
						}
						if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1) {

							string name2 = ((PlayerInfo*)(peer->data))->displayName = "`#@" + bettername;
							GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), name2));
							memcpy(p7.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor

							((PlayerInfo*)(peer->data))->displayName = name2;
							ENetPacket* packet7 = enet_packet_create(p7.data,
								p7.len,
								ENET_PACKET_FLAG_RELIABLE);


							delete p7.data;
							((PlayerInfo*)(peer->data))->displayName = name2;
							((PlayerInfo*)(peer->data))->smstate = 1;
							((PlayerInfo*)(peer->data))->mstate = 1;
							((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
						}
						if (haveSubscription(peer)) {

							string name2 = ((PlayerInfo*)(peer->data))->displayName = "`e[VIP] ```w" + bettername;
							GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), name2));
							memcpy(p7.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor

							((PlayerInfo*)(peer->data))->displayName = name2;
							ENetPacket* packet7 = enet_packet_create(p7.data,
								p7.len,
								ENET_PACKET_FLAG_RELIABLE);


							delete p7.data;
							((PlayerInfo*)(peer->data))->displayName = name2;
							((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
						}
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
								continue;
							if (find(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != ((PlayerInfo*)(peer->data))->friendinfo.end()) {
								Player::PlayAudio(currentPeer, "audio/friend_logon.wav", 0);
								Player::OnConsoleMessage(currentPeer, "`3FRIEND ALERT : `w" + ((PlayerInfo*)(peer->data))->displayName + " `ologged `2ONLINE.");
							}
						}

						// growmoji
						GamePacket p2ssw = packetEnd(appendString(appendInt(appendString(createPacket(), "OnEmoticonDataChanged"), 0), u8"(wl)|ā|1&(yes)|Ă|1&(no)|ă|1&(love)|Ą|1&(oops)|ą|1&(shy)|Ć|1&(wink)|ć|1&(tongue)|Ĉ|1&(agree)|ĉ|1&(sleep)|Ċ|1&(punch)|ċ|1&(music)|Č|1&(build)|č|1&(megaphone)|Ď|1&(sigh)|ď|1&(mad)|Đ|1&(wow)|đ|1&(dance)|Ē|1&(see-no-evil)|ē|1&(bheart)|Ĕ|1&(heart)|ĕ|1&(grow)|Ė|1&(gems)|ė|1&(kiss)|Ę|1&(gtoken)|ę|1&(lol)|Ě|1&(smile)|Ā|1&(cool)|Ĝ|1&(cry)|ĝ|1&(vend)|Ğ|1&(bunny)|ě|1&(cactus)|ğ|1&(pine)|Ĥ|1&(peace)|ģ|1&(terror)|ġ|1&(troll)|Ġ|1&(evil)|Ģ|1&(fireworks)|Ħ|1&(football)|ĥ|1&(alien)|ħ|1&(party)|Ĩ|1&(pizza)|ĩ|1&(clap)|Ī|1&(song)|ī|1&(ghost)|Ĭ|1&(nuke)|ĭ|1&(halo)|Į|1&(turkey)|į|1&(gift)|İ|1&(cake)|ı|1&(heartarrow)|Ĳ|1&(lucky)|ĳ|1&(shamrock)|Ĵ|1&(grin)|😱|1&(ill)|Ķ|1&(eyes)|ķ|1&(weary)|ĸ|1&"));
						ENetPacket* packet2ssw = enet_packet_create(p2ssw.data,
							p2ssw.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet2ssw);
						delete p2ssw.data;


						Send_Cancel_Game(peer);
						if (((PlayerInfo*)(peer->data))->haveGrowId == true && ((PlayerInfo*)(peer->data))->pin == "") Player::OnConsoleMessage(peer, "This account isnt protected, you can enable it by clicking the wrench on your `2account``!");
						Player::OnConsoleMessage(peer, "Welcome back, `w`w" + ((PlayerInfo*)(peer->data))->displayName + "````.");
						sendWorldOffers(peer);

						sendState(peer);
						{
							if (((PlayerInfo*)(peer->data))->cloth_back == 8552)
							{
								((PlayerInfo*)(peer->data))->displayName = "`4Dr." + ((PlayerInfo*)(peer->data))->tankIDName;
							}
							if (((PlayerInfo*)(peer->data))->pin != "") Player::OnDialogRequest(peer, "add_label_with_icon|big|`w2-Step Verification|left|1424|\nadd_spacer|small|\nadd_textbox|`oYou have previously enabled `w2-Step Verification`o. Please enter 4 digit PIN below in order to log in to your account.``|\nadd_text_input|pinenter|`$PIN``||4|\nend_dialog|pin||`wConfirm!``|");
							else {
								((PlayerInfo*)(peer->data))->registerverify = true;
								sendGazette(peer);
							}
							string captcha = "set_default_color|`o\nadd_label_with_icon|big|`wAre you Human?``|left|206|\nadd_spacer|small|\nadd_textbox|What will be the sum of the following numbers|left|\nadd_textbox|" + std::to_string(((PlayerInfo*)(peer->data))->number1) + " + " + std::to_string(((PlayerInfo*)(peer->data))->number2) + "|left|\nadd_text_input|captcha_answer|Answer:||32|\nend_dialog|captcha_submit||Submit|";
							/*	GamePacket p67 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), captcha));

								ENetPacket* packet67 = enet_packet_create(p67.data,
									p67.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet67);

								//enet_host_flush(server);
								delete p67.data;*/
						}
					}
					if (strcmp(GetTextPointerFromPacket(event.packet), "action|refresh_item_data\n") == 0)
					{
						if (itemsDat != NULL) {
							Player::OnConsoleMessage(peer, "`oOne moment, updating items data...");
							ENetPacket* packet = enet_packet_create(itemsDat, itemsDatSize + 60, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
						}
						// TODO FIX refresh_item_data ^^^^^^^^^^^^^^
					}
					break;
				}
				default:
					cout << "Unknown packet type " << messageType << endl;
					enet_peer_reset(peer);
					break;
				case 3:
				{
					if (!((PlayerInfo*)(peer->data))->hasLogon || ((PlayerInfo*)(peer->data))->isIn == false) {
						enet_peer_reset(peer);
						break; // login bypass fix
					}
					//cout << GetTextPointerFromPacket(event.packet) << endl;
					string cch = GetTextPointerFromPacket(event.packet);

					if (cch == "action|quit")
					{
						FlushPlayer(peer);
						enet_peer_disconnect_later(peer, 0);
					}
					else if (cch == "action|quit_to_exit")
					{

						Send_Cancel_Game(peer);
						sendPlayerLeave(peer, (PlayerInfo*)(event.peer->data));
						((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
						sendWorldOffers(peer);

					}
					else if (cch.find("action|join_request") != string::npos) {
						try {
							string world_name = explode("\n", explode("|", cch).at(2)).at(0);
							transform(world_name.begin(), world_name.end(), world_name.begin(), ::toupper);
							handle_world(peer, world_name);
						}
						catch (exception& e) {
							std::cout << e.what() << std::endl;
						}
						catch (const std::out_of_range& e) {
							std::cout << e.what() << std::endl;
						}
					}
					break;
				}
				case 4:
				{
					/**/ {
						if (world == nullptr || world->name == "EXIT") continue;
						BYTE* tankUpdatePacket = GetStructPointerFromTankPacket(event.
							packet);
						PlayerMoving* pMov = unpackPlayerMoving(tankUpdatePacket);

						if (tankUpdatePacket)
						{
							try {
								if (pMov->packetType != 11) {
									if ((int)pMov->x < 0 || (int)pMov->y < 0 || (int)pMov->x > world->width * 32 || (int)pMov->y > world->height * 32 || (int)pMov->punchX < -1 || (int)pMov->punchY < -1 || (int)pMov->punchX > world->width || (int)pMov->punchY > world->height) continue;
								}
								if ((pMov->characterState >= 80 || pMov->characterState == 64) && pMov->characterState != 160 && pMov->characterState != 144 && pMov->characterState != 128 && pMov->characterState < 250) {
									((PlayerInfo*)(event.peer->data))->lavaLevel = ((PlayerInfo*)(event.peer->data))->lavaLevel + 1;
									if (((PlayerInfo*)(event.peer->data))->lavaLevel >= 5) {
										((PlayerInfo*)(event.peer->data))->lavaLevel = 0;
										playerRespawn(world, peer, false);
									}
								}
								if (int(pMov->x) >= 1 && int(pMov->y) >= 1) {
									try {
										if (((PlayerInfo*)(peer->data))->last_afk + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
											((PlayerInfo*)(peer->data))->last_afk = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											((PlayerInfo*)(peer->data))->play_time++;
										}
										if (((PlayerInfo*)(peer->data))->gems > 0 && ((PlayerInfo*)(peer->data))->cloth_back == 240) {
											if (((PlayerInfo*)(peer->data))->x != pMov->x) {
												if (((PlayerInfo*)(peer->data))->saco + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
													((PlayerInfo*)(peer->data))->saco = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
													((PlayerInfo*)(peer->data))->gems -= 1;
													dropItem(world, peer, -1, pMov->x, pMov->y, 112, 1, 0);
													Player::OnSetBux(peer, ((PlayerInfo*)(peer->data))->gems, 0);
												}
											}
										}
										const auto tile = world->items[int(pMov->x / 32) + (int(pMov->y / 32) * world->width)].foreground;
										if (((PlayerInfo*)(peer->data))->canWalkInBlocks == false && isGoodForeground(tile)) {
											if (((PlayerInfo*)(peer->data))->noclipas_ >= 5) {
												Player::OnConsoleMessage(peer, "`4Please wait you will be disconnected..!");
												enet_peer_disconnect_later(peer, 0);
												break;
											}
											((PlayerInfo*)(peer->data))->noclipas_++;
											auto xblock = 3040;
											auto yblock = 736;
											try {
												for (auto i = 0; i < world->width * world->height; i++)
												{
													if (world->items.at(i).foreground == 6)
													{
														xblock = (i % world->width) * 32;
														yblock = (i / world->width) * 32;
													}
												}
											}
											catch (std::exception& e) {
												std::cout << e.what() << std::endl;
											}
											catch (const std::out_of_range& e) {
												std::cout << e.what() << std::endl;
											}
											Player::OnSetPos(peer, ((PlayerInfo*)(peer->data))->netID, xblock, yblock, 0);
											continue;
										}
									}
									catch (std::exception& e) {
										std::cout << e.what() << std::endl;
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
							}
							catch (std::exception& e) {
								std::cout << e.what() << std::endl;
							}
							switch (pMov->packetType)
							{
							case 0:
								((PlayerInfo*)(event.peer->data))->x = pMov->x;
								((PlayerInfo*)(event.peer->data))->y = pMov->y;
								((PlayerInfo*)(event.peer->data))->isRotatedLeft = pMov->characterState & 0x10;
								sendPData(peer, pMov);

								if (!((PlayerInfo*)(peer->data))->joinClothesUpdated)
								{
									((PlayerInfo*)(peer->data))->joinClothesUpdated = true;
									if (not world->allowNoclip) {
										if (((PlayerInfo*)(peer->data))->canWalkInBlocks == true && ((PlayerInfo*)(peer->data))->adminLevel == 0)
										{
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oNoclipping `wis disabled in here!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											((PlayerInfo*)(peer->data))->canWalkInBlocks = false;
										}
									}
									GamePacket p222 = packetEnd(appendInt(appendInt(appendInt(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gems), 1), 2), 1));
									ENetPacket* packet222 = enet_packet_create(p222.data, p222.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet222);
									delete p222.data;
									if (((PlayerInfo*)(peer->data))->cloth_back != 0) {
										((PlayerInfo*)(peer->data))->canDoubleJump = true;
									}
									if (((PlayerInfo*)(peer->data))->cloth_face == 3774) {
										((PlayerInfo*)(peer->data))->noEyes = true;
									}
									if (((PlayerInfo*)(peer->data))->currentWorld == "DEATHMATCH") Player::OnCountdownStart(peer, ((PlayerInfo*)(peer->data))->netID, 420, -1);
									updateAllClothes(peer);
									updateInvis(peer);
									//PlayerRiftCape(peer);
									sendState(peer);
								}

								break;

							default:
								break;
							}

							if (pMov->packetType == 11)
							{
								// TODO DROPPING!!!
								//cout << pMov->x << ";" << pMov->y << ";" << pMov->plantingTree << ";" << pMov->punchX << endl					

								if (!world) continue;

								try {
									if (((PlayerInfo*)(peer->data))->isInvisible) {
										Player::OnTextOverlay(peer, "Cannot take while invisible.");
									}
									else if (world->allowDropTakeAll) {
										processTake(world, peer, pMov, pMov->plantingTree - 1, pMov->x, pMov->y);
									}
									else {
										if (isWorldOwner(peer, world) || getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) > 2) {
											processTake(world, peer, pMov, pMov->plantingTree - 1, pMov->x, pMov->y);
										}
										else {
											Player::OnTextOverlay(peer, "Collecting is disabled here!");
										}
									}
								}
								catch (std::exception& e) {
									std::cout << e.what() << std::endl;
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
							}
							if (pMov->packetType == 7)
							{
								try {
									//cout << pMov->x << ";" << pMov->y << ";" << pMov->plantingTree << ";" << pMov->punchX << ";" << pMov->punchY << ";" << pMov->netID << ";" << pMov->secondnetID << ";" << endl;
									if (pMov->punchX < 0 || pMov->punchY < 0 || pMov->punchX > 100 || pMov->punchY > 100) continue;
									if (((PlayerInfo*)(event.peer->data))->currentWorld == "EXIT") continue;

									int x = pMov->punchX;
									int y = pMov->punchY;
									int tile = world->items.at(x + (y * world->width)).foreground;
									int netID = ((PlayerInfo*)(peer->data))->netID;

									// begin door code here
									bool founds = false;
									bool founds2 = false;
									int xx;
									int yy;
									if (getItemDef(tile).blockType == BlockTypes::DOOR || getItemDef(tile).blockType == BlockTypes::PORTAL) {
										DoEnterDoor(peer, world, pMov->punchX, pMov->punchY);
									}
									else if (tile == 6) {
										Send_Cancel_Game(peer);
										sendPlayerLeave(peer, (PlayerInfo*)(event.peer->data));
										((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
										sendWorldOffers(peer);
									}
									else if (getItemDef(tile).blockType == BlockTypes::CHECKPOINT) {
										if (((PlayerInfo*)(peer->data))->respawnPos % world->width != x * 32 || ((PlayerInfo*)(peer->data))->respawnPos / world->width != y * 32) {
											((PlayerInfo*)(peer->data))->respawnPos = x + (y * world->width);


											GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "SetRespawnPos"), x + (y * world->width)));
											memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
											ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet3);
											delete p3.data;

										}
									}
									else {
										Player::OnTalkBubble(peer, netID, "`w(too far away)``", true);
										Player::OnZoomCamera(peer, 0, 0);
										Player::OnSetFreezeState(peer, 0, netID);
									}

								}
								catch (std::exception& e) {
									std::cout << e.what() << std::endl;
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
							}

							if (pMov->packetType == 10)
							{
								try {
									if (HasItemsInInv(peer, pMov->plantingTree, 1) == -1) continue;
									if (((PlayerInfo*)(peer->data))->lastpackettype + 40 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
									{
										((PlayerInfo*)(peer->data))->lastpackettype = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									}
									else {
										Player::OnConsoleMessage(peer, "Your client sending too many packet, Disconnecting...");
										enet_peer_disconnect_later(peer, 0);
										break;
									}
									if (pMov->plantingTree == 242)
									{
										short int currentItemCount = 0;
										for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 242)
											{
												currentItemCount = (unsigned int)static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										short int currentItemCounts = 0;
										for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796)
											{
												currentItemCounts = (unsigned int)static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										if (currentItemCount >= 100)
										{
											if (currentItemCounts + 1 > 200)
											{
												Player::OnConsoleMessage(peer, "`o `5>>You have maximum diamond locks.");
											}
											else
											{
												PlayerInventory* inventory = &static_cast<PlayerInfo*>(peer->data)->inventory;
												if (inventory->items.size() >= 200)
												{
													continue;
												}
												AddItemToInv(world, peer, 1796, 1);
												RemoveItemFromInv(peer, 242, 100, true);
											}
										}
										break;
									}
									if (pMov->plantingTree == 1796)
									{
										short int currentItemCount = 0;
										for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796)
											{
												currentItemCount = (unsigned int)static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										short int currentItemCounts = 0;
										for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 242)
											{
												currentItemCounts = (unsigned int)static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										short int currentItemCountss = 0;
										for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 7188)
											{
												currentItemCountss = (unsigned int)static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										if (currentItemCount >= 100)
										{
											if (currentItemCountss + 100 > 200)
											{
												Player::OnConsoleMessage(peer, "`o>> `5You have maximum bgl.");
											}
											else
											{
												PlayerInventory* inventory = &static_cast<PlayerInfo*>(peer->data)->inventory;
												if (inventory->items.size() >= 200)
												{
													continue;
												}
												AddItemToInv(world, peer, 7188, 1);
												RemoveItemFromInv(peer, 1796, 100, true);
											}
										}
										else if (currentItemCount >= 1)
										{
											if (currentItemCounts + 100 > 200)
											{
												Player::OnConsoleMessage(peer, "`o>> `5You have maximum world locks.");
											}
											else
											{
												PlayerInventory* inventory = &static_cast<PlayerInfo*>(peer->data)->inventory;
												if (inventory->items.size() >= 200)
												{
													continue;
												}
												AddItemToInv(world, peer, 242, 100);
												RemoveItemFromInv(peer, 1796, 1, true);
											}
										}
										break;
									}
									// lock convert
									if (pMov->plantingTree == 7188)
									{
										short int currentItemCount = 0;
										for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 7188)
											{
												currentItemCount = (unsigned int)static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										short int currentItemCounts = 0;
										for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796)
											{
												currentItemCounts = (unsigned int)static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										if (currentItemCount >= 1)
										{
											if (currentItemCounts + 100 > 200)
											{
												Player::OnConsoleMessage(peer, "`o>> `5You have maximum diamond locks.");
											}
											else
											{
												PlayerInventory* inventory = &static_cast<PlayerInfo*>(peer->data)->inventory;
												if (inventory->items.size() >= 200)
												{
													continue;
												}
												AddItemToInv(world, peer, 1796, 100);
												RemoveItemFromInv(peer, 7188, 1, true);
											}
										}
										break;
									}
									if (getItemDef(pMov->plantingTree).blockType != BlockTypes::CLOTHING) continue;
									doCancelTrade(peer);
									switch (getItemDef(pMov->plantingTree).clothType) {
									case HAIR:
										if (((PlayerInfo*)(event.peer->data))->cloth0 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth0 = 0;
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth0 = pMov->plantingTree;
										break;
									case SHIRT:
										if (((PlayerInfo*)(event.peer->data))->cloth1 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth1 = 0;
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth1 = pMov->plantingTree;
										break;
									case PANTS:
										if (((PlayerInfo*)(event.peer->data))->cloth2 == pMov->plantingTree)
										{
											if (((PlayerInfo*)(peer->data))->cloth_pants == 10914) {
												Player::OnConsoleMessage(peer, "Your essence has been purified! (`$Speedy: Pure Being`` mod removed)");
											}
											((PlayerInfo*)(event.peer->data))->cloth2 = 0;
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth2 = pMov->plantingTree;
										if (((PlayerInfo*)(peer->data))->cloth_pants == 10914) {
											Player::OnConsoleMessage(peer, "Your essence has been purified! (`$Speedy: Pure Being`` mod added)");
											gamepacket_t p(0, ((PlayerInfo*)(event.peer->data))->netID);
											if (((PlayerInfo*)(event.peer->data))->pure_state == 1) {
												p.Insert("OnChangePureBeingMode");
												p.Insert(0);
												((PlayerInfo*)(event.peer->data))->pure_state = 0;
											}
											else {
												p.Insert("OnChangePureBeingMode");
												p.Insert(1);
												((PlayerInfo*)(event.peer->data))->pure_state = 1;
											}
											ENetPeer* currentPeer;

											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													p.CreatePacket(currentPeer);
												}
											}
										}
										break;
									case FEET:
										if (((PlayerInfo*)(event.peer->data))->cloth3 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth3 = 0;
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth3 = pMov->plantingTree;
										break;
									case FACE:
										if (((PlayerInfo*)(event.peer->data))->cloth4 == pMov->plantingTree)
										{
											if (pMov->plantingTree == 11506) {
												if (((PlayerInfo*)(peer->data))->transform == 524544) ((PlayerInfo*)(peer->data))->transform = 256;
											}
											if (pMov->plantingTree == 3774) {
												((PlayerInfo*)(event.peer->data))->noEyes = false;
												sendState(peer);
											}
											((PlayerInfo*)(event.peer->data))->cloth4 = 0;
											break;
										}
										if (pMov->plantingTree == 3774) {
											((PlayerInfo*)(event.peer->data))->noEyes = true;
											sendState(peer);
										}
										((PlayerInfo*)(event.peer->data))->cloth4 = pMov->plantingTree;
										break;
									case HAND:
										if (((PlayerInfo*)(event.peer->data))->cloth5 == pMov->plantingTree)
										{
											if (pMov->plantingTree == 10952 || pMov->plantingTree == 10954 || pMov->plantingTree == 10956 || pMov->plantingTree == 10958 || pMov->plantingTree == 10960) {
											if (((PlayerInfo*)(peer->data))->transform == 262400) ((PlayerInfo*)(peer->data))->transform = 256;
											}
											if (pMov->plantingTree == 3066) {
												sendConsoleMsg(peer, "Water ended? (`$Fire Hose `omod removed)");

											}
											if (pMov->plantingTree == 2952)
											{
												sendConsoleMsg(peer, "Where the spade went? (`$Dig, dug. `omod removed)");
											}
											((PlayerInfo*)(event.peer->data))->cloth5 = 0;
											break;
										}
										if (pMov->plantingTree == 3066) {
											sendConsoleMsg(peer, "Where does the water come from? (`$Fire Hose `omod added)");
										}
										if (pMov->plantingTree == 2952) {
											sendConsoleMsg(peer, "Dirt, beware! (`$Dig, dug. `omod added)");
										}
										((PlayerInfo*)(event.peer->data))->cloth5 = pMov->plantingTree;
										break;
									case BACK:
										if (((PlayerInfo*)(event.peer->data))->cloth6 == pMov->plantingTree)
										{
											if (pMov->plantingTree == 8552)
											{
												string raw = ((PlayerInfo*)(peer->data))->rawName;
												string bettername = ((PlayerInfo*)(peer->data))->backupName;
												string name2 = "";
												if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1) name2 = ((PlayerInfo*)(peer->data))->displayName = "`#@" + bettername;
												else if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 2) name2 = ((PlayerInfo*)(peer->data))->displayName = "`4@" + bettername;
												else if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 3) name2 = ((PlayerInfo*)(peer->data))->displayName = "`6@" + bettername;
												else if (haveSubscription(peer))  name2 = ((PlayerInfo*)(peer->data))->displayName = "`e[VIP] ```w" + bettername;
												else name2 = ((PlayerInfo*)(peer->data))->displayName = bettername;
												ENetPeer* currentPeer;

												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
														continue;

													if (isHere(peer, currentPeer))
													{
														((PlayerInfo*)(peer->data))->displayName = name2;
														((PlayerInfo*)(peer->data))->isNicked = false;
														GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), name2));

														memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);

														enet_peer_send(currentPeer, 0, packet2);
														delete p2.data;
													}
												}
											}
											((PlayerInfo*)(event.peer->data))->cloth6 = 0;
											((PlayerInfo*)(event.peer->data))->canDoubleJump = false;
											sendState(peer);
											break;
										}
										{
											((PlayerInfo*)(event.peer->data))->cloth6 = pMov->plantingTree;
											int item = pMov->plantingTree;
											((PlayerInfo*)(event.peer->data))->canDoubleJump = true;
											if (pMov->plantingTree == 8552)
											{
												Player::OnNameChanged(peer, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->displayName = "`4Dr." + ((PlayerInfo*)(peer->data))->tankIDName);
												((PlayerInfo*)(peer->data))->displayName = "`4Dr." + ((PlayerInfo*)(peer->data))->tankIDName;
											}
											sendState(peer);
											// ^^^^ wings
										}
										break;
									case MASK:
										if (((PlayerInfo*)(event.peer->data))->cloth7 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth7 = 0;
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth7 = pMov->plantingTree;
										break;
									case NECKLACE:
										if (((PlayerInfo*)(event.peer->data))->cloth8 == pMov->plantingTree)
										{
											if (pMov->plantingTree == 11560 || pMov->plantingTree == 11554 || pMov->plantingTree == 11556 || pMov->plantingTree == 11558) {
												if (((PlayerInfo*)(peer->data))->transform == 1929312) ((PlayerInfo*)(peer->data))->transform = 256;
											}
											((PlayerInfo*)(event.peer->data))->cloth8 = 0;
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth8 = pMov->plantingTree;
										break;
									case ANCES:
										if (((PlayerInfo*)(event.peer->data))->cloth9 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth9 = 0;
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth9 = pMov->plantingTree;
										break;
									default:
#ifdef TOTAL_LOG
										cout << "Invalid item activated: " << pMov->plantingTree << " by " << ((PlayerInfo*)(event.peer->data))->displayName << endl;
#endif
										break;
									}
									sendClothes(peer);
									sendState(peer);
									// activate item
								END_CLOTHSETTER_FORCE:;
								}
								catch (std::exception& e) {
									std::cout << e.what() << std::endl;
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
							}
							if (pMov->packetType == 18)
							{
								sendPData(peer, pMov);
								// add talk buble
							}
							if (pMov->punchX != -1 && pMov->punchY != -1) {
								//cout << pMov->packetType << endl;
								if (pMov->packetType == 3)
								{
									try {
										if (((PlayerInfo*)(peer->data))->isInvisible) {
											Player::OnTextOverlay(peer, "Cannot break while invisible.");
											continue;
										}
										int maxX = (((PlayerInfo*)(peer->data))->x / 32) + 4, maxY = (((PlayerInfo*)(peer->data))->y / 32) + 4, maxX2 = (((PlayerInfo*)(peer->data))->x / 32) - 4, maxY2 = (((PlayerInfo*)(peer->data))->y / 32) - 4, xx = pMov->punchX, yy = pMov->punchY;
										if (xx > maxX || yy > maxY || xx < maxX2 || yy < maxY2)
										{
											if (((PlayerInfo*)(peer->data))->adminLevel == 0) break;
										}
										if (pMov->plantingTree == 18) {
											if (((PlayerInfo*)(peer->data))->transform == 524544 || ((PlayerInfo*)(peer->data))->transform == 1929312 || ((PlayerInfo*)(peer->data))->transform == 262400) {
												sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
												break;
											}
											if (((PlayerInfo*)(peer->data))->cloth_hand == 5480) {
												if (HasItemsInInv(peer, 5480, 1) == -1) break;
												if (world->items.at(pMov->punchX + (pMov->punchY * 100)).foreground == 0 and world->items.at(pMov->punchX + (pMov->punchY * 100)).background == 0) break;
												if (((PlayerInfo*)(event.peer->data))->cloth_face != 4288) {
													if (((PlayerInfo*)(event.peer->data))->isRotatedLeft = pMov->characterState & 0x10) {
														((PlayerInfo*)(event.peer->data))->isRotatedLeft = true;
													}
													else {
														((PlayerInfo*)(event.peer->data))->isRotatedLeft = false;
													}
													if (pMov->punchY == ((PlayerInfo*)(event.peer->data))->y / 32) {
														if (((PlayerInfo*)(event.peer->data))->isRotatedLeft == true) {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 1, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 2, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 3, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
														else {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 1, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 2, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 3, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
													}
													else if (pMov->punchX == ((PlayerInfo*)(event.peer->data))->x / 32) {
														if (pMov->punchY > ((PlayerInfo*)(event.peer->data))->y / 32) {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX, pMov->punchY + 1, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX, pMov->punchY + 2, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX, pMov->punchY + 3, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
														else if (pMov->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX, pMov->punchY - 1, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX, pMov->punchY - 2, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX, pMov->punchY - 3, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
													}
													else if (pMov->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
														if (((PlayerInfo*)(event.peer->data))->isRotatedLeft == true) {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 1, pMov->punchY - 1, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 2, pMov->punchY - 2, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 3, pMov->punchY - 3, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
														else {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 1, pMov->punchY - 1, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 2, pMov->punchY - 2, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 3, pMov->punchY - 3, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
													}
													else if (pMov->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
														if (((PlayerInfo*)(event.peer->data))->isRotatedLeft == true) {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 1, pMov->punchY - 1, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 2, pMov->punchY - 2, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 3, pMov->punchY - 3, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
														else {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 1, pMov->punchY - 1, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 2, pMov->punchY - 2, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 3, pMov->punchY - 3, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
													}
													else if (pMov->punchY > ((PlayerInfo*)(event.peer->data))->y / 32) {
														if (((PlayerInfo*)(event.peer->data))->isRotatedLeft == true) {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 1, pMov->punchY + 1, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 2, pMov->punchY + 2, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX - 3, pMov->punchY + 3, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}
														else {
															sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 1, pMov->punchY + 1, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 2, pMov->punchY + 2, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															sendTileUpdate(world, pMov->punchX + 3, pMov->punchY + 3, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
														}

													}
												}
											}
											else {
												sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
											}
										}
										else {
											if (HasItemsInInv(peer, pMov->plantingTree, 1) != -1) sendTileUpdate(world, pMov->punchX, pMov->punchY, pMov->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
										}
									} catch (std::exception& e) {
										std::cout << e.what() << std::endl;
									} catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
							}
							delete pMov;
						}

						else {
							cout << "Got bad tank packet";
						}
					}
				}
				break;
				case 5:
					break;
				case 6:
#ifdef TOTAL_LOG
					printf("Login Data append..");
#endif
					//cout << GetTextPointerFromPacket(event.packet) << endl;
					break;
				}
				enet_packet_destroy(event.packet);
				break;
			}
			case ENET_EVENT_TYPE_DISCONNECT:
#ifdef TOTAL_LOG
				printf("<if (condition=good)>.\n");
#endif
				ENetPeer* currentPeer;
				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
						continue;
					if (find(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != ((PlayerInfo*)(peer->data))->friendinfo.end()) {
						Player::PlayAudio(currentPeer, "audio/friend_logoff.wav", 0);
						Player::OnConsoleMessage(currentPeer, "`3FRIEND ALERT : `w" + ((PlayerInfo*)(peer->data))->displayName + "`o Logged `4OFFLINE!");
					}
				}

				if (((PlayerInfo*)(peer->data))->isIn) {
					if (((PlayerInfo*)(peer->data))->haveGrowId) {
						if (not ((PlayerInfo*)(peer->data))->disconnect_) {
							try {
								PlayerInfo* p = ((PlayerInfo*)(peer->data));
								json inv = json::array();
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									json d;
									d["id"] = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID;
									d["count"] = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
									inv.push_back(d);
								}
								ifstream read_player("players/" + p->rawName + ".json");
								if (!read_player.is_open()) {
									break;
								}
								json j;
								read_player >> j;
								read_player.close();
								j["username"] = p->rawName;
								j["password"] = p->tankIDPass;
								j["gems"] = p->gems;
								j["adminLevel"] = p->adminLevel;
								j["userID"] = p->userID;
								j["xp"] = p->xp;
								j["level"] = p->level;
								j["hair"] = p->cloth_hair;
								j["shirt"] = p->cloth_shirt;
								j["skin"] = p->skinColor;
								j["hand"] = p->cloth_hand;
								j["mask"] = p->cloth_mask;
								j["wing"] = p->cloth_back;
								j["neck"] = p->cloth_necklace;
								j["face"] = p->cloth_face;
								j["ances"] = p->cloth_ances;
								j["pants"] = p->cloth_pants;
								j["feet"] = p->cloth_feet;
								j["bannedat"] = p->bandate;
								j["ban"] = p->ban;
								j["bantime"] = p->bantime;
								j["lstep"] = p->lqueststep;
								j["lprogress"] = p->lquestprogress;
								j["ltype"] = p->ltype;
								j["invisize"] = p->inventory.items.size();
								j["size"] = p->inventory.inventorySize;
								j["inventory"] = inv;
								j["xpboost"] = p->xpboost;
								j["xptime"] = p->xptime;
								j["mute"] = p->isDuctaped;
								j["curse"] = p->isCursed;
								j["billboardid"] = p->billboardid;
								j["billboardtab"] = p->billboardtab;
								j["billboardprice"] = p->billboardprice;
								j["billboardperwhat"] = p->billboardperwhat;
								j["cape"] = ((PlayerInfo*)(peer->data))->ItemsOption;
								j["transform"] = p->transform;
								j["friends"] = p->friendinfo;
								j["showloc"] = p->showloc;
								j["enableBName"] = p->blueName;
								j["enableLName"] = p->lName;
								j["pure"] = p->pure_state;
								j["worldsowned"] = p->worldsowned;
								j["pin"] = p->pin;
								ofstream write_player("players/" + p->rawName + ".json");
								write_player << j << std::endl;
								write_player.close();
							}
							catch (std::exception& e) {
								std::cout << e.what() << std::endl;
							}
							catch (const std::out_of_range& e) {
								std::cout << e.what() << std::endl;
							}
						}
					}
				}
				Send_Cancel_Game(peer);
				sendPlayerLeave(peer, (PlayerInfo*)(event.peer->data));
				delete static_cast<ENetPeer*>(event.peer->data);
				event.peer->data = NULL;
			}
		}
	}
	cout << "Program ended??? Huh?" << endl;
	while (1);
	return 0;
}
